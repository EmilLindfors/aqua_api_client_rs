/// Error types.
pub mod error {
    /// Error from a TryFrom or FromStr implementation.
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(
            &self,
            f: &mut ::std::fmt::Formatter<'_>,
        ) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
///BwApiApiAisModelsAisRestPositionDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "cog": {
///      "description": "course over ground (degrees)",
///      "type": "number",
///      "format": "double",
///      "example": 91.1,
///      "nullable": true
///    },
///    "heading": {
///      "type": "number",
///      "format": "double",
///      "example": 91,
///      "nullable": true
///    },
///    "lat": {
///      "type": "number",
///      "format": "double",
///      "example": 63.810734
///    },
///    "lon": {
///      "type": "number",
///      "format": "double",
///      "example": 8.474338
///    },
///    "msgt": {
///      "description": "timestamp of data",
///      "type": "string",
///      "format": "date-time",
///      "example": "2017-12-11T18:08:02.000Z"
///    },
///    "rot": {
///      "description": "rate of turn",
///      "type": "number",
///      "format": "double",
///      "example": 0,
///      "nullable": true
///    },
///    "sog": {
///      "description": "speed over ground",
///      "type": "number",
///      "format": "double",
///      "example": 8.3,
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiAisModelsAisRestPositionDto {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cog: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub heading: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lat: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lon: ::std::option::Option<f64>,
    ///timestamp of data
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub msgt: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub rot: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sog: ::std::option::Option<f64>,
}
impl ::std::convert::From<&BwApiApiAisModelsAisRestPositionDto>
for BwApiApiAisModelsAisRestPositionDto {
    fn from(value: &BwApiApiAisModelsAisRestPositionDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiAisModelsAisRestPositionDto {
    fn default() -> Self {
        Self {
            cog: Default::default(),
            heading: Default::default(),
            lat: Default::default(),
            lon: Default::default(),
            msgt: Default::default(),
            rot: Default::default(),
            sog: Default::default(),
        }
    }
}
impl BwApiApiAisModelsAisRestPositionDto {
    pub fn builder() -> builder::BwApiApiAisModelsAisRestPositionDto {
        Default::default()
    }
}
///BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "category": {
///      "type": "string",
///      "nullable": true
///    },
///    "count": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub category: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount,
> for BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount {
    fn from(
        value: &BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount {
    fn default() -> Self {
        Self {
            category: Default::default(),
            count: Default::default(),
        }
    }
}
impl BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount {
    pub fn builder() -> builder::BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount {
        Default::default()
    }
}
///BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "aquaCultureUpdateTime": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2016-05-30T00:00:00.000Z"
///    },
///    "capacity": {
///      "description": "Site capacity",
///      "type": "number",
///      "format": "double",
///      "example": 6240
///    },
///    "isGreen": {
///      "description": "True if the site has a green production type license",
///      "type": "boolean"
///    },
///    "lat": {
///      "description": "Published location of the site (latitude and longitude in EPSG:4326))",
///      "type": "number",
///      "format": "double",
///      "example": 70.408
///    },
///    "licenses": {
///      "description": "List of licenses valid this week at this site",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.AquacultureRegister.Models.Dto.LicenseDto"
///      },
///      "nullable": true
///    },
///    "localityNo": {
///      "description": "Site id",
///      "type": "integer",
///      "format": "int32",
///      "example": 12345
///    },
///    "lon": {
///      "description": "Published location of the site (latitude and longitude in EPSG:4326))",
///      "type": "number",
///      "format": "double",
///      "example": 26.691334
///    },
///    "municipality": {
///      "description": "Municipality name",
///      "type": "string",
///      "example": "Skodje",
///      "nullable": true
///    },
///    "municipalityNo": {
///      "description": "Municipality number",
///      "type": "string",
///      "example": "1213",
///      "nullable": true
///    },
///    "name": {
///      "description": "Site name",
///      "type": "string",
///      "example": "Skodjefjorden",
///      "nullable": true
///    },
///    "organizations": {
///      "description": "List of organizations that have licenses at this site",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.AquacultureRegister.Models.Dto.OrganizationDto"
///      },
///      "nullable": true
///    },
///    "placement": {
///      "description": "\"SJØ\" for at sea near the coast, \"HAV\" for at sea, or \"LAND\"",
///      "type": "string",
///      "example": "SJØ",
///      "nullable": true
///    },
///    "productionTypes": {
///      "description": "Production type",
///      "type": "string",
///      "example": "Matfisk",
///      "nullable": true
///    },
///    "purposes": {
///      "description": "Site license purpose",
///      "type": "string",
///      "example": "Kommersiell",
///      "nullable": true
///    },
///    "species": {
///      "description": "String with list of species this site has licenses for",
///      "type": "string",
///      "example": "Laks, Ørret, Regnbueørret",
///      "nullable": true
///    },
///    "speciesList": {
///      "description": "List of species this site has licenses for",
///      "type": "array",
///      "items": {
///        "type": "string"
///      },
///      "nullable": true
///    },
///    "unit": {
///      "description": "Site capacity unit",
///      "type": "string",
///      "example": "TN",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto {
    #[serde(
        rename = "aquaCultureUpdateTime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub aqua_culture_update_time: ::std::option::Option<
        chrono::DateTime<chrono::offset::Utc>,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub capacity: ::std::option::Option<f64>,
    ///True if the site has a green production type license
    #[serde(
        rename = "isGreen",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_green: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lat: ::std::option::Option<f64>,
    ///List of licenses valid this week at this site
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub licenses: ::std::vec::Vec<BwApiApiAquacultureRegisterModelsDtoLicenseDto>,
    ///Site id
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lon: ::std::option::Option<f64>,
    ///Municipality name
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub municipality: ::std::option::Option<::std::string::String>,
    ///Municipality number
    #[serde(
        rename = "municipalityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_no: ::std::option::Option<::std::string::String>,
    ///Site name
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    ///List of organizations that have licenses at this site
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub organizations: ::std::vec::Vec<
        BwApiApiAquacultureRegisterModelsDtoOrganizationDto,
    >,
    ///"SJØ" for at sea near the coast, "HAV" for at sea, or "LAND"
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub placement: ::std::option::Option<::std::string::String>,
    ///Production type
    #[serde(
        rename = "productionTypes",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_types: ::std::option::Option<::std::string::String>,
    ///Site license purpose
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub purposes: ::std::option::Option<::std::string::String>,
    ///String with list of species this site has licenses for
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub species: ::std::option::Option<::std::string::String>,
    ///List of species this site has licenses for
    #[serde(
        rename = "speciesList",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub species_list: ::std::vec::Vec<::std::string::String>,
    ///Site capacity unit
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub unit: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto>
for BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto {
    fn from(value: &BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto {
    fn default() -> Self {
        Self {
            aqua_culture_update_time: Default::default(),
            capacity: Default::default(),
            is_green: Default::default(),
            lat: Default::default(),
            licenses: Default::default(),
            locality_no: Default::default(),
            lon: Default::default(),
            municipality: Default::default(),
            municipality_no: Default::default(),
            name: Default::default(),
            organizations: Default::default(),
            placement: Default::default(),
            production_types: Default::default(),
            purposes: Default::default(),
            species: Default::default(),
            species_list: Default::default(),
            unit: Default::default(),
        }
    }
}
impl BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto {
    pub fn builder() -> builder::BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto {
        Default::default()
    }
}
///BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "isReportingLocality": {
///      "type": "boolean"
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "municipality": {
///      "type": "string",
///      "nullable": true
///    },
///    "name": {
///      "type": "string",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink {
    #[serde(
        rename = "isReportingLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_reporting_locality: ::std::option::Option<bool>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub municipality: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink>
for BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink {
    fn from(
        value: &BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink {
    fn default() -> Self {
        Self {
            is_reporting_locality: Default::default(),
            locality_no: Default::default(),
            municipality: Default::default(),
            name: Default::default(),
        }
    }
}
impl BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink {
    pub fn builder() -> builder::BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink {
        Default::default()
    }
}
///BwApiApiAquacultureRegisterModelsDtoLicenseDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "capacity": {
///      "description": "Maximum production capacity for this license",
///      "type": "number",
///      "format": "double",
///      "example": 780
///    },
///    "expirationDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "grantDate": {
///      "type": "string",
///      "format": "date-time",
///      "example": "1973-12-04T00:00:00.000Z",
///      "nullable": true
///    },
///    "isGreen": {
///      "description": "True if the production type is any of the green production types",
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "licenseNo": {
///      "description": "Aquaculture license id",
///      "type": "string",
///      "example": "XXXX0001",
///      "nullable": true
///    },
///    "licensee": {
///      "type": "string",
///      "example": "LAKSEFIRMA AS",
///      "nullable": true
///    },
///    "localities": {
///      "description": "List of sites this license is valid for",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.AquacultureRegister.Models.Dto.AquacultureLocalityLink"
///      },
///      "nullable": true
///    },
///    "productionType": {
///      "type": "string",
///      "example": "Matfisk",
///      "nullable": true
///    },
///    "purpose": {
///      "type": "string",
///      "example": "Kommersiell",
///      "nullable": true
///    },
///    "species": {
///      "type": "array",
///      "items": {
///        "type": "string"
///      },
///      "nullable": true
///    },
///    "unit": {
///      "description": "Capacity unit",
///      "type": "string",
///      "example": "TN",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiAquacultureRegisterModelsDtoLicenseDto {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub capacity: ::std::option::Option<f64>,
    #[serde(
        rename = "expirationDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub expiration_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "grantDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub grant_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    ///True if the production type is any of the green production types
    #[serde(
        rename = "isGreen",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_green: ::std::option::Option<bool>,
    ///Aquaculture license id
    #[serde(
        rename = "licenseNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub license_no: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub licensee: ::std::option::Option<::std::string::String>,
    ///List of sites this license is valid for
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub localities: ::std::vec::Vec<
        BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink,
    >,
    #[serde(
        rename = "productionType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_type: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub purpose: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub species: ::std::vec::Vec<::std::string::String>,
    ///Capacity unit
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub unit: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiAquacultureRegisterModelsDtoLicenseDto>
for BwApiApiAquacultureRegisterModelsDtoLicenseDto {
    fn from(value: &BwApiApiAquacultureRegisterModelsDtoLicenseDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiAquacultureRegisterModelsDtoLicenseDto {
    fn default() -> Self {
        Self {
            capacity: Default::default(),
            expiration_date: Default::default(),
            grant_date: Default::default(),
            is_green: Default::default(),
            license_no: Default::default(),
            licensee: Default::default(),
            localities: Default::default(),
            production_type: Default::default(),
            purpose: Default::default(),
            species: Default::default(),
            unit: Default::default(),
        }
    }
}
impl BwApiApiAquacultureRegisterModelsDtoLicenseDto {
    pub fn builder() -> builder::BwApiApiAquacultureRegisterModelsDtoLicenseDto {
        Default::default()
    }
}
///BwApiApiAquacultureRegisterModelsDtoOrganizationDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "address": {
///      "type": "string",
///      "example": "Fjordgata 66",
///      "nullable": true
///    },
///    "city": {
///      "type": "string",
///      "example": "Ålesund",
///      "nullable": true
///    },
///    "localities": {
///      "description": "List of other sites this organization is related to",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.AquacultureRegister.Models.Dto.AquacultureLocalityLink"
///      },
///      "nullable": true
///    },
///    "name": {
///      "type": "string",
///      "example": "Fjordlaks AS",
///      "nullable": true
///    },
///    "organizationNo": {
///      "type": "string",
///      "example": "123456789",
///      "nullable": true
///    },
///    "postalCode": {
///      "type": "string",
///      "example": "6005",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiAquacultureRegisterModelsDtoOrganizationDto {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub address: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub city: ::std::option::Option<::std::string::String>,
    ///List of other sites this organization is related to
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub localities: ::std::vec::Vec<
        BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "organizationNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub organization_no: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "postalCode",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub postal_code: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiAquacultureRegisterModelsDtoOrganizationDto>
for BwApiApiAquacultureRegisterModelsDtoOrganizationDto {
    fn from(value: &BwApiApiAquacultureRegisterModelsDtoOrganizationDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiAquacultureRegisterModelsDtoOrganizationDto {
    fn default() -> Self {
        Self {
            address: Default::default(),
            city: Default::default(),
            localities: Default::default(),
            name: Default::default(),
            organization_no: Default::default(),
            postal_code: Default::default(),
        }
    }
}
impl BwApiApiAquacultureRegisterModelsDtoOrganizationDto {
    pub fn builder() -> builder::BwApiApiAquacultureRegisterModelsDtoOrganizationDto {
        Default::default()
    }
}
///BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "name": {
///      "type": "string",
///      "example": "FISK1 AS",
///      "nullable": true
///    },
///    "orgNo": {
///      "description": "Organization number",
///      "type": "integer",
///      "format": "int32",
///      "example": 123456789,
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    ///Organization number
    #[serde(
        rename = "orgNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub org_no: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto>
for BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto {
    fn from(value: &BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto {
    fn default() -> Self {
        Self {
            name: Default::default(),
            org_no: Default::default(),
        }
    }
}
impl BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto {
    pub fn builder() -> builder::BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto {
        Default::default()
    }
}
///BwApiApiAquacultureRegisterModelsDtoSpecies
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "id": {
///      "type": "string",
///      "example": "liten kantål",
///      "nullable": true
///    },
///    "name": {
///      "type": "string",
///      "example": "Liten kantål",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiAquacultureRegisterModelsDtoSpecies {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiAquacultureRegisterModelsDtoSpecies>
for BwApiApiAquacultureRegisterModelsDtoSpecies {
    fn from(value: &BwApiApiAquacultureRegisterModelsDtoSpecies) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiAquacultureRegisterModelsDtoSpecies {
    fn default() -> Self {
        Self {
            id: Default::default(),
            name: Default::default(),
        }
    }
}
impl BwApiApiAquacultureRegisterModelsDtoSpecies {
    pub fn builder() -> builder::BwApiApiAquacultureRegisterModelsDtoSpecies {
        Default::default()
    }
}
///BwApiApiCodSpawningGroundModelsCodSpawningGroundDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "areaDescription": {
///      "type": "string",
///      "example": "Lav eggtetthet (1), lav retensjon (1)",
///      "nullable": true
///    },
///    "bmvalue": {
///      "description": "A (national), B (regional), C (locally)",
///      "type": "string",
///      "example": "B",
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "description": "Id",
///      "type": "integer",
///      "format": "int32",
///      "example": 384
///    },
///    "information": {
///      "type": "string",
///      "example": "Lokalt viktig gytefelt",
///      "nullable": true
///    },
///    "origin": {
///      "type": "string",
///      "example": "Havforskningsinstituttet",
///      "nullable": true
///    },
///    "placeName": {
///      "type": "string",
///      "example": "Meltefjorden",
///      "nullable": true
///    },
///    "registeredDate": {
///      "type": "string",
///      "format": "date-time"
///    },
///    "value": {
///      "description": "Value of codspawningground (1-6)",
///      "type": "integer",
///      "format": "int32",
///      "example": 4
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCodSpawningGroundModelsCodSpawningGroundDto {
    #[serde(
        rename = "areaDescription",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub area_description: ::std::option::Option<::std::string::String>,
    ///A (national), B (regional), C (locally)
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub bmvalue: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    ///Id
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub information: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub origin: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "placeName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub place_name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "registeredDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub registered_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    ///Value of codspawningground (1-6)
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub value: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiCodSpawningGroundModelsCodSpawningGroundDto>
for BwApiApiCodSpawningGroundModelsCodSpawningGroundDto {
    fn from(value: &BwApiApiCodSpawningGroundModelsCodSpawningGroundDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiCodSpawningGroundModelsCodSpawningGroundDto {
    fn default() -> Self {
        Self {
            area_description: Default::default(),
            bmvalue: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            information: Default::default(),
            origin: Default::default(),
            place_name: Default::default(),
            registered_date: Default::default(),
            value: Default::default(),
        }
    }
}
impl BwApiApiCodSpawningGroundModelsCodSpawningGroundDto {
    pub fn builder() -> builder::BwApiApiCodSpawningGroundModelsCodSpawningGroundDto {
        Default::default()
    }
}
///BwApiApiControlAreasModelsControlAreaLinkV1
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "forskLink": {
///      "type": "string",
///      "nullable": true
///    },
///    "forskNavn": {
///      "type": "string",
///      "nullable": true
///    },
///    "forskNr": {
///      "type": "string",
///      "nullable": true
///    },
///    "fromDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "originalDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "sistEndret": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "toDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "version": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiControlAreasModelsControlAreaLinkV1 {
    #[serde(
        rename = "forskLink",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_link: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "forskNavn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_navn: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "forskNr",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_nr: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "fromDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(
        rename = "originalDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub original_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "sistEndret",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub sist_endret: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "toDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub version: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiControlAreasModelsControlAreaLinkV1>
for BwApiApiControlAreasModelsControlAreaLinkV1 {
    fn from(value: &BwApiApiControlAreasModelsControlAreaLinkV1) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiControlAreasModelsControlAreaLinkV1 {
    fn default() -> Self {
        Self {
            forsk_link: Default::default(),
            forsk_navn: Default::default(),
            forsk_nr: Default::default(),
            from_date: Default::default(),
            id: Default::default(),
            original_date: Default::default(),
            sist_endret: Default::default(),
            to_date: Default::default(),
            version: Default::default(),
        }
    }
}
impl BwApiApiControlAreasModelsControlAreaLinkV1 {
    pub fn builder() -> builder::BwApiApiControlAreasModelsControlAreaLinkV1 {
        Default::default()
    }
}
///BwApiApiControlAreasModelsIlaControlArea
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "forskLink": {
///      "type": "string",
///      "nullable": true
///    },
///    "forskNavn": {
///      "type": "string",
///      "nullable": true
///    },
///    "forskNr": {
///      "type": "string",
///      "nullable": true
///    },
///    "fromDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "originalDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "sistEndret": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "toDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "version": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiControlAreasModelsIlaControlArea {
    #[serde(
        rename = "forskLink",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_link: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "forskNavn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_navn: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "forskNr",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_nr: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "fromDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(
        rename = "originalDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub original_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "sistEndret",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub sist_endret: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "toDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub version: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiControlAreasModelsIlaControlArea>
for BwApiApiControlAreasModelsIlaControlArea {
    fn from(value: &BwApiApiControlAreasModelsIlaControlArea) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiControlAreasModelsIlaControlArea {
    fn default() -> Self {
        Self {
            forsk_link: Default::default(),
            forsk_navn: Default::default(),
            forsk_nr: Default::default(),
            from_date: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            original_date: Default::default(),
            sist_endret: Default::default(),
            to_date: Default::default(),
            version: Default::default(),
        }
    }
}
impl BwApiApiControlAreasModelsIlaControlArea {
    pub fn builder() -> builder::BwApiApiControlAreasModelsIlaControlArea {
        Default::default()
    }
}
///BwApiApiControlAreasModelsIlaControlAreaDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "forskLink": {
///      "type": "string",
///      "example": "https://lovdata.no/dokument/FV/forskrift/2016-02-10-116",
///      "nullable": true
///    },
///    "forskNavn": {
///      "type": "string",
///      "example": "Forskrift om kontrollområde for ...",
///      "nullable": true
///    },
///    "forskNr": {
///      "type": "string",
///      "example": "FOR-2016-02-10-116",
///      "nullable": true
///    },
///    "fromDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32",
///      "example": 3
///    },
///    "localities": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.IlaControlAreaLocalityLink"
///      },
///      "nullable": true
///    },
///    "originalDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "sistEndret": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2016-07-01T00:00:00.000Z",
///      "nullable": true
///    },
///    "toDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiControlAreasModelsIlaControlAreaDto {
    #[serde(
        rename = "forskLink",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_link: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "forskNavn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_navn: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "forskNr",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_nr: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "fromDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub localities: ::std::vec::Vec<
        BwApiApiControlAreasModelsIlaControlAreaLocalityLink,
    >,
    #[serde(
        rename = "originalDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub original_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "sistEndret",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub sist_endret: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "toDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiControlAreasModelsIlaControlAreaDto>
for BwApiApiControlAreasModelsIlaControlAreaDto {
    fn from(value: &BwApiApiControlAreasModelsIlaControlAreaDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiControlAreasModelsIlaControlAreaDto {
    fn default() -> Self {
        Self {
            forsk_link: Default::default(),
            forsk_navn: Default::default(),
            forsk_nr: Default::default(),
            from_date: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            localities: Default::default(),
            original_date: Default::default(),
            sist_endret: Default::default(),
            to_date: Default::default(),
        }
    }
}
impl BwApiApiControlAreasModelsIlaControlAreaDto {
    pub fn builder() -> builder::BwApiApiControlAreasModelsIlaControlAreaDto {
        Default::default()
    }
}
///BwApiApiControlAreasModelsIlaControlAreaLocalityLink
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "ilaConfirmed": {
///      "type": "boolean"
///    },
///    "ilaSuspected": {
///      "type": "boolean"
///    },
///    "isReportingLocality": {
///      "type": "boolean"
///    },
///    "localityNo": {
///      "description": "Site id",
///      "type": "integer",
///      "format": "int32",
///      "example": 12345
///    },
///    "name": {
///      "type": "string",
///      "example": "Dragsundet",
///      "nullable": true
///    },
///    "position": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiControlAreasModelsIlaControlAreaLocalityLink {
    #[serde(
        rename = "ilaConfirmed",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ila_confirmed: ::std::option::Option<bool>,
    #[serde(
        rename = "ilaSuspected",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ila_suspected: ::std::option::Option<bool>,
    #[serde(
        rename = "isReportingLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_reporting_locality: ::std::option::Option<bool>,
    ///Site id
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub position: ::std::option::Option<GeoJsonGeometry>,
}
impl ::std::convert::From<&BwApiApiControlAreasModelsIlaControlAreaLocalityLink>
for BwApiApiControlAreasModelsIlaControlAreaLocalityLink {
    fn from(value: &BwApiApiControlAreasModelsIlaControlAreaLocalityLink) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiControlAreasModelsIlaControlAreaLocalityLink {
    fn default() -> Self {
        Self {
            ila_confirmed: Default::default(),
            ila_suspected: Default::default(),
            is_reporting_locality: Default::default(),
            locality_no: Default::default(),
            name: Default::default(),
            position: Default::default(),
        }
    }
}
impl BwApiApiControlAreasModelsIlaControlAreaLocalityLink {
    pub fn builder() -> builder::BwApiApiControlAreasModelsIlaControlAreaLocalityLink {
        Default::default()
    }
}
///BwApiApiControlAreasModelsPdControlArea
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "forskLink": {
///      "type": "string",
///      "nullable": true
///    },
///    "forskNavn": {
///      "type": "string",
///      "nullable": true
///    },
///    "forskNr": {
///      "type": "string",
///      "nullable": true
///    },
///    "fromDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "originalDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "sistEndret": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "toDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "version": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiControlAreasModelsPdControlArea {
    #[serde(
        rename = "forskLink",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_link: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "forskNavn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_navn: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "forskNr",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_nr: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "fromDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(
        rename = "originalDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub original_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "sistEndret",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub sist_endret: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "toDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub version: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiControlAreasModelsPdControlArea>
for BwApiApiControlAreasModelsPdControlArea {
    fn from(value: &BwApiApiControlAreasModelsPdControlArea) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiControlAreasModelsPdControlArea {
    fn default() -> Self {
        Self {
            forsk_link: Default::default(),
            forsk_navn: Default::default(),
            forsk_nr: Default::default(),
            from_date: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            original_date: Default::default(),
            sist_endret: Default::default(),
            to_date: Default::default(),
            version: Default::default(),
        }
    }
}
impl BwApiApiControlAreasModelsPdControlArea {
    pub fn builder() -> builder::BwApiApiControlAreasModelsPdControlArea {
        Default::default()
    }
}
///BwApiApiControlAreasModelsPdControlAreaDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "forskLink": {
///      "type": "string",
///      "example": "https://lovdata.no/dokument/FV/forskrift/2016-02-10-116",
///      "nullable": true
///    },
///    "forskNavn": {
///      "type": "string",
///      "example": "Forskrift om kontrollområde for ...",
///      "nullable": true
///    },
///    "forskNr": {
///      "type": "string",
///      "example": "FOR-2016-02-10-116",
///      "nullable": true
///    },
///    "fromDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32",
///      "example": 3
///    },
///    "localities": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.PdControlAreaLocalityLink"
///      },
///      "nullable": true
///    },
///    "originalDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "sistEndret": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2016-07-01T00:00:00.000Z",
///      "nullable": true
///    },
///    "toDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiControlAreasModelsPdControlAreaDto {
    #[serde(
        rename = "forskLink",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_link: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "forskNavn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_navn: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "forskNr",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forsk_nr: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "fromDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub localities: ::std::vec::Vec<BwApiApiControlAreasModelsPdControlAreaLocalityLink>,
    #[serde(
        rename = "originalDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub original_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "sistEndret",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub sist_endret: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "toDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiControlAreasModelsPdControlAreaDto>
for BwApiApiControlAreasModelsPdControlAreaDto {
    fn from(value: &BwApiApiControlAreasModelsPdControlAreaDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiControlAreasModelsPdControlAreaDto {
    fn default() -> Self {
        Self {
            forsk_link: Default::default(),
            forsk_navn: Default::default(),
            forsk_nr: Default::default(),
            from_date: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            localities: Default::default(),
            original_date: Default::default(),
            sist_endret: Default::default(),
            to_date: Default::default(),
        }
    }
}
impl BwApiApiControlAreasModelsPdControlAreaDto {
    pub fn builder() -> builder::BwApiApiControlAreasModelsPdControlAreaDto {
        Default::default()
    }
}
///BwApiApiControlAreasModelsPdControlAreaLocalityLink
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "isReportingLocality": {
///      "type": "boolean"
///    },
///    "localityNo": {
///      "description": "Site id",
///      "type": "integer",
///      "format": "int32",
///      "example": 12345
///    },
///    "name": {
///      "type": "string",
///      "example": "Dragsundet",
///      "nullable": true
///    },
///    "pdConfirmed": {
///      "type": "boolean"
///    },
///    "pdSuspected": {
///      "type": "boolean"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiControlAreasModelsPdControlAreaLocalityLink {
    #[serde(
        rename = "isReportingLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_reporting_locality: ::std::option::Option<bool>,
    ///Site id
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "pdConfirmed",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub pd_confirmed: ::std::option::Option<bool>,
    #[serde(
        rename = "pdSuspected",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub pd_suspected: ::std::option::Option<bool>,
}
impl ::std::convert::From<&BwApiApiControlAreasModelsPdControlAreaLocalityLink>
for BwApiApiControlAreasModelsPdControlAreaLocalityLink {
    fn from(value: &BwApiApiControlAreasModelsPdControlAreaLocalityLink) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiControlAreasModelsPdControlAreaLocalityLink {
    fn default() -> Self {
        Self {
            is_reporting_locality: Default::default(),
            locality_no: Default::default(),
            name: Default::default(),
            pd_confirmed: Default::default(),
            pd_suspected: Default::default(),
        }
    }
}
impl BwApiApiControlAreasModelsPdControlAreaLocalityLink {
    pub fn builder() -> builder::BwApiApiControlAreasModelsPdControlAreaLocalityLink {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "count": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "type": {
///      "type": "string",
///      "nullable": true
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i32>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount,
> for BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount {
    fn default() -> Self {
        Self {
            count: Default::default(),
            type_: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMomBCondition
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "VeryGood",
///    "Good",
///    "Poor",
///    "VeryPoor"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BwApiApiCountyAndMunicipalityModelsMomBCondition {
    VeryGood,
    Good,
    Poor,
    VeryPoor,
}
impl ::std::convert::From<&Self> for BwApiApiCountyAndMunicipalityModelsMomBCondition {
    fn from(value: &BwApiApiCountyAndMunicipalityModelsMomBCondition) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BwApiApiCountyAndMunicipalityModelsMomBCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::VeryGood => write!(f, "VeryGood"),
            Self::Good => write!(f, "Good"),
            Self::Poor => write!(f, "Poor"),
            Self::VeryPoor => write!(f, "VeryPoor"),
        }
    }
}
impl ::std::str::FromStr for BwApiApiCountyAndMunicipalityModelsMomBCondition {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "VeryGood" => Ok(Self::VeryGood),
            "Good" => Ok(Self::Good),
            "Poor" => Ok(Self::Poor),
            "VeryPoor" => Ok(Self::VeryPoor),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BwApiApiCountyAndMunicipalityModelsMomBCondition {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for BwApiApiCountyAndMunicipalityModelsMomBCondition {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for BwApiApiCountyAndMunicipalityModelsMomBCondition {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "condition": {
///      "$ref": "#/components/schemas/BW.Api.Api.CountyAndMunicipality.Models.MomBCondition"
///    },
///    "count": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "municipalityNumber": {
///      "type": "string",
///      "nullable": true
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub condition: ::std::option::Option<
        BwApiApiCountyAndMunicipalityModelsMomBCondition,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i32>,
    #[serde(
        rename = "municipalityNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_number: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount>
for BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount {
    fn from(value: &BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount {
    fn default() -> Self {
        Self {
            condition: Default::default(),
            count: Default::default(),
            municipality_number: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityArea
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "alternativeNames": {
///      "type": "object",
///      "additionalProperties": {
///        "type": "string",
///        "nullable": true
///      },
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "isSamiTerritory": {
///      "type": "boolean"
///    },
///    "name": {
///      "type": "string",
///      "nullable": true
///    },
///    "nameNo": {
///      "type": "string",
///      "nullable": true
///    },
///    "number": {
///      "type": "string",
///      "nullable": true
///    },
///    "retrieved": {
///      "type": "string",
///      "format": "date-time"
///    },
///    "updated": {
///      "type": "string",
///      "format": "date-time"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityArea {
    #[serde(
        rename = "alternativeNames",
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub alternative_names: ::std::collections::HashMap<
        ::std::string::String,
        ::std::string::String,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(
        rename = "isSamiTerritory",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_sami_territory: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "nameNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub name_no: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub number: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub retrieved: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub updated: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiCountyAndMunicipalityModelsMunicipalityArea>
for BwApiApiCountyAndMunicipalityModelsMunicipalityArea {
    fn from(value: &BwApiApiCountyAndMunicipalityModelsMunicipalityArea) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiCountyAndMunicipalityModelsMunicipalityArea {
    fn default() -> Self {
        Self {
            alternative_names: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            is_sami_territory: Default::default(),
            name: Default::default(),
            name_no: Default::default(),
            number: Default::default(),
            retrieved: Default::default(),
            updated: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalityArea {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalityArea {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "capacity": {
///      "type": "number",
///      "format": "double"
///    },
///    "municipalityNumber": {
///      "type": "string",
///      "nullable": true
///    },
///    "type": {
///      "$ref": "#/components/schemas/BW.Api.Api.CountyAndMunicipality.Models.MunicipalityCapacityType"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub capacity: ::std::option::Option<f64>,
    #[serde(
        rename = "municipalityNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_number: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<
        BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics,
> for BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics {
    fn default() -> Self {
        Self {
            capacity: Default::default(),
            municipality_number: Default::default(),
            type_: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "Salmonoids",
///    "Other"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType {
    Salmonoids,
    Other,
}
impl ::std::convert::From<&Self>
for BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType,
    ) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display
for BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Salmonoids => write!(f, "Salmonoids"),
            Self::Other => write!(f, "Other"),
        }
    }
}
impl ::std::str::FromStr
for BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Salmonoids" => Ok(Self::Salmonoids),
            "Other" => Ok(Self::Other),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
for BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "count": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "municipalityNumber": {
///      "type": "string",
///      "nullable": true
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i32>,
    #[serde(
        rename = "municipalityNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_number: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes,
> for BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes {
    fn default() -> Self {
        Self {
            count: Default::default(),
            municipality_number: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "cases": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "municipalityNumber": {
///      "type": "string",
///      "nullable": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cases: ::std::option::Option<i32>,
    #[serde(
        rename = "municipalityNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_number: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics,
> for BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics {
    fn default() -> Self {
        Self {
            cases: Default::default(),
            municipality_number: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "area": {
///      "description": "Area of localities in municipality, in ㎡",
///      "type": "integer",
///      "format": "int32"
///    },
///    "municipality": {
///      "description": "The numerical id of the municipality",
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "municipalityNumber": {
///      "type": "string",
///      "nullable": true
///    },
///    "year": {
///      "description": "The year",
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics {
    ///Area of localities in municipality, in ㎡
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub area: ::std::option::Option<i32>,
    ///The numerical id of the municipality
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub municipality: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "municipalityNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_number: ::std::option::Option<::std::string::String>,
    ///The year
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics,
> for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics {
    fn default() -> Self {
        Self {
            area: Default::default(),
            municipality: Default::default(),
            municipality_number: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "lastUpdated": {
///      "description": "Date of when data was last updated",
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "statistics": {
///      "description": "Statistics items",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.CountyAndMunicipality.Models.MunicipalityLocalityAreaStatistics"
///      },
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary {
    ///Date of when data was last updated
    #[serde(
        rename = "lastUpdated",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub last_updated: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    ///Statistics items
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub statistics: ::std::vec::Vec<
        BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics,
    >,
}
impl ::std::convert::From<
    &BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary,
> for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary {
    fn default() -> Self {
        Self {
            last_updated: Default::default(),
            statistics: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "count": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "municipalityNumber": {
///      "type": "string",
///      "nullable": true
///    },
///    "type": {
///      "$ref": "#/components/schemas/BW.Api.Api.CountyAndMunicipality.Models.MunicipalityLocalityType"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i32>,
    #[serde(
        rename = "municipalityNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_number: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<
        BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics,
> for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics {
    fn default() -> Self {
        Self {
            count: Default::default(),
            municipality_number: Default::default(),
            type_: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "Salmonoids",
///    "EmptySalmonoids",
///    "Other"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType {
    Salmonoids,
    EmptySalmonoids,
    Other,
}
impl ::std::convert::From<&Self>
for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType,
    ) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display
for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Salmonoids => write!(f, "Salmonoids"),
            Self::EmptySalmonoids => write!(f, "EmptySalmonoids"),
            Self::Other => write!(f, "Other"),
        }
    }
}
impl ::std::str::FromStr
for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Salmonoids" => Ok(Self::Salmonoids),
            "EmptySalmonoids" => Ok(Self::EmptySalmonoids),
            "Other" => Ok(Self::Other),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "name": {
///      "type": "string",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization>
for BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization {
    fn default() -> Self {
        Self { name: Default::default() }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "areaUsedSquareMeters": {
///      "type": "number",
///      "format": "double"
///    },
///    "municipalityNumber": {
///      "type": "string",
///      "nullable": true
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage {
    #[serde(
        rename = "areaUsedSquareMeters",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub area_used_square_meters: ::std::option::Option<f64>,
    #[serde(
        rename = "municipalityNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_number: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage>
for BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage {
    fn default() -> Self {
        Self {
            area_used_square_meters: Default::default(),
            municipality_number: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "catch": {
///      "type": "string",
///      "nullable": true
///    },
///    "count": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "species": {
///      "type": "string",
///      "nullable": true
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub catch: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub species: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount,
> for BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount {
    fn default() -> Self {
        Self {
            catch: Default::default(),
            count: Default::default(),
            species: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "municipalityNumber": {
///      "type": "string",
///      "nullable": true
///    },
///    "salmonLiceReportCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "totalReportCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel {
    #[serde(
        rename = "municipalityNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_number: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "salmonLiceReportCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub salmon_lice_report_count: ::std::option::Option<i32>,
    #[serde(
        rename = "totalReportCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub total_report_count: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel,
> for BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel {
    fn default() -> Self {
        Self {
            municipality_number: Default::default(),
            salmon_lice_report_count: Default::default(),
            total_report_count: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel {
        Default::default()
    }
}
///BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "bathTreatmentCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "freshWaterTreatmentCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "inFeedTreatmentCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "mechanicalRemovalCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "mechanicalTreatmentCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "municipalityNumber": {
///      "type": "string",
///      "nullable": true
///    },
///    "otherMedicalTreatmentCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "otherNonMedicalTreatmentCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "thermalTreatmentCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "treatmentYear": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount {
    #[serde(
        rename = "bathTreatmentCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub bath_treatment_count: ::std::option::Option<i32>,
    #[serde(
        rename = "freshWaterTreatmentCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub fresh_water_treatment_count: ::std::option::Option<i32>,
    #[serde(
        rename = "inFeedTreatmentCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub in_feed_treatment_count: ::std::option::Option<i32>,
    #[serde(
        rename = "mechanicalRemovalCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mechanical_removal_count: ::std::option::Option<i32>,
    #[serde(
        rename = "mechanicalTreatmentCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mechanical_treatment_count: ::std::option::Option<i32>,
    #[serde(
        rename = "municipalityNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_number: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "otherMedicalTreatmentCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub other_medical_treatment_count: ::std::option::Option<i32>,
    #[serde(
        rename = "otherNonMedicalTreatmentCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub other_non_medical_treatment_count: ::std::option::Option<i32>,
    #[serde(
        rename = "thermalTreatmentCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub thermal_treatment_count: ::std::option::Option<i32>,
    #[serde(
        rename = "treatmentYear",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub treatment_year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount>
for BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount {
    fn from(
        value: &BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount {
    fn default() -> Self {
        Self {
            bath_treatment_count: Default::default(),
            fresh_water_treatment_count: Default::default(),
            in_feed_treatment_count: Default::default(),
            mechanical_removal_count: Default::default(),
            mechanical_treatment_count: Default::default(),
            municipality_number: Default::default(),
            other_medical_treatment_count: Default::default(),
            other_non_medical_treatment_count: Default::default(),
            thermal_treatment_count: Default::default(),
            treatment_year: Default::default(),
        }
    }
}
impl BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount {
    pub fn builder() -> builder::BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount {
        Default::default()
    }
}
///BwApiApiEscapesModelsEscapesGraphDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "escapes": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Escapes.Models.EscapesWeekDataDto"
///      },
///      "nullable": true
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiEscapesModelsEscapesGraphDataDto {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub escapes: ::std::vec::Vec<BwApiApiEscapesModelsEscapesWeekDataDto>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiEscapesModelsEscapesGraphDataDto>
for BwApiApiEscapesModelsEscapesGraphDataDto {
    fn from(value: &BwApiApiEscapesModelsEscapesGraphDataDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiEscapesModelsEscapesGraphDataDto {
    fn default() -> Self {
        Self {
            escapes: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiEscapesModelsEscapesGraphDataDto {
    pub fn builder() -> builder::BwApiApiEscapesModelsEscapesGraphDataDto {
        Default::default()
    }
}
///BwApiApiEscapesModelsEscapesWeekDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "escapeCases": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiEscapesModelsEscapesWeekDataDto {
    #[serde(
        rename = "escapeCases",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub escape_cases: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiEscapesModelsEscapesWeekDataDto>
for BwApiApiEscapesModelsEscapesWeekDataDto {
    fn from(value: &BwApiApiEscapesModelsEscapesWeekDataDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiEscapesModelsEscapesWeekDataDto {
    fn default() -> Self {
        Self {
            escape_cases: Default::default(),
            week: Default::default(),
        }
    }
}
impl BwApiApiEscapesModelsEscapesWeekDataDto {
    pub fn builder() -> builder::BwApiApiEscapesModelsEscapesWeekDataDto {
        Default::default()
    }
}
///BwApiApiExportRestrictionsModelsExportRestrictionAreaLink
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "localityNo": {
///      "type": "integer",
///      "format": "int64"
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiExportRestrictionsModelsExportRestrictionAreaLink {
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiExportRestrictionsModelsExportRestrictionAreaLink>
for BwApiApiExportRestrictionsModelsExportRestrictionAreaLink {
    fn from(value: &BwApiApiExportRestrictionsModelsExportRestrictionAreaLink) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiExportRestrictionsModelsExportRestrictionAreaLink {
    fn default() -> Self {
        Self {
            locality_no: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiExportRestrictionsModelsExportRestrictionAreaLink {
    pub fn builder() -> builder::BwApiApiExportRestrictionsModelsExportRestrictionAreaLink {
        Default::default()
    }
}
///BwApiApiExportRestrictionsModelsExportRestrictionDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "localities": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.IlaControlAreaLocalityLink"
///      },
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int64"
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiExportRestrictionsModelsExportRestrictionDto {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub localities: ::std::vec::Vec<
        BwApiApiControlAreasModelsIlaControlAreaLocalityLink,
    >,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiExportRestrictionsModelsExportRestrictionDto>
for BwApiApiExportRestrictionsModelsExportRestrictionDto {
    fn from(value: &BwApiApiExportRestrictionsModelsExportRestrictionDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiExportRestrictionsModelsExportRestrictionDto {
    fn default() -> Self {
        Self {
            localities: Default::default(),
            locality_no: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiExportRestrictionsModelsExportRestrictionDto {
    pub fn builder() -> builder::BwApiApiExportRestrictionsModelsExportRestrictionDto {
        Default::default()
    }
}
///BwApiApiFairwaysModelsFairwayDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "fairwayNumber": {
///      "description": "Fairway number",
///      "type": "string",
///      "example": "1125",
///      "nullable": true
///    },
///    "fairwayType": {
///      "description": "Fairway type",
///      "type": "string",
///      "example": "Hovedled",
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "description": "Serial ID, will change when dataset is updated",
///      "type": "integer",
///      "format": "int32",
///      "example": 44384
///    },
///    "objectId": {
///      "description": "Object Id",
///      "type": "integer",
///      "format": "int32",
///      "example": 44384
///    },
///    "placeName": {
///      "description": "Place name",
///      "type": "string",
///      "example": "Meltefjorden",
///      "nullable": true
///    },
///    "region": {
///      "description": "Region",
///      "type": "string",
///      "example": "Nordland",
///      "nullable": true
///    },
///    "status": {
///      "description": "Status",
///      "type": "string",
///      "example": "Eksisterende",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFairwaysModelsFairwayDto {
    ///Fairway number
    #[serde(
        rename = "fairwayNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub fairway_number: ::std::option::Option<::std::string::String>,
    ///Fairway type
    #[serde(
        rename = "fairwayType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub fairway_type: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    ///Serial ID, will change when dataset is updated
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    ///Object Id
    #[serde(
        rename = "objectId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub object_id: ::std::option::Option<i32>,
    ///Place name
    #[serde(
        rename = "placeName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub place_name: ::std::option::Option<::std::string::String>,
    ///Region
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub region: ::std::option::Option<::std::string::String>,
    ///Status
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub status: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiFairwaysModelsFairwayDto>
for BwApiApiFairwaysModelsFairwayDto {
    fn from(value: &BwApiApiFairwaysModelsFairwayDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFairwaysModelsFairwayDto {
    fn default() -> Self {
        Self {
            fairway_number: Default::default(),
            fairway_type: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            object_id: Default::default(),
            place_name: Default::default(),
            region: Default::default(),
            status: Default::default(),
        }
    }
}
impl BwApiApiFairwaysModelsFairwayDto {
    pub fn builder() -> builder::BwApiApiFairwaysModelsFairwayDto {
        Default::default()
    }
}
///BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "cleanerFish": {
///      "type": "boolean"
///    },
///    "comment": {
///      "type": "string",
///      "nullable": true
///    },
///    "count": {
///      "type": "integer",
///      "format": "int32",
///      "example": 1,
///      "nullable": true
///    },
///    "countCategory": {
///      "type": "string",
///      "example": "20-999",
///      "nullable": true
///    },
///    "countEstimated": {
///      "type": "string",
///      "example": "1-19",
///      "nullable": true
///    },
///    "countType": {
///      "type": "string",
///      "example": "estimert #",
///      "nullable": true
///    },
///    "county": {
///      "type": "string",
///      "example": "Trøndelag",
///      "nullable": true
///    },
///    "countyCode": {
///      "type": "integer",
///      "format": "int32",
///      "example": 54
///    },
///    "createdDate": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2016-06-21T00:00:00.000Z",
///      "nullable": true
///    },
///    "date": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2016-06-21T00:00:00.000Z",
///      "nullable": true
///    },
///    "description": {
///      "type": "string",
///      "example": "Fisk falt i havet ved håving",
///      "nullable": true
///    },
///    "globalId": {
///      "type": "string",
///      "example": "{22CA7E34-EBD0-4204-A65E-030252D047DF}",
///      "nullable": true
///    },
///    "lastEditedDate": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2016-06-21T00:00:00.000Z",
///      "nullable": true
///    },
///    "localityCapacity": {
///      "type": "integer",
///      "format": "int32",
///      "example": 150,
///      "nullable": true
///    },
///    "localityName": {
///      "type": "string",
///      "example": "STORFJORDEN",
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int32",
///      "example": 12345
///    },
///    "municipalityNumber": {
///      "type": "integer",
///      "format": "int32",
///      "example": 5421
///    },
///    "objectId": {
///      "type": "integer",
///      "format": "int32",
///      "example": 12345,
///      "nullable": true
///    },
///    "parentId": {
///      "type": "integer",
///      "format": "int32",
///      "example": 1234,
///      "nullable": true
///    },
///    "recaptureDescription": {
///      "type": "string",
///      "example": "Havn er sperret med gjennfangst garn",
///      "nullable": true
///    },
///    "recaptureStarted": {
///      "type": "boolean"
///    },
///    "recapturesCompleted": {
///      "type": "integer",
///      "format": "int32",
///      "example": 1,
///      "nullable": true
///    },
///    "size": {
///      "type": "number",
///      "format": "double",
///      "example": 4000,
///      "nullable": true
///    },
///    "sizeEstimated": {
///      "type": "number",
///      "format": "double",
///      "example": 5500,
///      "nullable": true
///    },
///    "species": {
///      "type": "string",
///      "example": "Laks",
///      "nullable": true
///    },
///    "status": {
///      "type": "string",
///      "example": "Del 2",
///      "nullable": true
///    },
///    "statusLocality": {
///      "type": "string",
///      "example": "KLARERT",
///      "nullable": true
///    },
///    "waterEnvironment": {
///      "type": "string",
///      "example": "SALTVANN",
///      "nullable": true
///    },
///    "waterEnvironmentCode": {
///      "type": "string",
///      "example": "Salt",
///      "nullable": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32",
///      "example": 25
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2016
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto {
    #[serde(
        rename = "cleanerFish",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub cleaner_fish: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub comment: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i32>,
    #[serde(
        rename = "countCategory",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub count_category: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "countEstimated",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub count_estimated: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "countType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub count_type: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub county: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "countyCode",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub county_code: ::std::option::Option<i32>,
    #[serde(
        rename = "createdDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub created_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "globalId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub global_id: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "lastEditedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub last_edited_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "localityCapacity",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_capacity: ::std::option::Option<i32>,
    #[serde(
        rename = "localityName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(
        rename = "municipalityNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_number: ::std::option::Option<i32>,
    #[serde(
        rename = "objectId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub object_id: ::std::option::Option<i32>,
    #[serde(
        rename = "parentId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub parent_id: ::std::option::Option<i32>,
    #[serde(
        rename = "recaptureDescription",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub recapture_description: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "recaptureStarted",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub recapture_started: ::std::option::Option<bool>,
    #[serde(
        rename = "recapturesCompleted",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub recaptures_completed: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub size: ::std::option::Option<f64>,
    #[serde(
        rename = "sizeEstimated",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub size_estimated: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub species: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub status: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "statusLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub status_locality: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "waterEnvironment",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub water_environment: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "waterEnvironmentCode",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub water_environment_code: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>
for BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto {
    fn from(value: &BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto {
    fn default() -> Self {
        Self {
            cleaner_fish: Default::default(),
            comment: Default::default(),
            count: Default::default(),
            count_category: Default::default(),
            count_estimated: Default::default(),
            count_type: Default::default(),
            county: Default::default(),
            county_code: Default::default(),
            created_date: Default::default(),
            date: Default::default(),
            description: Default::default(),
            global_id: Default::default(),
            last_edited_date: Default::default(),
            locality_capacity: Default::default(),
            locality_name: Default::default(),
            locality_no: Default::default(),
            municipality_number: Default::default(),
            object_id: Default::default(),
            parent_id: Default::default(),
            recapture_description: Default::default(),
            recapture_started: Default::default(),
            recaptures_completed: Default::default(),
            size: Default::default(),
            size_estimated: Default::default(),
            species: Default::default(),
            status: Default::default(),
            status_locality: Default::default(),
            water_environment: Default::default(),
            water_environment_code: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto {
    pub fn builder() -> builder::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto {
        Default::default()
    }
}
///BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "escapes": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FarmedFishEscape.Models.FarmedFishEscapeDto"
///      },
///      "nullable": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub escapes: ::std::vec::Vec<BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto>
for BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto {
    fn from(value: &BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto {
    fn default() -> Self {
        Self {
            escapes: Default::default(),
            week: Default::default(),
        }
    }
}
impl BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto {
    pub fn builder() -> builder::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto {
        Default::default()
    }
}
///BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "data": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FarmedFishEscape.Models.FarmedFishEscapeWeekDto"
///      },
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int32",
///      "example": 12345
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2016
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub data: ::std::vec::Vec<BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto>
for BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto {
    fn from(value: &BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto {
    fn default() -> Self {
        Self {
            data: Default::default(),
            locality_no: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto {
    pub fn builder() -> builder::BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto {
        Default::default()
    }
}
///BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "exportRestrictions": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ExportRestrictions.Models.ExportRestrictionAreaLink"
///      },
///      "nullable": true
///    },
///    "ilaProtectionZones": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.ControlAreaLinkV1"
///      },
///      "nullable": true
///    },
///    "ilaSurveilanzeZones": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.ControlAreaLinkV1"
///      },
///      "nullable": true
///    },
///    "pdProtectionZones": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.ControlAreaLinkV1"
///      },
///      "nullable": true
///    },
///    "pdSurveilanzeZones": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.ControlAreaLinkV1"
///      },
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory {
    #[serde(
        rename = "exportRestrictions",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub export_restrictions: ::std::vec::Vec<
        BwApiApiExportRestrictionsModelsExportRestrictionAreaLink,
    >,
    #[serde(
        rename = "ilaProtectionZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub ila_protection_zones: ::std::vec::Vec<
        BwApiApiControlAreasModelsControlAreaLinkV1,
    >,
    #[serde(
        rename = "ilaSurveilanzeZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub ila_surveilanze_zones: ::std::vec::Vec<
        BwApiApiControlAreasModelsControlAreaLinkV1,
    >,
    #[serde(
        rename = "pdProtectionZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub pd_protection_zones: ::std::vec::Vec<
        BwApiApiControlAreasModelsControlAreaLinkV1,
    >,
    #[serde(
        rename = "pdSurveilanzeZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub pd_surveilanze_zones: ::std::vec::Vec<
        BwApiApiControlAreasModelsControlAreaLinkV1,
    >,
}
impl ::std::convert::From<&BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory>
for BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory {
    fn from(value: &BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory {
    fn default() -> Self {
        Self {
            export_restrictions: Default::default(),
            ila_protection_zones: Default::default(),
            ila_surveilanze_zones: Default::default(),
            pd_protection_zones: Default::default(),
            pd_surveilanze_zones: Default::default(),
        }
    }
}
impl BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory {
    pub fn builder() -> builder::BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory {
        Default::default()
    }
}
///BwApiApiFishhealthDownloadModelsLocalityWeekExportDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "aboveLiceLimit": {
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "avgAdultFemaleLiceRounded": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double",
///      "nullable": true
///    },
///    "avgMobileLiceRounded": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double",
///      "nullable": true
///    },
///    "avgStationaryLiceRounded": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double",
///      "nullable": true
///    },
///    "county": {
///      "type": "string",
///      "nullable": true
///    },
///    "countyNumber": {
///      "type": "string",
///      "nullable": true
///    },
///    "fallowString": {
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "hasReportedLiceString": {
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "lat": {
///      "type": "number",
///      "format": "float",
///      "nullable": true
///    },
///    "liceLimit": {
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "localityName": {
///      "type": "string",
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int64"
///    },
///    "lon": {
///      "type": "number",
///      "format": "float",
///      "nullable": true
///    },
///    "municipality": {
///      "type": "string",
///      "nullable": true
///    },
///    "municipalityNo": {
///      "type": "string",
///      "nullable": true
///    },
///    "productionAreaId": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "productionAreaName": {
///      "type": "string",
///      "nullable": true
///    },
///    "seaTemperatureRounded": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double",
///      "nullable": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthDownloadModelsLocalityWeekExportDto {
    #[serde(
        rename = "aboveLiceLimit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub above_lice_limit: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "avgAdultFemaleLiceRounded",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_adult_female_lice_rounded: ::std::option::Option<f64>,
    #[serde(
        rename = "avgMobileLiceRounded",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_mobile_lice_rounded: ::std::option::Option<f64>,
    #[serde(
        rename = "avgStationaryLiceRounded",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_stationary_lice_rounded: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub county: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "countyNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub county_number: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "fallowString",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub fallow_string: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "hasReportedLiceString",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_reported_lice_string: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lat: ::std::option::Option<f32>,
    #[serde(
        rename = "liceLimit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub lice_limit: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "localityName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lon: ::std::option::Option<f32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub municipality: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "municipalityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_no: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "productionAreaId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_area_id: ::std::option::Option<i32>,
    #[serde(
        rename = "productionAreaName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_area_name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "seaTemperatureRounded",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub sea_temperature_rounded: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthDownloadModelsLocalityWeekExportDto>
for BwApiApiFishhealthDownloadModelsLocalityWeekExportDto {
    fn from(value: &BwApiApiFishhealthDownloadModelsLocalityWeekExportDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthDownloadModelsLocalityWeekExportDto {
    fn default() -> Self {
        Self {
            above_lice_limit: Default::default(),
            avg_adult_female_lice_rounded: Default::default(),
            avg_mobile_lice_rounded: Default::default(),
            avg_stationary_lice_rounded: Default::default(),
            county: Default::default(),
            county_number: Default::default(),
            fallow_string: Default::default(),
            has_reported_lice_string: Default::default(),
            lat: Default::default(),
            lice_limit: Default::default(),
            locality_name: Default::default(),
            locality_no: Default::default(),
            lon: Default::default(),
            municipality: Default::default(),
            municipality_no: Default::default(),
            production_area_id: Default::default(),
            production_area_name: Default::default(),
            sea_temperature_rounded: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthDownloadModelsLocalityWeekExportDto {
    pub fn builder() -> builder::BwApiApiFishhealthDownloadModelsLocalityWeekExportDto {
        Default::default()
    }
}
///BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "avsluttetdato": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "county": {
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "countyNumber": {
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "disease": {
///      "type": "string",
///      "nullable": true
///    },
///    "diseaseSubType": {
///      "type": "string",
///      "nullable": true
///    },
///    "fromDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "lat": {
///      "type": "number",
///      "format": "float",
///      "nullable": true
///    },
///    "localityName": {
///      "type": "string",
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int64"
///    },
///    "lon": {
///      "type": "number",
///      "format": "float",
///      "nullable": true
///    },
///    "mistankedato": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "municipality": {
///      "type": "string",
///      "nullable": true
///    },
///    "municipalityNo": {
///      "type": "string",
///      "nullable": true
///    },
///    "paavistdato": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "productionAreaId": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "productionAreaName": {
///      "type": "string",
///      "nullable": true
///    },
///    "ruling": {
///      "type": "string",
///      "nullable": true
///    },
///    "toDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "tomtdato": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "utbruddsId": {
///      "type": "string",
///      "nullable": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub avsluttetdato: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub county: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "countyNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub county_number: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disease: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "diseaseSubType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub disease_sub_type: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "fromDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lat: ::std::option::Option<f32>,
    #[serde(
        rename = "localityName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lon: ::std::option::Option<f32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mistankedato: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub municipality: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "municipalityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_no: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub paavistdato: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "productionAreaId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_area_id: ::std::option::Option<i32>,
    #[serde(
        rename = "productionAreaName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_area_name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ruling: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "toDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub tomtdato: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "utbruddsId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub utbrudds_id: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto>
for BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto {
    fn from(value: &BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto {
    fn default() -> Self {
        Self {
            avsluttetdato: Default::default(),
            county: Default::default(),
            county_number: Default::default(),
            disease: Default::default(),
            disease_sub_type: Default::default(),
            from_date: Default::default(),
            lat: Default::default(),
            locality_name: Default::default(),
            locality_no: Default::default(),
            lon: Default::default(),
            mistankedato: Default::default(),
            municipality: Default::default(),
            municipality_no: Default::default(),
            paavistdato: Default::default(),
            production_area_id: Default::default(),
            production_area_name: Default::default(),
            ruling: Default::default(),
            to_date: Default::default(),
            tomtdato: Default::default(),
            utbrudds_id: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto {
    pub fn builder() -> builder::BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto {
        Default::default()
    }
}
///BwApiApiFishhealthDownloadModelsTreatmentsExportDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "county": {
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "countyNumber": {
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "lat": {
///      "type": "number",
///      "format": "float",
///      "nullable": true
///    },
///    "localityName": {
///      "type": "string",
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int64"
///    },
///    "lon": {
///      "type": "number",
///      "format": "float",
///      "nullable": true
///    },
///    "municipality": {
///      "type": "string",
///      "nullable": true
///    },
///    "municipalityNo": {
///      "type": "string",
///      "nullable": true
///    },
///    "numberOfCages": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "productionAreaId": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "productionAreaName": {
///      "type": "string",
///      "nullable": true
///    },
///    "quantity": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "species": {
///      "type": "string",
///      "nullable": true
///    },
///    "speciesId": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "substance": {
///      "type": "string",
///      "nullable": true
///    },
///    "treatmentScope": {
///      "type": "string",
///      "nullable": true
///    },
///    "treatmentSubType": {
///      "type": "string",
///      "nullable": true
///    },
///    "treatmentType": {
///      "type": "string",
///      "nullable": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthDownloadModelsTreatmentsExportDto {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub county: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "countyNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub county_number: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lat: ::std::option::Option<f32>,
    #[serde(
        rename = "localityName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lon: ::std::option::Option<f32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub municipality: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "municipalityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_no: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "numberOfCages",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_cages: ::std::option::Option<i32>,
    #[serde(
        rename = "productionAreaId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_area_id: ::std::option::Option<i32>,
    #[serde(
        rename = "productionAreaName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_area_name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub quantity: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub species: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "speciesId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub species_id: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub substance: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "treatmentScope",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub treatment_scope: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "treatmentSubType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub treatment_sub_type: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "treatmentType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub treatment_type: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthDownloadModelsTreatmentsExportDto>
for BwApiApiFishhealthDownloadModelsTreatmentsExportDto {
    fn from(value: &BwApiApiFishhealthDownloadModelsTreatmentsExportDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthDownloadModelsTreatmentsExportDto {
    fn default() -> Self {
        Self {
            county: Default::default(),
            county_number: Default::default(),
            lat: Default::default(),
            locality_name: Default::default(),
            locality_no: Default::default(),
            lon: Default::default(),
            municipality: Default::default(),
            municipality_no: Default::default(),
            number_of_cages: Default::default(),
            production_area_id: Default::default(),
            production_area_name: Default::default(),
            quantity: Default::default(),
            species: Default::default(),
            species_id: Default::default(),
            substance: Default::default(),
            treatment_scope: Default::default(),
            treatment_sub_type: Default::default(),
            treatment_type: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthDownloadModelsTreatmentsExportDto {
    pub fn builder() -> builder::BwApiApiFishhealthDownloadModelsTreatmentsExportDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "data": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.TreatmentGraphDataWeek"
///      },
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int32",
///      "example": 12345
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2016
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub data: ::std::vec::Vec<BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto>
for BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto {
    fn from(value: &BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto {
    fn default() -> Self {
        Self {
            data: Default::default(),
            locality_no: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "caseDetail": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.IlaPdCases.Models.IlaPdCaseDetail"
///      },
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int32",
///      "example": 12345
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2016
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail {
    #[serde(
        rename = "caseDetail",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub case_detail: ::std::vec::Vec<BwApiApiIlaPdCasesModelsIlaPdCaseDetail>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail>
for BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail {
    fn from(value: &BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail {
    fn default() -> Self {
        Self {
            case_detail: Default::default(),
            locality_no: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "data": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.DiseasePeriodDto"
///      },
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int32",
///      "example": 12345
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2016
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub data: ::std::vec::Vec<BwApiApiFishhealthLocalityModelsDiseasePeriodDto>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto>
for BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto {
    fn from(value: &BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto {
    fn default() -> Self {
        Self {
            data: Default::default(),
            locality_no: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsCleanerFishTreatment
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "entireLocality": {
///      "type": "boolean",
///      "example": false
///    },
///    "name": {
///      "type": "string",
///      "example": "Rognkjeks (hun)",
///      "nullable": true
///    },
///    "quantity": {
///      "type": "integer",
///      "format": "int32",
///      "example": 5432
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsCleanerFishTreatment {
    #[serde(
        rename = "entireLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub entire_locality: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub quantity: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsCleanerFishTreatment>
for BwApiApiFishhealthLocalityModelsCleanerFishTreatment {
    fn from(value: &BwApiApiFishhealthLocalityModelsCleanerFishTreatment) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsCleanerFishTreatment {
    fn default() -> Self {
        Self {
            entire_locality: Default::default(),
            name: Default::default(),
            quantity: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsCleanerFishTreatment {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsCleanerFishTreatment {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsDiseaseCount
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "confirmed": {
///      "type": "integer",
///      "format": "int32",
///      "example": 6
///    },
///    "suspected": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsDiseaseCount {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub confirmed: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub suspected: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsDiseaseCount>
for BwApiApiFishhealthLocalityModelsDiseaseCount {
    fn from(value: &BwApiApiFishhealthLocalityModelsDiseaseCount) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsDiseaseCount {
    fn default() -> Self {
        Self {
            confirmed: Default::default(),
            suspected: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsDiseaseCount {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsDiseaseCount {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsDiseasePeriodDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "disease": {
///      "type": "string",
///      "example": "PD",
///      "nullable": true
///    },
///    "endDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "endWeek": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "ruling": {
///      "description": "Påvist (confirmed) or Mistanke (suspected)",
///      "type": "string",
///      "example": "Mistanke",
///      "nullable": true
///    },
///    "startDate": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2015-12-02T00:00:00.000Z"
///    },
///    "startWeek": {
///      "type": "integer",
///      "format": "int32",
///      "example": 49
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsDiseasePeriodDto {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disease: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "endDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "endWeek",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_week: ::std::option::Option<i32>,
    ///Påvist (confirmed) or Mistanke (suspected)
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ruling: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "startDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub start_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "startWeek",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub start_week: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsDiseasePeriodDto>
for BwApiApiFishhealthLocalityModelsDiseasePeriodDto {
    fn from(value: &BwApiApiFishhealthLocalityModelsDiseasePeriodDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsDiseasePeriodDto {
    fn default() -> Self {
        Self {
            disease: Default::default(),
            end_date: Default::default(),
            end_week: Default::default(),
            ruling: Default::default(),
            start_date: Default::default(),
            start_week: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsDiseasePeriodDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsDiseasePeriodDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "aboveLimitLocalityCount": {
///      "type": "integer",
///      "format": "int32",
///      "example": 17
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32",
///      "example": 52
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2017
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek {
    #[serde(
        rename = "aboveLimitLocalityCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub above_limit_locality_count: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek>
for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek {
    fn from(value: &BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek {
    fn default() -> Self {
        Self {
            above_limit_locality_count: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "averageProportionOfLocalitiesOverLimit": {
///      "type": "number",
///      "format": "double",
///      "example": 0.033041
///    },
///    "weightedAverageLocalitiesOverLimit": {
///      "type": "number",
///      "format": "double",
///      "example": 19.025
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2017
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear {
    #[serde(
        rename = "averageProportionOfLocalitiesOverLimit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub average_proportion_of_localities_over_limit: ::std::option::Option<f64>,
    #[serde(
        rename = "weightedAverageLocalitiesOverLimit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub weighted_average_localities_over_limit: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear>
for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear {
    fn from(value: &BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear {
    fn default() -> Self {
        Self {
            average_proportion_of_localities_over_limit: Default::default(),
            weighted_average_localities_over_limit: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "averageProportionOfLocalitiesOverLimit": {
///      "type": "number",
///      "format": "double",
///      "example": 0.036931
///    },
///    "regionName": {
///      "type": "string",
///      "example": "Trøndelag",
///      "nullable": true
///    },
///    "weightedAverageLocalitiesOverLimit": {
///      "type": "number",
///      "format": "double",
///      "example": 3.223016
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2017
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion {
    #[serde(
        rename = "averageProportionOfLocalitiesOverLimit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub average_proportion_of_localities_over_limit: ::std::option::Option<f64>,
    #[serde(
        rename = "regionName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub region_name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "weightedAverageLocalitiesOverLimit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub weighted_average_localities_over_limit: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion,
> for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion {
    fn from(
        value: &BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion {
    fn default() -> Self {
        Self {
            average_proportion_of_localities_over_limit: Default::default(),
            region_name: Default::default(),
            weighted_average_localities_over_limit: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalityDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "avgAdultFemaleLice": {
///      "description": "Average adult female lice per fish (this is the lice development stage lice limits target)",
///      "type": "number",
///      "format": "float",
///      "example": 0.1,
///      "nullable": true
///    },
///    "hasCleanerfishDeployed": {
///      "description": "Has cleanerfish been used to combat lice this week?",
///      "type": "boolean"
///    },
///    "hasIla": {
///      "description": "Does the site have ISA disease this week",
///      "type": "boolean"
///    },
///    "hasMechanicalRemoval": {
///      "description": "Has mechanical removal methods been used to combat lice this week?",
///      "type": "boolean"
///    },
///    "hasPd": {
///      "description": "Does the site have PD disease this week",
///      "type": "boolean"
///    },
///    "hasReportedLice": {
///      "description": "True if lice count is included in the report for this week",
///      "type": "boolean"
///    },
///    "hasSalmonoids": {
///      "description": "Has production license for salmonoid species",
///      "type": "boolean"
///    },
///    "hasSubstanceTreatments": {
///      "description": "Has chemical substances, bath or in-feed, been used to combat lice this week?",
///      "type": "boolean"
///    },
///    "inFilteredSelection": {
///      "description": "True if the site matches the filtering criteria. See *tagFilteredLocalities* filter.",
///      "type": "boolean"
///    },
///    "isFallow": {
///      "description": "When a site obliged to report salmon lice, has not reported for four consecutive weeks or more,\r\nwe assume it has no fish. Then it is exempt from salmon lice reporting.",
///      "type": "boolean"
///    },
///    "isOnLand": {
///      "description": "True if site is land based, false if at sea",
///      "type": "boolean"
///    },
///    "isSlaughterHoldingCage": {
///      "description": "Locality is fish slaughter holding cage",
///      "type": "boolean"
///    },
///    "lat": {
///      "description": "Published location of the site (latitude and longitude in EPSG:4326))",
///      "type": "number",
///      "format": "double",
///      "example": 70.408
///    },
///    "localityNo": {
///      "description": "Site ID",
///      "type": "integer",
///      "format": "int64",
///      "example": 12345
///    },
///    "localityWeekId": {
///      "type": "integer",
///      "format": "int64",
///      "example": 799305
///    },
///    "lon": {
///      "description": "Published location of the site (latitude and longitude in EPSG:4326))",
///      "type": "number",
///      "format": "double",
///      "example": 26.691334
///    },
///    "municipality": {
///      "description": "Municipality name",
///      "type": "string",
///      "example": "Bømlo",
///      "nullable": true
///    },
///    "municipalityNo": {
///      "description": "Municipality number",
///      "type": "string",
///      "example": "1219",
///      "nullable": true
///    },
///    "name": {
///      "description": "Site name",
///      "type": "string",
///      "example": "Name 1",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalityDto {
    #[serde(
        rename = "avgAdultFemaleLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_adult_female_lice: ::std::option::Option<f32>,
    ///Has cleanerfish been used to combat lice this week?
    #[serde(
        rename = "hasCleanerfishDeployed",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_cleanerfish_deployed: ::std::option::Option<bool>,
    ///Does the site have ISA disease this week
    #[serde(
        rename = "hasIla",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_ila: ::std::option::Option<bool>,
    ///Has mechanical removal methods been used to combat lice this week?
    #[serde(
        rename = "hasMechanicalRemoval",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_mechanical_removal: ::std::option::Option<bool>,
    ///Does the site have PD disease this week
    #[serde(
        rename = "hasPd",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_pd: ::std::option::Option<bool>,
    ///True if lice count is included in the report for this week
    #[serde(
        rename = "hasReportedLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_reported_lice: ::std::option::Option<bool>,
    ///Has production license for salmonoid species
    #[serde(
        rename = "hasSalmonoids",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_salmonoids: ::std::option::Option<bool>,
    ///Has chemical substances, bath or in-feed, been used to combat lice this week?
    #[serde(
        rename = "hasSubstanceTreatments",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_substance_treatments: ::std::option::Option<bool>,
    ///True if the site matches the filtering criteria. See *tagFilteredLocalities* filter.
    #[serde(
        rename = "inFilteredSelection",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub in_filtered_selection: ::std::option::Option<bool>,
    /**When a site obliged to report salmon lice, has not reported for four consecutive weeks or more,
we assume it has no fish. Then it is exempt from salmon lice reporting.*/
    #[serde(
        rename = "isFallow",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_fallow: ::std::option::Option<bool>,
    ///True if site is land based, false if at sea
    #[serde(
        rename = "isOnLand",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_on_land: ::std::option::Option<bool>,
    ///Locality is fish slaughter holding cage
    #[serde(
        rename = "isSlaughterHoldingCage",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_slaughter_holding_cage: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lat: ::std::option::Option<f64>,
    ///Site ID
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i64>,
    #[serde(
        rename = "localityWeekId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_week_id: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub lon: ::std::option::Option<f64>,
    ///Municipality name
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub municipality: ::std::option::Option<::std::string::String>,
    ///Municipality number
    #[serde(
        rename = "municipalityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_no: ::std::option::Option<::std::string::String>,
    ///Site name
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsLocalityDto>
for BwApiApiFishhealthLocalityModelsLocalityDto {
    fn from(value: &BwApiApiFishhealthLocalityModelsLocalityDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityDto {
    fn default() -> Self {
        Self {
            avg_adult_female_lice: Default::default(),
            has_cleanerfish_deployed: Default::default(),
            has_ila: Default::default(),
            has_mechanical_removal: Default::default(),
            has_pd: Default::default(),
            has_reported_lice: Default::default(),
            has_salmonoids: Default::default(),
            has_substance_treatments: Default::default(),
            in_filtered_selection: Default::default(),
            is_fallow: Default::default(),
            is_on_land: Default::default(),
            is_slaughter_holding_cage: Default::default(),
            lat: Default::default(),
            locality_no: Default::default(),
            locality_week_id: Default::default(),
            lon: Default::default(),
            municipality: Default::default(),
            municipality_no: Default::default(),
            name: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalityDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalityDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalityGraphDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "value": {
///      "type": "number",
///      "format": "double",
///      "example": 0.15
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32",
///      "example": 15
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalityGraphDataDto {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub value: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsLocalityGraphDataDto>
for BwApiApiFishhealthLocalityModelsLocalityGraphDataDto {
    fn from(value: &BwApiApiFishhealthLocalityModelsLocalityGraphDataDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityGraphDataDto {
    fn default() -> Self {
        Self {
            value: Default::default(),
            week: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalityGraphDataDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalityGraphDataDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalityIlaPdLink
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "confirmed": {
///      "type": "boolean",
///      "example": true
///    },
///    "disease": {
///      "type": "string",
///      "example": "PD",
///      "nullable": true
///    },
///    "isOnLand": {
///      "type": "boolean",
///      "example": false
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int64",
///      "example": 11783
///    },
///    "name": {
///      "type": "string",
///      "example": "Hella",
///      "nullable": true
///    },
///    "suspected": {
///      "type": "boolean",
///      "example": false
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalityIlaPdLink {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub confirmed: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disease: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "isOnLand",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_on_land: ::std::option::Option<bool>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub suspected: ::std::option::Option<bool>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsLocalityIlaPdLink>
for BwApiApiFishhealthLocalityModelsLocalityIlaPdLink {
    fn from(value: &BwApiApiFishhealthLocalityModelsLocalityIlaPdLink) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityIlaPdLink {
    fn default() -> Self {
        Self {
            confirmed: Default::default(),
            disease: Default::default(),
            is_on_land: Default::default(),
            locality_no: Default::default(),
            name: Default::default(),
            suspected: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalityIlaPdLink {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalityIlaPdLink {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalityLiceCountDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "avgAdultFemaleLice": {
///      "type": "number",
///      "format": "float",
///      "example": 0.03,
///      "nullable": true
///    },
///    "avgMobileLice": {
///      "type": "number",
///      "format": "float",
///      "example": 0.04,
///      "nullable": true
///    },
///    "avgStationaryLice": {
///      "type": "number",
///      "format": "float",
///      "example": 0.01,
///      "nullable": true
///    },
///    "hasReportedLice": {
///      "type": "boolean",
///      "example": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32",
///      "example": 25
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2016
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalityLiceCountDto {
    #[serde(
        rename = "avgAdultFemaleLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_adult_female_lice: ::std::option::Option<f32>,
    #[serde(
        rename = "avgMobileLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_mobile_lice: ::std::option::Option<f32>,
    #[serde(
        rename = "avgStationaryLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_stationary_lice: ::std::option::Option<f32>,
    #[serde(
        rename = "hasReportedLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_reported_lice: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsLocalityLiceCountDto>
for BwApiApiFishhealthLocalityModelsLocalityLiceCountDto {
    fn from(value: &BwApiApiFishhealthLocalityModelsLocalityLiceCountDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityLiceCountDto {
    fn default() -> Self {
        Self {
            avg_adult_female_lice: Default::default(),
            avg_mobile_lice: Default::default(),
            avg_stationary_lice: Default::default(),
            has_reported_lice: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalityLiceCountDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalityLiceCountDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "data": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.LocalityLiceDistributionGraphDataWeekDto"
///      },
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int32",
///      "example": 12345
///    },
///    "maxCombinedNumberOfLice": {
///      "description": "Sum of lice of all types for week with highest combined count",
///      "type": "number",
///      "format": "double"
///    },
///    "type": {
///      "type": "string",
///      "example": "liceTypeDistribution",
///      "nullable": true
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2016
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub data: ::std::vec::Vec<
        BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto,
    >,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(
        rename = "maxCombinedNumberOfLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_combined_number_of_lice: ::std::option::Option<f64>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto,
> for BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto {
    fn from(
        value: &BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto {
    fn default() -> Self {
        Self {
            data: Default::default(),
            locality_no: Default::default(),
            max_combined_number_of_lice: Default::default(),
            type_: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "avgAdultFemaleLice": {
///      "description": "Average lice count for adult female lice",
///      "type": "number",
///      "format": "double",
///      "example": 0.2
///    },
///    "avgMobileLice": {
///      "description": "Average lice count for lice in mobile stages of development",
///      "type": "number",
///      "format": "double",
///      "example": 0.3
///    },
///    "avgStationaryLice": {
///      "description": "Average lice count for lice in stationary stage of development",
///      "type": "number",
///      "format": "double",
///      "example": 0.14
///    },
///    "hasReportedLice": {
///      "type": "boolean",
///      "example": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32",
///      "example": 1
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto {
    #[serde(
        rename = "avgAdultFemaleLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_adult_female_lice: ::std::option::Option<f64>,
    #[serde(
        rename = "avgMobileLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_mobile_lice: ::std::option::Option<f64>,
    #[serde(
        rename = "avgStationaryLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_stationary_lice: ::std::option::Option<f64>,
    #[serde(
        rename = "hasReportedLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_reported_lice: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto,
> for BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto {
    fn from(
        value: &BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto {
    fn default() -> Self {
        Self {
            avg_adult_female_lice: Default::default(),
            avg_mobile_lice: Default::default(),
            avg_stationary_lice: Default::default(),
            has_reported_lice: Default::default(),
            week: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "data": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.LocalityGraphDataDto"
///      },
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int32",
///      "example": 12345
///    },
///    "type": {
///      "readOnly": true,
///      "type": "string",
///      "example": "avgAdultFemaleLice",
///      "nullable": true
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2017
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub data: ::std::vec::Vec<BwApiApiFishhealthLocalityModelsLocalityGraphDataDto>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto>
for BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto {
    fn from(value: &BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto {
    fn default() -> Self {
        Self {
            data: Default::default(),
            locality_no: Default::default(),
            type_: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalityNameIdDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "localityNo": {
///      "description": "Site ID",
///      "type": "integer",
///      "format": "int32"
///    },
///    "name": {
///      "description": "Site name",
///      "type": "string",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalityNameIdDto {
    ///Site ID
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    ///Site name
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsLocalityNameIdDto>
for BwApiApiFishhealthLocalityModelsLocalityNameIdDto {
    fn from(value: &BwApiApiFishhealthLocalityModelsLocalityNameIdDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityNameIdDto {
    fn default() -> Self {
        Self {
            locality_no: Default::default(),
            name: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalityNameIdDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalityNameIdDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "aquaCultureRegistryVersion": {
///      "description": "The version of the AquaCultureRegistry this locality is from. (The same physical locality can be registered in multiple\r\nAquaCultureRegistry versions and can thus have multiple representations with varying metadata)",
///      "type": "integer",
///      "format": "int32"
///    },
///    "localityNo": {
///      "description": "Site ID",
///      "type": "integer",
///      "format": "int32"
///    },
///    "municipality": {
///      "description": "Municipality for the locality",
///      "type": "string",
///      "nullable": true
///    },
///    "municipalityNo": {
///      "description": "Municipality number for the locality",
///      "type": "string",
///      "nullable": true
///    },
///    "name": {
///      "description": "Site name",
///      "type": "string",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto {
    /**The version of the AquaCultureRegistry this locality is from. (The same physical locality can be registered in multiple
AquaCultureRegistry versions and can thus have multiple representations with varying metadata)*/
    #[serde(
        rename = "aquaCultureRegistryVersion",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub aqua_culture_registry_version: ::std::option::Option<i32>,
    ///Site ID
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    ///Municipality for the locality
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub municipality: ::std::option::Option<::std::string::String>,
    ///Municipality number for the locality
    #[serde(
        rename = "municipalityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_no: ::std::option::Option<::std::string::String>,
    ///Site name
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto>
for BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto {
    fn from(
        value: &BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto {
    fn default() -> Self {
        Self {
            aqua_culture_registry_version: Default::default(),
            locality_no: Default::default(),
            municipality: Default::default(),
            municipality_no: Default::default(),
            name: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalityReportV1
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "aquaCultureRegister": {
///      "$ref": "#/components/schemas/BW.Api.Api.AquacultureRegister.Models.Dto.AquaCultureLocalityDto"
///    },
///    "escapes": {
///      "description": "Escapes at this site, in this week. Data from Fiskeridirektoratet",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FarmedFishEscape.Models.FarmedFishEscapeDto"
///      },
///      "nullable": true
///    },
///    "exportRestrictionAreas": {
///      "description": "Export restriction zones this site belongs to, if any.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ExportRestrictions.Models.ExportRestrictionAreaLink"
///      },
///      "nullable": true
///    },
///    "ilaPd": {
///      "description": "ILA/PD cases for the site up to week 44 of 2020",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.IlaPds.Models.IlaPd"
///      },
///      "nullable": true
///    },
///    "ilaPdCase": {
///      "description": "ILA/PD cases for the site after week 44 of 2020",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.IlaPdCases.Models.IlaPdCase"
///      },
///      "nullable": true
///    },
///    "ilaProtectionZones": {
///      "description": "ISA protection zones this site is in, if any.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.IlaControlAreaDto"
///      },
///      "nullable": true
///    },
///    "ilaSurveillanceZones": {
///      "description": "ISA surveillance zones this site is in, if any.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.IlaControlAreaDto"
///      },
///      "nullable": true
///    },
///    "liceCountPreviousWeek": {
///      "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.LocalityLiceCountDto"
///    },
///    "localityIsInAquaCultureRegister": {
///      "description": "Site is in the aquaculture register for this week",
///      "type": "boolean"
///    },
///    "localityName": {
///      "description": "Site name",
///      "type": "string",
///      "example": "Flaberg",
///      "nullable": true
///    },
///    "localityWeek": {
///      "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LocalityWeek"
///    },
///    "pdProtectionZones": {
///      "description": "PD control zones this site is in, if any.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.PdControlAreaDto"
///      },
///      "nullable": true
///    },
///    "pdSurveillanceZones": {
///      "description": "PD surveillance zones this site is in, if any.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.PdControlAreaDto"
///      },
///      "nullable": true
///    },
///    "pdZoneId": {
///      "description": "ID of the (national) PD zone this site belongs to, either \"pd\" (\"PD-sonen\") or \"surveillance\"\r\n(\"PD-overvåkningssone\")",
///      "type": "string",
///      "nullable": true
///    },
///    "productionArea": {
///      "$ref": "#/components/schemas/BW.Api.Api.ProductionAreas.Models.ProductionArea"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalityReportV1 {
    #[serde(
        rename = "aquaCultureRegister",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub aqua_culture_register: ::std::option::Option<
        BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto,
    >,
    ///Escapes at this site, in this week. Data from Fiskeridirektoratet
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub escapes: ::std::vec::Vec<BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>,
    ///Export restriction zones this site belongs to, if any.
    #[serde(
        rename = "exportRestrictionAreas",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub export_restriction_areas: ::std::vec::Vec<
        BwApiApiExportRestrictionsModelsExportRestrictionAreaLink,
    >,
    ///ILA/PD cases for the site up to week 44 of 2020
    #[serde(
        rename = "ilaPd",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub ila_pd: ::std::vec::Vec<BwApiApiIlaPdsModelsIlaPd>,
    ///ILA/PD cases for the site after week 44 of 2020
    #[serde(
        rename = "ilaPdCase",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub ila_pd_case: ::std::vec::Vec<BwApiApiIlaPdCasesModelsIlaPdCase>,
    ///ISA protection zones this site is in, if any.
    #[serde(
        rename = "ilaProtectionZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub ila_protection_zones: ::std::vec::Vec<
        BwApiApiControlAreasModelsIlaControlAreaDto,
    >,
    ///ISA surveillance zones this site is in, if any.
    #[serde(
        rename = "ilaSurveillanceZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub ila_surveillance_zones: ::std::vec::Vec<
        BwApiApiControlAreasModelsIlaControlAreaDto,
    >,
    #[serde(
        rename = "liceCountPreviousWeek",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub lice_count_previous_week: ::std::option::Option<
        BwApiApiFishhealthLocalityModelsLocalityLiceCountDto,
    >,
    ///Site is in the aquaculture register for this week
    #[serde(
        rename = "localityIsInAquaCultureRegister",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_is_in_aqua_culture_register: ::std::option::Option<bool>,
    ///Site name
    #[serde(
        rename = "localityName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "localityWeek",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_week: ::std::option::Option<BwApiApiLicereportModelsLocalityWeek>,
    ///PD control zones this site is in, if any.
    #[serde(
        rename = "pdProtectionZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub pd_protection_zones: ::std::vec::Vec<BwApiApiControlAreasModelsPdControlAreaDto>,
    ///PD surveillance zones this site is in, if any.
    #[serde(
        rename = "pdSurveillanceZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub pd_surveillance_zones: ::std::vec::Vec<
        BwApiApiControlAreasModelsPdControlAreaDto,
    >,
    /**ID of the (national) PD zone this site belongs to, either "pd" ("PD-sonen") or "surveillance"
("PD-overvåkningssone")*/
    #[serde(
        rename = "pdZoneId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub pd_zone_id: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "productionArea",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_area: ::std::option::Option<
        BwApiApiProductionAreasModelsProductionArea,
    >,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsLocalityReportV1>
for BwApiApiFishhealthLocalityModelsLocalityReportV1 {
    fn from(value: &BwApiApiFishhealthLocalityModelsLocalityReportV1) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityReportV1 {
    fn default() -> Self {
        Self {
            aqua_culture_register: Default::default(),
            escapes: Default::default(),
            export_restriction_areas: Default::default(),
            ila_pd: Default::default(),
            ila_pd_case: Default::default(),
            ila_protection_zones: Default::default(),
            ila_surveillance_zones: Default::default(),
            lice_count_previous_week: Default::default(),
            locality_is_in_aqua_culture_register: Default::default(),
            locality_name: Default::default(),
            locality_week: Default::default(),
            pd_protection_zones: Default::default(),
            pd_surveillance_zones: Default::default(),
            pd_zone_id: Default::default(),
            production_area: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalityReportV1 {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalityReportV1 {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "data": {
///      "description": "Value will be null if no temperature has be reported for a week and for all future weeks in year",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.WeekSeaTemparatureDto"
///      },
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int32",
///      "example": 12345
///    },
///    "maxSeaTemperature": {
///      "type": "number",
///      "format": "float",
///      "example": 8.5,
///      "nullable": true
///    },
///    "minMaxTemperatureIsSet": {
///      "type": "boolean",
///      "example": true
///    },
///    "minSeaTemperature": {
///      "type": "number",
///      "format": "float",
///      "example": 4.9,
///      "nullable": true
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2016
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto {
    ///Value will be null if no temperature has be reported for a week and for all future weeks in year
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub data: ::std::vec::Vec<BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    #[serde(
        rename = "maxSeaTemperature",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_sea_temperature: ::std::option::Option<f32>,
    #[serde(
        rename = "minMaxTemperatureIsSet",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_max_temperature_is_set: ::std::option::Option<bool>,
    #[serde(
        rename = "minSeaTemperature",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_sea_temperature: ::std::option::Option<f32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto,
> for BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto {
    fn from(
        value: &BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto {
    fn default() -> Self {
        Self {
            data: Default::default(),
            locality_no: Default::default(),
            max_sea_temperature: Default::default(),
            min_max_temperature_is_set: Default::default(),
            min_sea_temperature: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsLocalityWeekData
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "localities": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.LocalityDto"
///      },
///      "nullable": true
///    },
///    "week": {
///      "description": "The week part of ISO week date",
///      "type": "integer",
///      "format": "int32",
///      "example": 15
///    },
///    "year": {
///      "description": "The year part of ISO week date",
///      "type": "integer",
///      "format": "int32",
///      "example": 2018
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsLocalityWeekData {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub localities: ::std::vec::Vec<BwApiApiFishhealthLocalityModelsLocalityDto>,
    ///The week part of ISO week date
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    ///The year part of ISO week date
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsLocalityWeekData>
for BwApiApiFishhealthLocalityModelsLocalityWeekData {
    fn from(value: &BwApiApiFishhealthLocalityModelsLocalityWeekData) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityWeekData {
    fn default() -> Self {
        Self {
            localities: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsLocalityWeekData {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsLocalityWeekData {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "entireLocality": {
///      "type": "boolean",
///      "example": true
///    },
///    "name": {
///      "description": "Name of active substance or \"Other\"",
///      "type": "string",
///      "example": "Emamectin benzoat",
///      "nullable": true
///    },
///    "numberOfCages": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "substanceId": {
///      "type": "integer",
///      "format": "int32",
///      "example": 5,
///      "nullable": true
///    },
///    "type": {
///      "description": "Treatment type \"InFeed\" or \"Bath\"",
///      "type": "string",
///      "example": "InFeed",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto {
    #[serde(
        rename = "entireLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub entire_locality: ::std::option::Option<bool>,
    ///Name of active substance or "Other"
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "numberOfCages",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_cages: ::std::option::Option<i32>,
    #[serde(
        rename = "substanceId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub substance_id: ::std::option::Option<i32>,
    ///Treatment type "InFeed" or "Bath"
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto>
for BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto {
    fn from(value: &BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto {
    fn default() -> Self {
        Self {
            entire_locality: Default::default(),
            name: Default::default(),
            number_of_cages: Default::default(),
            substance_id: Default::default(),
            type_: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsNationalReportV1
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "escapes": {
///      "description": "List of escapes (from all sites in this summary) this week. Data from Fiskeridirektoratet.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FarmedFishEscape.Models.FarmedFishEscapeDto"
///      },
///      "nullable": true
///    },
///    "escapesAnnual": {
///      "$ref": "#/components/schemas/BW.Api.Api.Escapes.Models.EscapesGraphDataDto"
///    },
///    "localitiesAboveLiceLimitAnnual": {
///      "$ref": "#/components/schemas/BW.Api.Api.SalmonLice.LocalitiesAboveLiceLimitGraphDataDto"
///    },
///    "localitiesAboveThreshold": {
///      "description": "Count of sites above legal threshold for avg adult female lice per fish",
///      "type": "integer",
///      "format": "int32",
///      "example": 3
///    },
///    "localitiesBelowMinimumThreshold": {
///      "type": "integer",
///      "format": "int32",
///      "example": 130
///    },
///    "localitiesBelowThreshold": {
///      "type": "integer",
///      "format": "int32",
///      "example": 198
///    },
///    "newLocalitiesWithDisease": {
///      "description": "List of new sites with disease (PD or ISA) this week. Sites are filtered.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.LocalityIlaPdLink"
///      },
///      "nullable": true
///    },
///    "newLocalitiesWithDiseaseAnnual": {
///      "$ref": "#/components/schemas/BW.Api.Api.IlaPds.Models.NewIlapdCasesGraphDataDto"
///    },
///    "numberOfFilteredLocalities": {
///      "type": "integer",
///      "format": "int32",
///      "example": 23
///    },
///    "numberOfLocalitiesWithIla": {
///      "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.DiseaseCount"
///    },
///    "numberOfLocalitiesWithPd": {
///      "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.DiseaseCount"
///    },
///    "numberOfReportingLocalities": {
///      "description": "Some aquaculture sites may have submitted a report but still be exempt from including lice count depending on a\r\nnumber of circumstances",
///      "type": "integer",
///      "format": "int32",
///      "example": 201
///    },
///    "percentageOfLocalitiesAboveThreshold": {
///      "description": "% above + % below + % not reported = 100%",
///      "type": "number",
///      "format": "double",
///      "example": 1.49
///    },
///    "percentageOfLocalitiesBelowMinimumThreshold": {
///      "type": "number",
///      "format": "double",
///      "example": 30.3
///    },
///    "percentageOfLocalitiesBelowThreshold": {
///      "type": "number",
///      "format": "double",
///      "example": 90.51
///    },
///    "totalNumberOfLocalities": {
///      "description": "Total number of sites for week, fallow and active",
///      "type": "integer",
///      "format": "int32",
///      "example": 930
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32",
///      "example": 25
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2016
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsNationalReportV1 {
    ///List of escapes (from all sites in this summary) this week. Data from Fiskeridirektoratet.
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub escapes: ::std::vec::Vec<BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>,
    #[serde(
        rename = "escapesAnnual",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub escapes_annual: ::std::option::Option<BwApiApiEscapesModelsEscapesGraphDataDto>,
    #[serde(
        rename = "localitiesAboveLiceLimitAnnual",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub localities_above_lice_limit_annual: ::std::option::Option<
        BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto,
    >,
    ///Count of sites above legal threshold for avg adult female lice per fish
    #[serde(
        rename = "localitiesAboveThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub localities_above_threshold: ::std::option::Option<i32>,
    #[serde(
        rename = "localitiesBelowMinimumThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub localities_below_minimum_threshold: ::std::option::Option<i32>,
    #[serde(
        rename = "localitiesBelowThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub localities_below_threshold: ::std::option::Option<i32>,
    ///List of new sites with disease (PD or ISA) this week. Sites are filtered.
    #[serde(
        rename = "newLocalitiesWithDisease",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub new_localities_with_disease: ::std::vec::Vec<
        BwApiApiFishhealthLocalityModelsLocalityIlaPdLink,
    >,
    #[serde(
        rename = "newLocalitiesWithDiseaseAnnual",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub new_localities_with_disease_annual: ::std::option::Option<
        BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto,
    >,
    #[serde(
        rename = "numberOfFilteredLocalities",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_filtered_localities: ::std::option::Option<i32>,
    #[serde(
        rename = "numberOfLocalitiesWithIla",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_localities_with_ila: ::std::option::Option<
        BwApiApiFishhealthLocalityModelsDiseaseCount,
    >,
    #[serde(
        rename = "numberOfLocalitiesWithPd",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_localities_with_pd: ::std::option::Option<
        BwApiApiFishhealthLocalityModelsDiseaseCount,
    >,
    /**Some aquaculture sites may have submitted a report but still be exempt from including lice count depending on a
number of circumstances*/
    #[serde(
        rename = "numberOfReportingLocalities",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_reporting_localities: ::std::option::Option<i32>,
    #[serde(
        rename = "percentageOfLocalitiesAboveThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub percentage_of_localities_above_threshold: ::std::option::Option<f64>,
    #[serde(
        rename = "percentageOfLocalitiesBelowMinimumThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub percentage_of_localities_below_minimum_threshold: ::std::option::Option<f64>,
    #[serde(
        rename = "percentageOfLocalitiesBelowThreshold",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub percentage_of_localities_below_threshold: ::std::option::Option<f64>,
    ///Total number of sites for week, fallow and active
    #[serde(
        rename = "totalNumberOfLocalities",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub total_number_of_localities: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsNationalReportV1>
for BwApiApiFishhealthLocalityModelsNationalReportV1 {
    fn from(value: &BwApiApiFishhealthLocalityModelsNationalReportV1) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsNationalReportV1 {
    fn default() -> Self {
        Self {
            escapes: Default::default(),
            escapes_annual: Default::default(),
            localities_above_lice_limit_annual: Default::default(),
            localities_above_threshold: Default::default(),
            localities_below_minimum_threshold: Default::default(),
            localities_below_threshold: Default::default(),
            new_localities_with_disease: Default::default(),
            new_localities_with_disease_annual: Default::default(),
            number_of_filtered_localities: Default::default(),
            number_of_localities_with_ila: Default::default(),
            number_of_localities_with_pd: Default::default(),
            number_of_reporting_localities: Default::default(),
            percentage_of_localities_above_threshold: Default::default(),
            percentage_of_localities_below_minimum_threshold: Default::default(),
            percentage_of_localities_below_threshold: Default::default(),
            total_number_of_localities: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsNationalReportV1 {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsNationalReportV1 {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "cleanerFishTreatments": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.CleanerFishTreatment"
///      },
///      "nullable": true
///    },
///    "combinationTreatments": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.CombinationTreatment"
///      },
///      "nullable": true
///    },
///    "mechanicalRemoval": {
///      "type": "boolean"
///    },
///    "mechanicalRemovalEntireLocality": {
///      "type": "boolean"
///    },
///    "medicinalTreatments": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.FishhealthLocality.Models.MedicinalTreatmentDto"
///      },
///      "nullable": true
///    },
///    "nonMedicinalTreatments": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.NonMedicinalTreatment"
///      },
///      "nullable": true
///    },
///    "version": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32",
///      "example": 25
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek {
    #[serde(
        rename = "cleanerFishTreatments",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub cleaner_fish_treatments: ::std::vec::Vec<
        BwApiApiFishhealthLocalityModelsCleanerFishTreatment,
    >,
    #[serde(
        rename = "combinationTreatments",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub combination_treatments: ::std::vec::Vec<
        BwApiApiLicereportModelsLiceReportCombinationTreatment,
    >,
    #[serde(
        rename = "mechanicalRemoval",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mechanical_removal: ::std::option::Option<bool>,
    #[serde(
        rename = "mechanicalRemovalEntireLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mechanical_removal_entire_locality: ::std::option::Option<bool>,
    #[serde(
        rename = "medicinalTreatments",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub medicinal_treatments: ::std::vec::Vec<
        BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto,
    >,
    #[serde(
        rename = "nonMedicinalTreatments",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub non_medicinal_treatments: ::std::vec::Vec<
        BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub version: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek>
for BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek {
    fn from(value: &BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek {
    fn default() -> Self {
        Self {
            cleaner_fish_treatments: Default::default(),
            combination_treatments: Default::default(),
            mechanical_removal: Default::default(),
            mechanical_removal_entire_locality: Default::default(),
            medicinal_treatments: Default::default(),
            non_medicinal_treatments: Default::default(),
            version: Default::default(),
            week: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek {
        Default::default()
    }
}
///BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "hasReported": {
///      "type": "boolean",
///      "example": true
///    },
///    "seaTemperature": {
///      "description": "Sea temperature in celcius",
///      "type": "number",
///      "format": "float",
///      "example": 6.5,
///      "nullable": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto {
    #[serde(
        rename = "hasReported",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_reported: ::std::option::Option<bool>,
    #[serde(
        rename = "seaTemperature",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub sea_temperature: ::std::option::Option<f32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto>
for BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto {
    fn from(value: &BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto {
    fn default() -> Self {
        Self {
            has_reported: Default::default(),
            sea_temperature: Default::default(),
            week: Default::default(),
        }
    }
}
impl BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto {
    pub fn builder() -> builder::BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto {
        Default::default()
    }
}
///BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "objectid": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "type": {
///      "type": "string",
///      "nullable": true
///    },
///    "version": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub objectid: ::std::option::Option<i32>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub version: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling,
> for BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling {
    fn from(
        value: &BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling {
    fn default() -> Self {
        Self {
            geometry: Default::default(),
            id: Default::default(),
            objectid: Default::default(),
            type_: Default::default(),
            version: Default::default(),
        }
    }
}
impl BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling {
    pub fn builder() -> builder::BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling {
        Default::default()
    }
}
///BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "objectid": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "type": {
///      "type": "string",
///      "nullable": true
///    },
///    "version": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub objectid: ::std::option::Option<i32>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub version: ::std::option::Option<i32>,
}
impl ::std::convert::From<
    &BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere,
> for BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere {
    fn from(
        value: &BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere {
    fn default() -> Self {
        Self {
            geometry: Default::default(),
            id: Default::default(),
            objectid: Default::default(),
            type_: Default::default(),
            version: Default::default(),
        }
    }
}
impl BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere {
    pub fn builder() -> builder::BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere {
        Default::default()
    }
}
///BwApiApiIlaPdCasesModelsIlaPdCase
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "changedDate": {
///      "type": "string",
///      "format": "date-time"
///    },
///    "closedDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "confirmedDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "createdDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "disease": {
///      "$ref": "#/components/schemas/BW.Api.Api.IlaPdCases.Models.IlaPdCase.DiseaseName"
///    },
///    "disproved": {
///      "type": "boolean"
///    },
///    "disprovedDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "emptiedDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "id": {
///      "type": "string",
///      "nullable": true
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int64"
///    },
///    "subtype": {
///      "$ref": "#/components/schemas/BW.Api.Api.IlaPdCases.Models.IlaPdCase.DiseaseSubType"
///    },
///    "suspectedDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiIlaPdCasesModelsIlaPdCase {
    #[serde(
        rename = "changedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub changed_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "closedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub closed_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "confirmedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub confirmed_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "createdDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub created_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disease: ::std::option::Option<BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disproved: ::std::option::Option<bool>,
    #[serde(
        rename = "disprovedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub disproved_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "emptiedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub emptied_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub subtype: ::std::option::Option<BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType>,
    #[serde(
        rename = "suspectedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub suspected_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiIlaPdCasesModelsIlaPdCase>
for BwApiApiIlaPdCasesModelsIlaPdCase {
    fn from(value: &BwApiApiIlaPdCasesModelsIlaPdCase) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiIlaPdCasesModelsIlaPdCase {
    fn default() -> Self {
        Self {
            changed_date: Default::default(),
            closed_date: Default::default(),
            confirmed_date: Default::default(),
            created_date: Default::default(),
            disease: Default::default(),
            disproved: Default::default(),
            disproved_date: Default::default(),
            emptied_date: Default::default(),
            id: Default::default(),
            locality_no: Default::default(),
            subtype: Default::default(),
            suspected_date: Default::default(),
        }
    }
}
impl BwApiApiIlaPdCasesModelsIlaPdCase {
    pub fn builder() -> builder::BwApiApiIlaPdCasesModelsIlaPdCase {
        Default::default()
    }
}
///BwApiApiIlaPdCasesModelsIlaPdCaseDetail
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "closedDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "confirmedDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "disease": {
///      "$ref": "#/components/schemas/BW.Api.Api.IlaPdCases.Models.IlaPdCase.DiseaseName"
///    },
///    "disproved": {
///      "type": "boolean"
///    },
///    "disprovedDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "emptiedDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "subtype": {
///      "$ref": "#/components/schemas/BW.Api.Api.IlaPdCases.Models.IlaPdCase.DiseaseSubType"
///    },
///    "suspectedDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiIlaPdCasesModelsIlaPdCaseDetail {
    #[serde(
        rename = "closedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub closed_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "confirmedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub confirmed_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disease: ::std::option::Option<BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disproved: ::std::option::Option<bool>,
    #[serde(
        rename = "disprovedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub disproved_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "emptiedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub emptied_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub subtype: ::std::option::Option<BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType>,
    #[serde(
        rename = "suspectedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub suspected_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiIlaPdCasesModelsIlaPdCaseDetail>
for BwApiApiIlaPdCasesModelsIlaPdCaseDetail {
    fn from(value: &BwApiApiIlaPdCasesModelsIlaPdCaseDetail) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiIlaPdCasesModelsIlaPdCaseDetail {
    fn default() -> Self {
        Self {
            closed_date: Default::default(),
            confirmed_date: Default::default(),
            disease: Default::default(),
            disproved: Default::default(),
            disproved_date: Default::default(),
            emptied_date: Default::default(),
            subtype: Default::default(),
            suspected_date: Default::default(),
        }
    }
}
impl BwApiApiIlaPdCasesModelsIlaPdCaseDetail {
    pub fn builder() -> builder::BwApiApiIlaPdCasesModelsIlaPdCaseDetail {
        Default::default()
    }
}
///BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "PD",
///    "ILA"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName {
    #[serde(rename = "PD")]
    Pd,
    #[serde(rename = "ILA")]
    Ila,
}
impl ::std::convert::From<&Self> for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName {
    fn from(value: &BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pd => write!(f, "PD"),
            Self::Ila => write!(f, "ILA"),
        }
    }
}
impl ::std::str::FromStr for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "PD" => Ok(Self::Pd),
            "ILA" => Ok(Self::Ila),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "gHPR0_ILAV",
///    "HPR_del_ILAV",
///    "SAV2",
///    "SAV3",
///    "Unknown"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType {
    #[serde(rename = "gHPR0_ILAV")]
    GHpr0Ilav,
    #[serde(rename = "HPR_del_ILAV")]
    HprDelIlav,
    #[serde(rename = "SAV2")]
    Sav2,
    #[serde(rename = "SAV3")]
    Sav3,
    Unknown,
}
impl ::std::convert::From<&Self> for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType {
    fn from(value: &BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::GHpr0Ilav => write!(f, "gHPR0_ILAV"),
            Self::HprDelIlav => write!(f, "HPR_del_ILAV"),
            Self::Sav2 => write!(f, "SAV2"),
            Self::Sav3 => write!(f, "SAV3"),
            Self::Unknown => write!(f, "Unknown"),
        }
    }
}
impl ::std::str::FromStr for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gHPR0_ILAV" => Ok(Self::GHpr0Ilav),
            "HPR_del_ILAV" => Ok(Self::HprDelIlav),
            "SAV2" => Ok(Self::Sav2),
            "SAV3" => Ok(Self::Sav3),
            "Unknown" => Ok(Self::Unknown),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///BwApiApiIlaPdsModelsIlaPd
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "disease": {
///      "description": "PD or ILA",
///      "type": "string",
///      "example": "PD",
///      "nullable": true
///    },
///    "fromDate": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2019-11-29T00:00:00"
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32",
///      "example": 111120
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int64",
///      "example": 12345
///    },
///    "ruling": {
///      "description": "Mistanke or Påvist",
///      "type": "string",
///      "example": "Mistanke",
///      "nullable": true
///    },
///    "toDate": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2019-11-29T00:00:00",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiIlaPdsModelsIlaPd {
    ///PD or ILA
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub disease: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "fromDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i64>,
    ///Mistanke or Påvist
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ruling: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "toDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiIlaPdsModelsIlaPd> for BwApiApiIlaPdsModelsIlaPd {
    fn from(value: &BwApiApiIlaPdsModelsIlaPd) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiIlaPdsModelsIlaPd {
    fn default() -> Self {
        Self {
            disease: Default::default(),
            from_date: Default::default(),
            id: Default::default(),
            locality_no: Default::default(),
            ruling: Default::default(),
            to_date: Default::default(),
        }
    }
}
impl BwApiApiIlaPdsModelsIlaPd {
    pub fn builder() -> builder::BwApiApiIlaPdsModelsIlaPd {
        Default::default()
    }
}
///BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "includedNewIlaCases": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "includedNewPdCases": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "newDiseaseCases": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.IlaPds.Models.NewIlapdCasesWeekDataDto"
///      },
///      "nullable": true
///    },
///    "totalNewIlaCases": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "totalNewPdCases": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto {
    #[serde(
        rename = "includedNewIlaCases",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub included_new_ila_cases: ::std::option::Option<i32>,
    #[serde(
        rename = "includedNewPdCases",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub included_new_pd_cases: ::std::option::Option<i32>,
    #[serde(
        rename = "newDiseaseCases",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub new_disease_cases: ::std::vec::Vec<BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto>,
    #[serde(
        rename = "totalNewIlaCases",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub total_new_ila_cases: ::std::option::Option<i32>,
    #[serde(
        rename = "totalNewPdCases",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub total_new_pd_cases: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto>
for BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto {
    fn from(value: &BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto {
    fn default() -> Self {
        Self {
            included_new_ila_cases: Default::default(),
            included_new_pd_cases: Default::default(),
            new_disease_cases: Default::default(),
            total_new_ila_cases: Default::default(),
            total_new_pd_cases: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto {
    pub fn builder() -> builder::BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto {
        Default::default()
    }
}
///BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "ila": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "pd": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ila: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub pd: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto>
for BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto {
    fn from(value: &BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto {
    fn default() -> Self {
        Self {
            ila: Default::default(),
            pd: Default::default(),
            week: Default::default(),
        }
    }
}
impl BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto {
    pub fn builder() -> builder::BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto {
        Default::default()
    }
}
///BwApiApiIlaPdsModelsPdZone
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "fromDate": {
///      "type": "string",
///      "format": "date-time"
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "description": "Geometry as MultiPolygon",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "description": "'surveillance' or 'pd'",
///      "type": "string",
///      "example": "pd",
///      "nullable": true
///    },
///    "toDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "type": {
///      "description": "Type is always 'pdzone'",
///      "type": "string",
///      "example": "pdzone",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiIlaPdsModelsPdZone {
    #[serde(
        rename = "fromDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    ///Geometry as MultiPolygon
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    ///'surveillance' or 'pd'
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "toDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    ///Type is always 'pdzone'
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiIlaPdsModelsPdZone> for BwApiApiIlaPdsModelsPdZone {
    fn from(value: &BwApiApiIlaPdsModelsPdZone) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiIlaPdsModelsPdZone {
    fn default() -> Self {
        Self {
            from_date: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            to_date: Default::default(),
            type_: Default::default(),
        }
    }
}
impl BwApiApiIlaPdsModelsPdZone {
    pub fn builder() -> builder::BwApiApiIlaPdsModelsPdZone {
        Default::default()
    }
}
///BwApiApiLicereportModelsLiceReportAmountUnit
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "GRAM",
///    "KILO",
///    "TONN",
///    "LITER"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BwApiApiLicereportModelsLiceReportAmountUnit {
    #[serde(rename = "GRAM")]
    Gram,
    #[serde(rename = "KILO")]
    Kilo,
    #[serde(rename = "TONN")]
    Tonn,
    #[serde(rename = "LITER")]
    Liter,
}
impl ::std::convert::From<&Self> for BwApiApiLicereportModelsLiceReportAmountUnit {
    fn from(value: &BwApiApiLicereportModelsLiceReportAmountUnit) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BwApiApiLicereportModelsLiceReportAmountUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Gram => write!(f, "GRAM"),
            Self::Kilo => write!(f, "KILO"),
            Self::Tonn => write!(f, "TONN"),
            Self::Liter => write!(f, "LITER"),
        }
    }
}
impl ::std::str::FromStr for BwApiApiLicereportModelsLiceReportAmountUnit {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "GRAM" => Ok(Self::Gram),
            "KILO" => Ok(Self::Kilo),
            "TONN" => Ok(Self::Tonn),
            "LITER" => Ok(Self::Liter),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BwApiApiLicereportModelsLiceReportAmountUnit {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for BwApiApiLicereportModelsLiceReportAmountUnit {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for BwApiApiLicereportModelsLiceReportAmountUnit {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///BwApiApiLicereportModelsLiceReportCleanerFish
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "cleanerFishDetail": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.CleanerFishDetail"
///      },
///      "nullable": true
///    },
///    "entireLocality": {
///      "type": "boolean"
///    },
///    "id": {
///      "type": "integer",
///      "format": "int64",
///      "example": 111116
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiLicereportModelsLiceReportCleanerFish {
    #[serde(
        rename = "cleanerFishDetail",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub cleaner_fish_detail: ::std::vec::Vec<
        BwApiApiLicereportModelsLiceReportCleanerFishDetail,
    >,
    #[serde(
        rename = "entireLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub entire_locality: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i64>,
}
impl ::std::convert::From<&BwApiApiLicereportModelsLiceReportCleanerFish>
for BwApiApiLicereportModelsLiceReportCleanerFish {
    fn from(value: &BwApiApiLicereportModelsLiceReportCleanerFish) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiLicereportModelsLiceReportCleanerFish {
    fn default() -> Self {
        Self {
            cleaner_fish_detail: Default::default(),
            entire_locality: Default::default(),
            id: Default::default(),
        }
    }
}
impl BwApiApiLicereportModelsLiceReportCleanerFish {
    pub fn builder() -> builder::BwApiApiLicereportModelsLiceReportCleanerFish {
        Default::default()
    }
}
///BwApiApiLicereportModelsLiceReportCleanerFishDetail
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "id": {
///      "type": "integer",
///      "format": "int64",
///      "example": 11117
///    },
///    "quantity": {
///      "type": "integer",
///      "format": "int32",
///      "example": 9009
///    },
///    "species": {
///      "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.Species"
///    },
///    "speciesId": {
///      "type": "integer",
///      "format": "int32",
///      "example": 222221
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiLicereportModelsLiceReportCleanerFishDetail {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub quantity: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub species: ::std::option::Option<BwApiApiLicereportModelsLiceReportSpecies>,
    #[serde(
        rename = "speciesId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub species_id: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiLicereportModelsLiceReportCleanerFishDetail>
for BwApiApiLicereportModelsLiceReportCleanerFishDetail {
    fn from(value: &BwApiApiLicereportModelsLiceReportCleanerFishDetail) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiLicereportModelsLiceReportCleanerFishDetail {
    fn default() -> Self {
        Self {
            id: Default::default(),
            quantity: Default::default(),
            species: Default::default(),
            species_id: Default::default(),
        }
    }
}
impl BwApiApiLicereportModelsLiceReportCleanerFishDetail {
    pub fn builder() -> builder::BwApiApiLicereportModelsLiceReportCleanerFishDetail {
        Default::default()
    }
}
///BwApiApiLicereportModelsLiceReportCombinationTreatment
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "id": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "liceReportId": {
///      "type": "integer",
///      "format": "int64"
///    },
///    "medicinalTreatments": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.MedicinalTreatment"
///      },
///      "nullable": true
///    },
///    "nonMedicinalTreatments": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.NonMedicinalTreatment"
///      },
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiLicereportModelsLiceReportCombinationTreatment {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(
        rename = "liceReportId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub lice_report_id: ::std::option::Option<i64>,
    #[serde(
        rename = "medicinalTreatments",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub medicinal_treatments: ::std::vec::Vec<
        BwApiApiLicereportModelsLiceReportMedicinalTreatment,
    >,
    #[serde(
        rename = "nonMedicinalTreatments",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub non_medicinal_treatments: ::std::vec::Vec<
        BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
    >,
}
impl ::std::convert::From<&BwApiApiLicereportModelsLiceReportCombinationTreatment>
for BwApiApiLicereportModelsLiceReportCombinationTreatment {
    fn from(value: &BwApiApiLicereportModelsLiceReportCombinationTreatment) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiLicereportModelsLiceReportCombinationTreatment {
    fn default() -> Self {
        Self {
            id: Default::default(),
            lice_report_id: Default::default(),
            medicinal_treatments: Default::default(),
            non_medicinal_treatments: Default::default(),
        }
    }
}
impl BwApiApiLicereportModelsLiceReportCombinationTreatment {
    pub fn builder() -> builder::BwApiApiLicereportModelsLiceReportCombinationTreatment {
        Default::default()
    }
}
///BwApiApiLicereportModelsLiceReportConcentrationUnit
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "MILLIGRAM_PER_GRAM",
///    "MILLIGRAM_PER_MILLILITER",
///    "GRAM_PER_KILO",
///    "MILLIGRAM_PER_KILO",
///    "PROSENT"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BwApiApiLicereportModelsLiceReportConcentrationUnit {
    #[serde(rename = "MILLIGRAM_PER_GRAM")]
    MilligramPerGram,
    #[serde(rename = "MILLIGRAM_PER_MILLILITER")]
    MilligramPerMilliliter,
    #[serde(rename = "GRAM_PER_KILO")]
    GramPerKilo,
    #[serde(rename = "MILLIGRAM_PER_KILO")]
    MilligramPerKilo,
    #[serde(rename = "PROSENT")]
    Prosent,
}
impl ::std::convert::From<&Self>
for BwApiApiLicereportModelsLiceReportConcentrationUnit {
    fn from(value: &BwApiApiLicereportModelsLiceReportConcentrationUnit) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BwApiApiLicereportModelsLiceReportConcentrationUnit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::MilligramPerGram => write!(f, "MILLIGRAM_PER_GRAM"),
            Self::MilligramPerMilliliter => write!(f, "MILLIGRAM_PER_MILLILITER"),
            Self::GramPerKilo => write!(f, "GRAM_PER_KILO"),
            Self::MilligramPerKilo => write!(f, "MILLIGRAM_PER_KILO"),
            Self::Prosent => write!(f, "PROSENT"),
        }
    }
}
impl ::std::str::FromStr for BwApiApiLicereportModelsLiceReportConcentrationUnit {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "MILLIGRAM_PER_GRAM" => Ok(Self::MilligramPerGram),
            "MILLIGRAM_PER_MILLILITER" => Ok(Self::MilligramPerMilliliter),
            "GRAM_PER_KILO" => Ok(Self::GramPerKilo),
            "MILLIGRAM_PER_KILO" => Ok(Self::MilligramPerKilo),
            "PROSENT" => Ok(Self::Prosent),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
for BwApiApiLicereportModelsLiceReportConcentrationUnit {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for BwApiApiLicereportModelsLiceReportConcentrationUnit {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for BwApiApiLicereportModelsLiceReportConcentrationUnit {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///BwApiApiLicereportModelsLiceReportMechanicalRemoval
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "entireLocality": {
///      "type": "boolean"
///    },
///    "id": {
///      "type": "integer",
///      "format": "int64"
///    },
///    "method": {
///      "type": "string",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiLicereportModelsLiceReportMechanicalRemoval {
    #[serde(
        rename = "entireLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub entire_locality: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub method: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiLicereportModelsLiceReportMechanicalRemoval>
for BwApiApiLicereportModelsLiceReportMechanicalRemoval {
    fn from(value: &BwApiApiLicereportModelsLiceReportMechanicalRemoval) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiLicereportModelsLiceReportMechanicalRemoval {
    fn default() -> Self {
        Self {
            entire_locality: Default::default(),
            id: Default::default(),
            method: Default::default(),
        }
    }
}
impl BwApiApiLicereportModelsLiceReportMechanicalRemoval {
    pub fn builder() -> builder::BwApiApiLicereportModelsLiceReportMechanicalRemoval {
        Default::default()
    }
}
///BwApiApiLicereportModelsLiceReportMedicinalTreatment
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "amountUnit": {
///      "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.AmountUnit"
///    },
///    "amountValue": {
///      "type": "number",
///      "format": "double",
///      "nullable": true
///    },
///    "concentrationUnit": {
///      "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.ConcentrationUnit"
///    },
///    "concentrationValue": {
///      "type": "number",
///      "format": "double",
///      "nullable": true
///    },
///    "doneBeforeLiceCount": {
///      "type": "boolean"
///    },
///    "entireLocality": {
///      "type": "boolean"
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "numberOfCages": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "otherSubstance": {
///      "type": "string",
///      "nullable": true
///    },
///    "substanceId": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "type": {
///      "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.MedicinalTreatmentType"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiLicereportModelsLiceReportMedicinalTreatment {
    #[serde(
        rename = "amountUnit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub amount_unit: ::std::option::Option<BwApiApiLicereportModelsLiceReportAmountUnit>,
    #[serde(
        rename = "amountValue",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub amount_value: ::std::option::Option<f64>,
    #[serde(
        rename = "concentrationUnit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub concentration_unit: ::std::option::Option<
        BwApiApiLicereportModelsLiceReportConcentrationUnit,
    >,
    #[serde(
        rename = "concentrationValue",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub concentration_value: ::std::option::Option<f64>,
    #[serde(
        rename = "doneBeforeLiceCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub done_before_lice_count: ::std::option::Option<bool>,
    #[serde(
        rename = "entireLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub entire_locality: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(
        rename = "numberOfCages",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_cages: ::std::option::Option<i32>,
    #[serde(
        rename = "otherSubstance",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub other_substance: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "substanceId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub substance_id: ::std::option::Option<i32>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<
        BwApiApiLicereportModelsLiceReportMedicinalTreatmentType,
    >,
}
impl ::std::convert::From<&BwApiApiLicereportModelsLiceReportMedicinalTreatment>
for BwApiApiLicereportModelsLiceReportMedicinalTreatment {
    fn from(value: &BwApiApiLicereportModelsLiceReportMedicinalTreatment) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiLicereportModelsLiceReportMedicinalTreatment {
    fn default() -> Self {
        Self {
            amount_unit: Default::default(),
            amount_value: Default::default(),
            concentration_unit: Default::default(),
            concentration_value: Default::default(),
            done_before_lice_count: Default::default(),
            entire_locality: Default::default(),
            id: Default::default(),
            number_of_cages: Default::default(),
            other_substance: Default::default(),
            substance_id: Default::default(),
            type_: Default::default(),
        }
    }
}
impl BwApiApiLicereportModelsLiceReportMedicinalTreatment {
    pub fn builder() -> builder::BwApiApiLicereportModelsLiceReportMedicinalTreatment {
        Default::default()
    }
}
///BwApiApiLicereportModelsLiceReportMedicinalTreatmentType
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "FORBEHANDLING",
///    "BADEBEHANDLING",
///    "ANNEN_BEHANDLING"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BwApiApiLicereportModelsLiceReportMedicinalTreatmentType {
    #[serde(rename = "FORBEHANDLING")]
    Forbehandling,
    #[serde(rename = "BADEBEHANDLING")]
    Badebehandling,
    #[serde(rename = "ANNEN_BEHANDLING")]
    AnnenBehandling,
}
impl ::std::convert::From<&Self>
for BwApiApiLicereportModelsLiceReportMedicinalTreatmentType {
    fn from(value: &BwApiApiLicereportModelsLiceReportMedicinalTreatmentType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BwApiApiLicereportModelsLiceReportMedicinalTreatmentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Forbehandling => write!(f, "FORBEHANDLING"),
            Self::Badebehandling => write!(f, "BADEBEHANDLING"),
            Self::AnnenBehandling => write!(f, "ANNEN_BEHANDLING"),
        }
    }
}
impl ::std::str::FromStr for BwApiApiLicereportModelsLiceReportMedicinalTreatmentType {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "FORBEHANDLING" => Ok(Self::Forbehandling),
            "BADEBEHANDLING" => Ok(Self::Badebehandling),
            "ANNEN_BEHANDLING" => Ok(Self::AnnenBehandling),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
for BwApiApiLicereportModelsLiceReportMedicinalTreatmentType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for BwApiApiLicereportModelsLiceReportMedicinalTreatmentType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for BwApiApiLicereportModelsLiceReportMedicinalTreatmentType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///BwApiApiLicereportModelsLiceReportNonMedicinalTreatment
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "doneBeforeLiceCount": {
///      "type": "boolean"
///    },
///    "entireLocality": {
///      "type": "boolean"
///    },
///    "id": {
///      "type": "integer",
///      "format": "int64"
///    },
///    "numberOfCages": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "type": {
///      "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.NonMedicinalTreatmentType"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiLicereportModelsLiceReportNonMedicinalTreatment {
    #[serde(
        rename = "doneBeforeLiceCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub done_before_lice_count: ::std::option::Option<bool>,
    #[serde(
        rename = "entireLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub entire_locality: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i64>,
    #[serde(
        rename = "numberOfCages",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_cages: ::std::option::Option<i32>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<
        BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType,
    >,
}
impl ::std::convert::From<&BwApiApiLicereportModelsLiceReportNonMedicinalTreatment>
for BwApiApiLicereportModelsLiceReportNonMedicinalTreatment {
    fn from(value: &BwApiApiLicereportModelsLiceReportNonMedicinalTreatment) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiLicereportModelsLiceReportNonMedicinalTreatment {
    fn default() -> Self {
        Self {
            done_before_lice_count: Default::default(),
            entire_locality: Default::default(),
            id: Default::default(),
            number_of_cages: Default::default(),
            type_: Default::default(),
        }
    }
}
impl BwApiApiLicereportModelsLiceReportNonMedicinalTreatment {
    pub fn builder() -> builder::BwApiApiLicereportModelsLiceReportNonMedicinalTreatment {
        Default::default()
    }
}
///BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "TERMISK_BEHANDLING",
///    "MEKANISK_BEHANDLING",
///    "FERSKVANNSBEHANDLING",
///    "ANNEN_BEHANDLING"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType {
    #[serde(rename = "TERMISK_BEHANDLING")]
    TermiskBehandling,
    #[serde(rename = "MEKANISK_BEHANDLING")]
    MekaniskBehandling,
    #[serde(rename = "FERSKVANNSBEHANDLING")]
    Ferskvannsbehandling,
    #[serde(rename = "ANNEN_BEHANDLING")]
    AnnenBehandling,
}
impl ::std::convert::From<&Self>
for BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType {
    fn from(
        value: &BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType,
    ) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display
for BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::TermiskBehandling => write!(f, "TERMISK_BEHANDLING"),
            Self::MekaniskBehandling => write!(f, "MEKANISK_BEHANDLING"),
            Self::Ferskvannsbehandling => write!(f, "FERSKVANNSBEHANDLING"),
            Self::AnnenBehandling => write!(f, "ANNEN_BEHANDLING"),
        }
    }
}
impl ::std::str::FromStr
for BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "TERMISK_BEHANDLING" => Ok(Self::TermiskBehandling),
            "MEKANISK_BEHANDLING" => Ok(Self::MekaniskBehandling),
            "FERSKVANNSBEHANDLING" => Ok(Self::Ferskvannsbehandling),
            "ANNEN_BEHANDLING" => Ok(Self::AnnenBehandling),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
for BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///BwApiApiLicereportModelsLiceReportSpecies
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "id": {
///      "type": "integer",
///      "format": "int32",
///      "example": 11118
///    },
///    "name": {
///      "type": "string",
///      "example": "Rognkjeks (hun)",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiLicereportModelsLiceReportSpecies {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiLicereportModelsLiceReportSpecies>
for BwApiApiLicereportModelsLiceReportSpecies {
    fn from(value: &BwApiApiLicereportModelsLiceReportSpecies) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiLicereportModelsLiceReportSpecies {
    fn default() -> Self {
        Self {
            id: Default::default(),
            name: Default::default(),
        }
    }
}
impl BwApiApiLicereportModelsLiceReportSpecies {
    pub fn builder() -> builder::BwApiApiLicereportModelsLiceReportSpecies {
        Default::default()
    }
}
///BwApiApiLicereportModelsLiceReportSubstance
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "id": {
///      "type": "integer",
///      "format": "int32",
///      "example": 1
///    },
///    "name": {
///      "type": "string",
///      "example": "Deltamethrin",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiLicereportModelsLiceReportSubstance {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiLicereportModelsLiceReportSubstance>
for BwApiApiLicereportModelsLiceReportSubstance {
    fn from(value: &BwApiApiLicereportModelsLiceReportSubstance) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiLicereportModelsLiceReportSubstance {
    fn default() -> Self {
        Self {
            id: Default::default(),
            name: Default::default(),
        }
    }
}
impl BwApiApiLicereportModelsLiceReportSubstance {
    pub fn builder() -> builder::BwApiApiLicereportModelsLiceReportSubstance {
        Default::default()
    }
}
///BwApiApiLicereportModelsLiceReportTreatment
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "endDate": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2016-05-30T00:00:00.000Z",
///      "nullable": true
///    },
///    "entireLocality": {
///      "type": "boolean"
///    },
///    "id": {
///      "description": "Internal id",
///      "type": "integer",
///      "format": "int64",
///      "example": 11111
///    },
///    "startDate": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2016-05-25T00:00:00.000Z",
///      "nullable": true
///    },
///    "treatmentDetail": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.TreatmentDetail"
///      },
///      "nullable": true
///    },
///    "treatmentType": {
///      "type": "string",
///      "example": "Bath",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiLicereportModelsLiceReportTreatment {
    #[serde(
        rename = "endDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "entireLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub entire_locality: ::std::option::Option<bool>,
    ///Internal id
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i64>,
    #[serde(
        rename = "startDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub start_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "treatmentDetail",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub treatment_detail: ::std::vec::Vec<
        BwApiApiLicereportModelsLiceReportTreatmentDetail,
    >,
    #[serde(
        rename = "treatmentType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub treatment_type: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiLicereportModelsLiceReportTreatment>
for BwApiApiLicereportModelsLiceReportTreatment {
    fn from(value: &BwApiApiLicereportModelsLiceReportTreatment) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiLicereportModelsLiceReportTreatment {
    fn default() -> Self {
        Self {
            end_date: Default::default(),
            entire_locality: Default::default(),
            id: Default::default(),
            start_date: Default::default(),
            treatment_detail: Default::default(),
            treatment_type: Default::default(),
        }
    }
}
impl BwApiApiLicereportModelsLiceReportTreatment {
    pub fn builder() -> builder::BwApiApiLicereportModelsLiceReportTreatment {
        Default::default()
    }
}
///BwApiApiLicereportModelsLiceReportTreatmentDetail
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "concentration": {
///      "type": "number",
///      "format": "float",
///      "example": 0.1
///    },
///    "id": {
///      "description": "Internal id",
///      "type": "integer",
///      "format": "int64",
///      "example": 1111112
///    },
///    "quantity": {
///      "type": "number",
///      "format": "float",
///      "example": 1
///    },
///    "substance": {
///      "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.Substance"
///    },
///    "substanceId": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiLicereportModelsLiceReportTreatmentDetail {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub concentration: ::std::option::Option<f32>,
    ///Internal id
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub quantity: ::std::option::Option<f32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub substance: ::std::option::Option<BwApiApiLicereportModelsLiceReportSubstance>,
    #[serde(
        rename = "substanceId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub substance_id: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiLicereportModelsLiceReportTreatmentDetail>
for BwApiApiLicereportModelsLiceReportTreatmentDetail {
    fn from(value: &BwApiApiLicereportModelsLiceReportTreatmentDetail) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiLicereportModelsLiceReportTreatmentDetail {
    fn default() -> Self {
        Self {
            concentration: Default::default(),
            id: Default::default(),
            quantity: Default::default(),
            substance: Default::default(),
            substance_id: Default::default(),
        }
    }
}
impl BwApiApiLicereportModelsLiceReportTreatmentDetail {
    pub fn builder() -> builder::BwApiApiLicereportModelsLiceReportTreatmentDetail {
        Default::default()
    }
}
///BwApiApiLicereportModelsLocalityWeek
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "avgAdultFemaleLice": {
///      "type": "number",
///      "format": "float",
///      "example": 0.33,
///      "nullable": true
///    },
///    "avgMobileLice": {
///      "type": "number",
///      "format": "float",
///      "example": 1.11,
///      "nullable": true
///    },
///    "avgStationaryLice": {
///      "type": "number",
///      "format": "float",
///      "example": 0.21,
///      "nullable": true
///    },
///    "bathTreatments": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.Treatment"
///      },
///      "nullable": true
///    },
///    "cleanerFish": {
///      "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.CleanerFish"
///    },
///    "combinationTreatments": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.CombinationTreatment"
///      },
///      "nullable": true
///    },
///    "hasBathTreatment": {
///      "description": "A value of true indicates the \"bathTreatments\"-array has data, otherwise that array will be empty",
///      "type": "boolean"
///    },
///    "hasCleanerFishDeployed": {
///      "description": "A value of true indicates the \"cleanerFish\"-array has data, otherwise that array will be null",
///      "type": "boolean"
///    },
///    "hasInFeedTreatment": {
///      "description": "A value of true indicates the \"inFeedTreatments\"-array has data, otherwise that array will be empty",
///      "type": "boolean"
///    },
///    "hasMechanicalRemoval": {
///      "type": "boolean"
///    },
///    "hasReportedLice": {
///      "type": "boolean",
///      "example": true
///    },
///    "hasSalmonoids": {
///      "description": "Has license for salmonoid species",
///      "type": "boolean"
///    },
///    "id": {
///      "type": "integer",
///      "format": "int64",
///      "example": 123456
///    },
///    "inFeedTreatments": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.Treatment"
///      },
///      "nullable": true
///    },
///    "isFallow": {
///      "description": "When a site obliged to report salmon lice, has not reported for four consecutive weeks or more,\r\nwe assume it has no fish. Then it is exempt from salmon lice reporting.",
///      "type": "boolean"
///    },
///    "isSlaughterHoldingCage": {
///      "description": "Locality is fish slaughter holding cage",
///      "type": "boolean"
///    },
///    "localityNo": {
///      "type": "integer",
///      "format": "int64",
///      "example": 12345
///    },
///    "mechanicalRemoval": {
///      "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.MechanicalRemoval"
///    },
///    "medicinalTreatments": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.MedicinalTreatment"
///      },
///      "nullable": true
///    },
///    "nonMedicinalTreatments": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Licereport.Models.LiceReport.NonMedicinalTreatment"
///      },
///      "nullable": true
///    },
///    "seaTemperature": {
///      "type": "number",
///      "format": "float",
///      "example": 8.5,
///      "nullable": true
///    },
///    "timeSinceLastChitinSynthesisInhibitorTreatment": {
///      "type": "string",
///      "format": "date-span",
///      "nullable": true
///    },
///    "version": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32",
///      "example": 25
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2016
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiLicereportModelsLocalityWeek {
    #[serde(
        rename = "avgAdultFemaleLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_adult_female_lice: ::std::option::Option<f32>,
    #[serde(
        rename = "avgMobileLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_mobile_lice: ::std::option::Option<f32>,
    #[serde(
        rename = "avgStationaryLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avg_stationary_lice: ::std::option::Option<f32>,
    #[serde(
        rename = "bathTreatments",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub bath_treatments: ::std::vec::Vec<BwApiApiLicereportModelsLiceReportTreatment>,
    #[serde(
        rename = "cleanerFish",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub cleaner_fish: ::std::option::Option<
        BwApiApiLicereportModelsLiceReportCleanerFish,
    >,
    #[serde(
        rename = "combinationTreatments",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub combination_treatments: ::std::vec::Vec<
        BwApiApiLicereportModelsLiceReportCombinationTreatment,
    >,
    ///A value of true indicates the "bathTreatments"-array has data, otherwise that array will be empty
    #[serde(
        rename = "hasBathTreatment",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_bath_treatment: ::std::option::Option<bool>,
    ///A value of true indicates the "cleanerFish"-array has data, otherwise that array will be null
    #[serde(
        rename = "hasCleanerFishDeployed",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_cleaner_fish_deployed: ::std::option::Option<bool>,
    ///A value of true indicates the "inFeedTreatments"-array has data, otherwise that array will be empty
    #[serde(
        rename = "hasInFeedTreatment",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_in_feed_treatment: ::std::option::Option<bool>,
    #[serde(
        rename = "hasMechanicalRemoval",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_mechanical_removal: ::std::option::Option<bool>,
    #[serde(
        rename = "hasReportedLice",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_reported_lice: ::std::option::Option<bool>,
    ///Has license for salmonoid species
    #[serde(
        rename = "hasSalmonoids",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_salmonoids: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i64>,
    #[serde(
        rename = "inFeedTreatments",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub in_feed_treatments: ::std::vec::Vec<BwApiApiLicereportModelsLiceReportTreatment>,
    /**When a site obliged to report salmon lice, has not reported for four consecutive weeks or more,
we assume it has no fish. Then it is exempt from salmon lice reporting.*/
    #[serde(
        rename = "isFallow",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_fallow: ::std::option::Option<bool>,
    ///Locality is fish slaughter holding cage
    #[serde(
        rename = "isSlaughterHoldingCage",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_slaughter_holding_cage: ::std::option::Option<bool>,
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i64>,
    #[serde(
        rename = "mechanicalRemoval",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mechanical_removal: ::std::option::Option<
        BwApiApiLicereportModelsLiceReportMechanicalRemoval,
    >,
    #[serde(
        rename = "medicinalTreatments",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub medicinal_treatments: ::std::vec::Vec<
        BwApiApiLicereportModelsLiceReportMedicinalTreatment,
    >,
    #[serde(
        rename = "nonMedicinalTreatments",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub non_medicinal_treatments: ::std::vec::Vec<
        BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
    >,
    #[serde(
        rename = "seaTemperature",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub sea_temperature: ::std::option::Option<f32>,
    #[serde(
        rename = "timeSinceLastChitinSynthesisInhibitorTreatment",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub time_since_last_chitin_synthesis_inhibitor_treatment: ::std::option::Option<
        ::std::string::String,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub version: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiLicereportModelsLocalityWeek>
for BwApiApiLicereportModelsLocalityWeek {
    fn from(value: &BwApiApiLicereportModelsLocalityWeek) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiLicereportModelsLocalityWeek {
    fn default() -> Self {
        Self {
            avg_adult_female_lice: Default::default(),
            avg_mobile_lice: Default::default(),
            avg_stationary_lice: Default::default(),
            bath_treatments: Default::default(),
            cleaner_fish: Default::default(),
            combination_treatments: Default::default(),
            has_bath_treatment: Default::default(),
            has_cleaner_fish_deployed: Default::default(),
            has_in_feed_treatment: Default::default(),
            has_mechanical_removal: Default::default(),
            has_reported_lice: Default::default(),
            has_salmonoids: Default::default(),
            id: Default::default(),
            in_feed_treatments: Default::default(),
            is_fallow: Default::default(),
            is_slaughter_holding_cage: Default::default(),
            locality_no: Default::default(),
            mechanical_removal: Default::default(),
            medicinal_treatments: Default::default(),
            non_medicinal_treatments: Default::default(),
            sea_temperature: Default::default(),
            time_since_last_chitin_synthesis_inhibitor_treatment: Default::default(),
            version: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiLicereportModelsLocalityWeek {
    pub fn builder() -> builder::BwApiApiLicereportModelsLocalityWeek {
        Default::default()
    }
}
///BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "name": {
///      "type": "string",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto>
for BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto {
    fn from(value: &BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto {
    fn default() -> Self {
        Self {
            geometry: Default::default(),
            name: Default::default(),
        }
    }
}
impl BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto {
    pub fn builder() -> builder::BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto {
        Default::default()
    }
}
///BwApiApiPayoutModelsPayoutModel
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "municipalityName": {
///      "type": "string",
///      "nullable": true
///    },
///    "municipalityNumber": {
///      "type": "string",
///      "nullable": true
///    },
///    "totalPayout": {
///      "type": "number",
///      "format": "double"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiPayoutModelsPayoutModel {
    #[serde(
        rename = "municipalityName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "municipalityNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_number: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "totalPayout",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub total_payout: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiPayoutModelsPayoutModel>
for BwApiApiPayoutModelsPayoutModel {
    fn from(value: &BwApiApiPayoutModelsPayoutModel) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiPayoutModelsPayoutModel {
    fn default() -> Self {
        Self {
            municipality_name: Default::default(),
            municipality_number: Default::default(),
            total_payout: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiPayoutModelsPayoutModel {
    pub fn builder() -> builder::BwApiApiPayoutModelsPayoutModel {
        Default::default()
    }
}
///BwApiApiProductionAreasModelsColor
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "green",
///    "yellow",
///    "red"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BwApiApiProductionAreasModelsColor {
    #[serde(rename = "green")]
    Green,
    #[serde(rename = "yellow")]
    Yellow,
    #[serde(rename = "red")]
    Red,
}
impl ::std::convert::From<&Self> for BwApiApiProductionAreasModelsColor {
    fn from(value: &BwApiApiProductionAreasModelsColor) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BwApiApiProductionAreasModelsColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Green => write!(f, "green"),
            Self::Yellow => write!(f, "yellow"),
            Self::Red => write!(f, "red"),
        }
    }
}
impl ::std::str::FromStr for BwApiApiProductionAreasModelsColor {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "green" => Ok(Self::Green),
            "yellow" => Ok(Self::Yellow),
            "red" => Ok(Self::Red),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BwApiApiProductionAreasModelsColor {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for BwApiApiProductionAreasModelsColor {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for BwApiApiProductionAreasModelsColor {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///BwApiApiProductionAreasModelsProductionArea
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "colors": {
///      "description": "Color according to produksjonsområdeforskriften, and validity dates",
///      "readOnly": true,
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ProductionAreas.Models.ProductionAreaColor"
///      },
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32",
///      "example": 3
///    },
///    "name": {
///      "type": "string",
///      "example": "Karmøy til Sotra",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiProductionAreasModelsProductionArea {
    ///Color according to produksjonsområdeforskriften, and validity dates
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub colors: ::std::vec::Vec<BwApiApiProductionAreasModelsProductionAreaColor>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiProductionAreasModelsProductionArea>
for BwApiApiProductionAreasModelsProductionArea {
    fn from(value: &BwApiApiProductionAreasModelsProductionArea) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiProductionAreasModelsProductionArea {
    fn default() -> Self {
        Self {
            colors: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            name: Default::default(),
        }
    }
}
impl BwApiApiProductionAreasModelsProductionArea {
    pub fn builder() -> builder::BwApiApiProductionAreasModelsProductionArea {
        Default::default()
    }
}
///BwApiApiProductionAreasModelsProductionAreaAquaCultureData
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "numberOfBroodstockSites": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "numberOfLandSites": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "numberOfSalmonoidSites": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "numberOfSites": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiProductionAreasModelsProductionAreaAquaCultureData {
    #[serde(
        rename = "numberOfBroodstockSites",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_broodstock_sites: ::std::option::Option<i32>,
    #[serde(
        rename = "numberOfLandSites",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_land_sites: ::std::option::Option<i32>,
    #[serde(
        rename = "numberOfSalmonoidSites",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_salmonoid_sites: ::std::option::Option<i32>,
    #[serde(
        rename = "numberOfSites",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub number_of_sites: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiProductionAreasModelsProductionAreaAquaCultureData>
for BwApiApiProductionAreasModelsProductionAreaAquaCultureData {
    fn from(value: &BwApiApiProductionAreasModelsProductionAreaAquaCultureData) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiProductionAreasModelsProductionAreaAquaCultureData {
    fn default() -> Self {
        Self {
            number_of_broodstock_sites: Default::default(),
            number_of_land_sites: Default::default(),
            number_of_salmonoid_sites: Default::default(),
            number_of_sites: Default::default(),
        }
    }
}
impl BwApiApiProductionAreasModelsProductionAreaAquaCultureData {
    pub fn builder() -> builder::BwApiApiProductionAreasModelsProductionAreaAquaCultureData {
        Default::default()
    }
}
///BwApiApiProductionAreasModelsProductionAreaColor
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "color": {
///      "$ref": "#/components/schemas/BW.Api.Api.ProductionAreas.Models.Color"
///    },
///    "fromDate": {
///      "type": "string",
///      "format": "date-time"
///    },
///    "toDate": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiProductionAreasModelsProductionAreaColor {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub color: ::std::option::Option<BwApiApiProductionAreasModelsColor>,
    #[serde(
        rename = "fromDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "toDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiProductionAreasModelsProductionAreaColor>
for BwApiApiProductionAreasModelsProductionAreaColor {
    fn from(value: &BwApiApiProductionAreasModelsProductionAreaColor) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiProductionAreasModelsProductionAreaColor {
    fn default() -> Self {
        Self {
            color: Default::default(),
            from_date: Default::default(),
            to_date: Default::default(),
        }
    }
}
impl BwApiApiProductionAreasModelsProductionAreaColor {
    pub fn builder() -> builder::BwApiApiProductionAreasModelsProductionAreaColor {
        Default::default()
    }
}
///BwApiApiProductionAreasModelsProductionAreaWeek
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "area": {
///      "description": "Approximate area in square meters",
///      "type": "number",
///      "format": "double"
///    },
///    "currentColor": {
///      "$ref": "#/components/schemas/BW.Api.Api.ProductionAreas.Models.ProductionAreaColor"
///    },
///    "productionArea": {
///      "$ref": "#/components/schemas/BW.Api.Api.ProductionAreas.Models.ProductionArea"
///    },
///    "productionAreaAquaCultureData": {
///      "$ref": "#/components/schemas/BW.Api.Api.ProductionAreas.Models.ProductionAreaAquaCultureData"
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiProductionAreasModelsProductionAreaWeek {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub area: ::std::option::Option<f64>,
    #[serde(
        rename = "currentColor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub current_color: ::std::option::Option<
        BwApiApiProductionAreasModelsProductionAreaColor,
    >,
    #[serde(
        rename = "productionArea",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_area: ::std::option::Option<
        BwApiApiProductionAreasModelsProductionArea,
    >,
    #[serde(
        rename = "productionAreaAquaCultureData",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_area_aqua_culture_data: ::std::option::Option<
        BwApiApiProductionAreasModelsProductionAreaAquaCultureData,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiProductionAreasModelsProductionAreaWeek>
for BwApiApiProductionAreasModelsProductionAreaWeek {
    fn from(value: &BwApiApiProductionAreasModelsProductionAreaWeek) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiProductionAreasModelsProductionAreaWeek {
    fn default() -> Self {
        Self {
            area: Default::default(),
            current_color: Default::default(),
            production_area: Default::default(),
            production_area_aqua_culture_data: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiProductionAreasModelsProductionAreaWeek {
    pub fn builder() -> builder::BwApiApiProductionAreasModelsProductionAreaWeek {
        Default::default()
    }
}
///BwApiApiProtectedAreasModelsProtectedArea
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "cddaId": {
///      "type": "string",
///      "nullable": true
///    },
///    "faktaark": {
///      "type": "string",
///      "nullable": true
///    },
///    "foerstegangVernet": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "forvaltningsmyndighet": {
///      "type": "string",
///      "nullable": true
///    },
///    "forvaltningsmyndighetType": {
///      "type": "string",
///      "nullable": true
///    },
///    "geom": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "iucn": {
///      "type": "string",
///      "nullable": true
///    },
///    "kommune": {
///      "type": "string",
///      "nullable": true
///    },
///    "majorEcosystemType": {
///      "type": "string",
///      "nullable": true
///    },
///    "naturvernId": {
///      "type": "string",
///      "nullable": true
///    },
///    "navn": {
///      "type": "string",
///      "nullable": true
///    },
///    "objectId": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "offisieltNavn": {
///      "type": "string",
///      "nullable": true
///    },
///    "revisjon": {
///      "type": "string",
///      "nullable": true
///    },
///    "shape_STArea": {
///      "type": "number",
///      "format": "double"
///    },
///    "shape_STLength": {
///      "type": "number",
///      "format": "double"
///    },
///    "truetVurdering": {
///      "type": "string",
///      "nullable": true
///    },
///    "vernedato": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "verneform": {
///      "type": "string",
///      "nullable": true
///    },
///    "verneforskrift": {
///      "type": "string",
///      "nullable": true
///    },
///    "verneplan": {
///      "type": "string",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiProtectedAreasModelsProtectedArea {
    #[serde(
        rename = "cddaId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub cdda_id: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub faktaark: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "foerstegangVernet",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub foerstegang_vernet: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub forvaltningsmyndighet: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "forvaltningsmyndighetType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub forvaltningsmyndighet_type: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geom: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub iucn: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub kommune: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "majorEcosystemType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub major_ecosystem_type: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "naturvernId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub naturvern_id: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub navn: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "objectId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub object_id: ::std::option::Option<i32>,
    #[serde(
        rename = "offisieltNavn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub offisielt_navn: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub revisjon: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "shape_STArea",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub shape_st_area: ::std::option::Option<f64>,
    #[serde(
        rename = "shape_STLength",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub shape_st_length: ::std::option::Option<f64>,
    #[serde(
        rename = "truetVurdering",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub truet_vurdering: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub vernedato: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub verneform: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub verneforskrift: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub verneplan: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiProtectedAreasModelsProtectedArea>
for BwApiApiProtectedAreasModelsProtectedArea {
    fn from(value: &BwApiApiProtectedAreasModelsProtectedArea) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiProtectedAreasModelsProtectedArea {
    fn default() -> Self {
        Self {
            cdda_id: Default::default(),
            faktaark: Default::default(),
            foerstegang_vernet: Default::default(),
            forvaltningsmyndighet: Default::default(),
            forvaltningsmyndighet_type: Default::default(),
            geom: Default::default(),
            id: Default::default(),
            iucn: Default::default(),
            kommune: Default::default(),
            major_ecosystem_type: Default::default(),
            naturvern_id: Default::default(),
            navn: Default::default(),
            object_id: Default::default(),
            offisielt_navn: Default::default(),
            revisjon: Default::default(),
            shape_st_area: Default::default(),
            shape_st_length: Default::default(),
            truet_vurdering: Default::default(),
            vernedato: Default::default(),
            verneform: Default::default(),
            verneforskrift: Default::default(),
            verneplan: Default::default(),
        }
    }
}
impl BwApiApiProtectedAreasModelsProtectedArea {
    pub fn builder() -> builder::BwApiApiProtectedAreasModelsProtectedArea {
        Default::default()
    }
}
///BwApiApiRiverCatchModelsRiverCatchModel
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "catch": {
///      "type": "string",
///      "nullable": true
///    },
///    "number": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "river": {
///      "type": "string",
///      "nullable": true
///    },
///    "species": {
///      "type": "string",
///      "nullable": true
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiRiverCatchModelsRiverCatchModel {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub catch: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub number: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub river: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub species: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiRiverCatchModelsRiverCatchModel>
for BwApiApiRiverCatchModelsRiverCatchModel {
    fn from(value: &BwApiApiRiverCatchModelsRiverCatchModel) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiRiverCatchModelsRiverCatchModel {
    fn default() -> Self {
        Self {
            catch: Default::default(),
            number: Default::default(),
            river: Default::default(),
            species: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiRiverCatchModelsRiverCatchModel {
    pub fn builder() -> builder::BwApiApiRiverCatchModelsRiverCatchModel {
        Default::default()
    }
}
///BwApiApiSalmonFjordModelsSalmonFjordDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "borderPoint": {
///      "type": "string",
///      "example": "Leinesodden - Sandnessjøen, Hamnes - Bjørga",
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "description": "Serial ID, will change when dataset is updated",
///      "type": "integer",
///      "format": "int32",
///      "example": 654
///    },
///    "placeName": {
///      "type": "string",
///      "example": "Vefsnfjorden",
///      "nullable": true
///    },
///    "region": {
///      "type": "string",
///      "example": "Region Nordland",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiSalmonFjordModelsSalmonFjordDto {
    #[serde(
        rename = "borderPoint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub border_point: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    ///Serial ID, will change when dataset is updated
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(
        rename = "placeName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub place_name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub region: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiSalmonFjordModelsSalmonFjordDto>
for BwApiApiSalmonFjordModelsSalmonFjordDto {
    fn from(value: &BwApiApiSalmonFjordModelsSalmonFjordDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiSalmonFjordModelsSalmonFjordDto {
    fn default() -> Self {
        Self {
            border_point: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            place_name: Default::default(),
            region: Default::default(),
        }
    }
}
impl BwApiApiSalmonFjordModelsSalmonFjordDto {
    pub fn builder() -> builder::BwApiApiSalmonFjordModelsSalmonFjordDto {
        Default::default()
    }
}
///BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "count": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount>
for BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount {
    fn from(value: &BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount {
    fn default() -> Self {
        Self {
            count: Default::default(),
            week: Default::default(),
        }
    }
}
impl BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount {
    pub fn builder() -> builder::BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount {
        Default::default()
    }
}
///BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "includedLocalitiesAboveLiceLimitCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "localitiesAboveLiceLimitCount": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.SalmonLice.LocalitiesAboveLiceLimitCount"
///      },
///      "nullable": true
///    },
///    "totalLocalitiesAboveLiceLimitCount": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto {
    #[serde(
        rename = "includedLocalitiesAboveLiceLimitCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub included_localities_above_lice_limit_count: ::std::option::Option<i32>,
    #[serde(
        rename = "localitiesAboveLiceLimitCount",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub localities_above_lice_limit_count: ::std::vec::Vec<
        BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount,
    >,
    #[serde(
        rename = "totalLocalitiesAboveLiceLimitCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub total_localities_above_lice_limit_count: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto>
for BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto {
    fn from(value: &BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto {
    fn default() -> Self {
        Self {
            included_localities_above_lice_limit_count: Default::default(),
            localities_above_lice_limit_count: Default::default(),
            total_localities_above_lice_limit_count: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto {
    pub fn builder() -> builder::BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto {
        Default::default()
    }
}
///BwApiApiSalmonRiversModelsSalmonRiver
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "alternativeName": {
///      "description": "Alternative name. This may be null.",
///      "type": "string",
///      "example": "Tengselven",
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "description": "Geoemtry of river area",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "isNationalSalmonRiver": {
///      "description": "If the river is designated a national salmon river",
///      "type": "boolean",
///      "example": true
///    },
///    "municipalityId": {
///      "description": "Id of municipality",
///      "type": "string",
///      "nullable": true
///    },
///    "municipalityName": {
///      "description": "Name of Municipality",
///      "type": "string",
///      "nullable": true
///    },
///    "name": {
///      "description": "Primary name",
///      "type": "string",
///      "example": "Bjerkreimselva",
///      "nullable": true
///    },
///    "productionAreaId": {
///      "description": "Id of production area",
///      "type": "integer",
///      "format": "int32"
///    },
///    "productionAreaName": {
///      "description": "Name of production area",
///      "type": "string",
///      "nullable": true
///    },
///    "riverCatch": {
///      "description": "RiverCatch data from SSB",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.RiverCatch.Models.RiverCatchModel"
///      },
///      "nullable": true
///    },
///    "riverId": {
///      "description": "River ID (vassdragsnummer)",
///      "type": "string",
///      "example": "027.Z",
///      "nullable": true
///    },
///    "riverMouthLocation": {
///      "title": "GeoJson Geometry",
///      "description": "River mouth location (point geometry)",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiSalmonRiversModelsSalmonRiver {
    ///Alternative name. This may be null.
    #[serde(
        rename = "alternativeName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub alternative_name: ::std::option::Option<::std::string::String>,
    ///Geoemtry of river area
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    ///If the river is designated a national salmon river
    #[serde(
        rename = "isNationalSalmonRiver",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_national_salmon_river: ::std::option::Option<bool>,
    ///Id of municipality
    #[serde(
        rename = "municipalityId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_id: ::std::option::Option<::std::string::String>,
    ///Name of Municipality
    #[serde(
        rename = "municipalityName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub municipality_name: ::std::option::Option<::std::string::String>,
    ///Primary name
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    ///Id of production area
    #[serde(
        rename = "productionAreaId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_area_id: ::std::option::Option<i32>,
    ///Name of production area
    #[serde(
        rename = "productionAreaName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_area_name: ::std::option::Option<::std::string::String>,
    ///RiverCatch data from SSB
    #[serde(
        rename = "riverCatch",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub river_catch: ::std::vec::Vec<BwApiApiRiverCatchModelsRiverCatchModel>,
    ///River ID (vassdragsnummer)
    #[serde(
        rename = "riverId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub river_id: ::std::option::Option<::std::string::String>,
    ///River mouth location (point geometry)
    #[serde(
        rename = "riverMouthLocation",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub river_mouth_location: ::std::option::Option<GeoJsonGeometry>,
}
impl ::std::convert::From<&BwApiApiSalmonRiversModelsSalmonRiver>
for BwApiApiSalmonRiversModelsSalmonRiver {
    fn from(value: &BwApiApiSalmonRiversModelsSalmonRiver) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiSalmonRiversModelsSalmonRiver {
    fn default() -> Self {
        Self {
            alternative_name: Default::default(),
            geometry: Default::default(),
            is_national_salmon_river: Default::default(),
            municipality_id: Default::default(),
            municipality_name: Default::default(),
            name: Default::default(),
            production_area_id: Default::default(),
            production_area_name: Default::default(),
            river_catch: Default::default(),
            river_id: Default::default(),
            river_mouth_location: Default::default(),
        }
    }
}
impl BwApiApiSalmonRiversModelsSalmonRiver {
    pub fn builder() -> builder::BwApiApiSalmonRiversModelsSalmonRiver {
        Default::default()
    }
}
///BwApiApiShellSandAreaModelsShellSandAreaModel
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "areaName": {
///      "type": "string",
///      "nullable": true
///    },
///    "areaSize": {
///      "type": "number",
///      "format": "double"
///    },
///    "geometry": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Polygon"
///    },
///    "infoUrl": {
///      "type": "string",
///      "nullable": true
///    },
///    "objectId": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "registeredDate": {
///      "type": "string",
///      "format": "date-time"
///    },
///    "value": {
///      "type": "string",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiShellSandAreaModelsShellSandAreaModel {
    #[serde(
        rename = "areaName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub area_name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "areaSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub area_size: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<NetTopologySuiteGeometriesPolygon>,
    #[serde(
        rename = "infoUrl",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub info_url: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "objectId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub object_id: ::std::option::Option<i32>,
    #[serde(
        rename = "registeredDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub registered_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub value: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiShellSandAreaModelsShellSandAreaModel>
for BwApiApiShellSandAreaModelsShellSandAreaModel {
    fn from(value: &BwApiApiShellSandAreaModelsShellSandAreaModel) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiShellSandAreaModelsShellSandAreaModel {
    fn default() -> Self {
        Self {
            area_name: Default::default(),
            area_size: Default::default(),
            geometry: Default::default(),
            info_url: Default::default(),
            object_id: Default::default(),
            registered_date: Default::default(),
            value: Default::default(),
        }
    }
}
impl BwApiApiShellSandAreaModelsShellSandAreaModel {
    pub fn builder() -> builder::BwApiApiShellSandAreaModelsShellSandAreaModel {
        Default::default()
    }
}
///BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "date": {
///      "type": "string",
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "placename": {
///      "type": "string",
///      "nullable": true
///    },
///    "updatedDate": {
///      "type": "string",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub date: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub placename: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "updatedDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub updated_date: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto>
for BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto {
    fn from(
        value: &BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto,
    ) -> Self {
        value.clone()
    }
}
impl ::std::default::Default
for BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto {
    fn default() -> Self {
        Self {
            date: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            placename: Default::default(),
            updated_date: Default::default(),
        }
    }
}
impl BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto {
    pub fn builder() -> builder::BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto {
        Default::default()
    }
}
///BwApiApiSlaughterhouseModelsSlaughterhouseDetails
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "ilaProtectionZones": {
///      "description": "ISA protection zones this slaughterhouse is in, if any.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.IlaControlAreaDto"
///      },
///      "nullable": true
///    },
///    "ilaSurveillanceZones": {
///      "description": "ISA surveillance zones this slaughterhouse is in, if any.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.IlaControlAreaDto"
///      },
///      "nullable": true
///    },
///    "licenses": {
///      "description": "Fish slaughterhouse licenses valid this week",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Slaughterhouse.Models.SlaughterhouseLicense"
///      },
///      "nullable": true
///    },
///    "pdProtectionZones": {
///      "description": "PD protection zones this slaughterhouse is in, if any.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.PdControlAreaDto"
///      },
///      "nullable": true
///    },
///    "pdSurveillanceZones": {
///      "description": "PD surveillance zones this slaughterhouse is in, if any.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.ControlAreas.Models.PdControlAreaDto"
///      },
///      "nullable": true
///    },
///    "pdZoneId": {
///      "description": "ID of the national PD zone the slaughterhouse belongs to",
///      "type": "string",
///      "example": "surveillance",
///      "nullable": true
///    },
///    "slaughterhouseLocality": {
///      "$ref": "#/components/schemas/BW.Api.Api.Slaughterhouse.Models.SlaughterhouseLocality"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiSlaughterhouseModelsSlaughterhouseDetails {
    ///ISA protection zones this slaughterhouse is in, if any.
    #[serde(
        rename = "ilaProtectionZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub ila_protection_zones: ::std::vec::Vec<
        BwApiApiControlAreasModelsIlaControlAreaDto,
    >,
    ///ISA surveillance zones this slaughterhouse is in, if any.
    #[serde(
        rename = "ilaSurveillanceZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub ila_surveillance_zones: ::std::vec::Vec<
        BwApiApiControlAreasModelsIlaControlAreaDto,
    >,
    ///Fish slaughterhouse licenses valid this week
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub licenses: ::std::vec::Vec<BwApiApiSlaughterhouseModelsSlaughterhouseLicense>,
    ///PD protection zones this slaughterhouse is in, if any.
    #[serde(
        rename = "pdProtectionZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub pd_protection_zones: ::std::vec::Vec<BwApiApiControlAreasModelsPdControlAreaDto>,
    ///PD surveillance zones this slaughterhouse is in, if any.
    #[serde(
        rename = "pdSurveillanceZones",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub pd_surveillance_zones: ::std::vec::Vec<
        BwApiApiControlAreasModelsPdControlAreaDto,
    >,
    ///ID of the national PD zone the slaughterhouse belongs to
    #[serde(
        rename = "pdZoneId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub pd_zone_id: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "slaughterhouseLocality",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub slaughterhouse_locality: ::std::option::Option<
        BwApiApiSlaughterhouseModelsSlaughterhouseLocality,
    >,
}
impl ::std::convert::From<&BwApiApiSlaughterhouseModelsSlaughterhouseDetails>
for BwApiApiSlaughterhouseModelsSlaughterhouseDetails {
    fn from(value: &BwApiApiSlaughterhouseModelsSlaughterhouseDetails) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiSlaughterhouseModelsSlaughterhouseDetails {
    fn default() -> Self {
        Self {
            ila_protection_zones: Default::default(),
            ila_surveillance_zones: Default::default(),
            licenses: Default::default(),
            pd_protection_zones: Default::default(),
            pd_surveillance_zones: Default::default(),
            pd_zone_id: Default::default(),
            slaughterhouse_locality: Default::default(),
        }
    }
}
impl BwApiApiSlaughterhouseModelsSlaughterhouseDetails {
    pub fn builder() -> builder::BwApiApiSlaughterhouseModelsSlaughterhouseDetails {
        Default::default()
    }
}
///BwApiApiSlaughterhouseModelsSlaughterhouseLicense
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "productionType": {
///      "type": "string",
///      "example": "Slakting av laksefisk",
///      "nullable": true
///    },
///    "validFrom": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2017-10-15T00:00:00.000Z",
///      "nullable": true
///    },
///    "validTo": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2019-10-15T00:00:00.000Z",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiSlaughterhouseModelsSlaughterhouseLicense {
    #[serde(
        rename = "productionType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub production_type: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "validFrom",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub valid_from: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "validTo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub valid_to: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiSlaughterhouseModelsSlaughterhouseLicense>
for BwApiApiSlaughterhouseModelsSlaughterhouseLicense {
    fn from(value: &BwApiApiSlaughterhouseModelsSlaughterhouseLicense) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiSlaughterhouseModelsSlaughterhouseLicense {
    fn default() -> Self {
        Self {
            production_type: Default::default(),
            valid_from: Default::default(),
            valid_to: Default::default(),
        }
    }
}
impl BwApiApiSlaughterhouseModelsSlaughterhouseLicense {
    pub fn builder() -> builder::BwApiApiSlaughterhouseModelsSlaughterhouseLicense {
        Default::default()
    }
}
///BwApiApiSlaughterhouseModelsSlaughterhouseLocality
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "approvalNumber": {
///      "type": "string",
///      "example": "H701",
///      "nullable": true
///    },
///    "company": {
///      "type": "string",
///      "example": "FIRMALAKS AS",
///      "nullable": true
///    },
///    "establishment": {
///      "type": "string",
///      "example": "FIRMALAKS AS",
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "description": "GeoJson point geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "id": {
///      "type": "string",
///      "example": "Z1109131314477261068UATRO",
///      "nullable": true
///    },
///    "validFrom": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2017-10-15T00:00:00.000Z",
///      "nullable": true
///    },
///    "validTo": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2019-10-15T00:00:00.000Z",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiSlaughterhouseModelsSlaughterhouseLocality {
    #[serde(
        rename = "approvalNumber",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub approval_number: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub company: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub establishment: ::std::option::Option<::std::string::String>,
    ///GeoJson point geometry
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "validFrom",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub valid_from: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "validTo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub valid_to: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiSlaughterhouseModelsSlaughterhouseLocality>
for BwApiApiSlaughterhouseModelsSlaughterhouseLocality {
    fn from(value: &BwApiApiSlaughterhouseModelsSlaughterhouseLocality) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiSlaughterhouseModelsSlaughterhouseLocality {
    fn default() -> Self {
        Self {
            approval_number: Default::default(),
            company: Default::default(),
            establishment: Default::default(),
            geometry: Default::default(),
            id: Default::default(),
            valid_from: Default::default(),
            valid_to: Default::default(),
        }
    }
}
impl BwApiApiSlaughterhouseModelsSlaughterhouseLocality {
    pub fn builder() -> builder::BwApiApiSlaughterhouseModelsSlaughterhouseLocality {
        Default::default()
    }
}
///BwApiApiVesselTrackWeeksModelsDisease
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "diseaseName": {
///      "description": "PD or ILA",
///      "type": "string",
///      "example": "PD",
///      "nullable": true
///    },
///    "fromDate": {
///      "type": "string",
///      "format": "date-time",
///      "example": "2019-11-29T00:00:00",
///      "nullable": true
///    },
///    "ruling": {
///      "type": "string",
///      "example": "Påvist",
///      "nullable": true
///    },
///    "toDate": {
///      "type": "string",
///      "format": "date-time",
///      "example": "",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiVesselTrackWeeksModelsDisease {
    ///PD or ILA
    #[serde(
        rename = "diseaseName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub disease_name: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "fromDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ruling: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "toDate",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_date: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiVesselTrackWeeksModelsDisease>
for BwApiApiVesselTrackWeeksModelsDisease {
    fn from(value: &BwApiApiVesselTrackWeeksModelsDisease) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsDisease {
    fn default() -> Self {
        Self {
            disease_name: Default::default(),
            from_date: Default::default(),
            ruling: Default::default(),
            to_date: Default::default(),
        }
    }
}
impl BwApiApiVesselTrackWeeksModelsDisease {
    pub fn builder() -> builder::BwApiApiVesselTrackWeeksModelsDisease {
        Default::default()
    }
}
///BwApiApiVesselTrackWeeksModelsDiseaseZoneType
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "IlaProtectionZone",
///    "IlaSurveillanceZone",
///    "PdProtectionZone",
///    "PdSurveillanceZone",
///    "PdZone"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum BwApiApiVesselTrackWeeksModelsDiseaseZoneType {
    IlaProtectionZone,
    IlaSurveillanceZone,
    PdProtectionZone,
    PdSurveillanceZone,
    PdZone,
}
impl ::std::convert::From<&Self> for BwApiApiVesselTrackWeeksModelsDiseaseZoneType {
    fn from(value: &BwApiApiVesselTrackWeeksModelsDiseaseZoneType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BwApiApiVesselTrackWeeksModelsDiseaseZoneType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::IlaProtectionZone => write!(f, "IlaProtectionZone"),
            Self::IlaSurveillanceZone => write!(f, "IlaSurveillanceZone"),
            Self::PdProtectionZone => write!(f, "PdProtectionZone"),
            Self::PdSurveillanceZone => write!(f, "PdSurveillanceZone"),
            Self::PdZone => write!(f, "PdZone"),
        }
    }
}
impl ::std::str::FromStr for BwApiApiVesselTrackWeeksModelsDiseaseZoneType {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "IlaProtectionZone" => Ok(Self::IlaProtectionZone),
            "IlaSurveillanceZone" => Ok(Self::IlaSurveillanceZone),
            "PdProtectionZone" => Ok(Self::PdProtectionZone),
            "PdSurveillanceZone" => Ok(Self::PdSurveillanceZone),
            "PdZone" => Ok(Self::PdZone),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BwApiApiVesselTrackWeeksModelsDiseaseZoneType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for BwApiApiVesselTrackWeeksModelsDiseaseZoneType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for BwApiApiVesselTrackWeeksModelsDiseaseZoneType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "diseaseZoneId": {
///      "type": "string",
///      "nullable": true
///    },
///    "diseaseZoneType": {
///      "$ref": "#/components/schemas/BW.Api.Api.VesselTrackWeeks.Models.DiseaseZoneType"
///    },
///    "fromPoint": {
///      "title": "GeoJson Geometry",
///      "description": "First point of visit (inside the zone)s.",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "fromTime": {
///      "description": "The start time of the visit. Null means visit started previous week.",
///      "type": "string",
///      "format": "date-time",
///      "example": "2017-12-12T04:10:04.000Z",
///      "nullable": true
///    },
///    "toPoint": {
///      "title": "GeoJson Geometry",
///      "description": "The point that ends the visit (outside the zone).",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "toTime": {
///      "description": "The end time of the visit. Null means visit has not ended (this week).",
///      "type": "string",
///      "format": "date-time",
///      "example": "2017-12-12T04:10:04.000Z",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit {
    #[serde(
        rename = "diseaseZoneId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub disease_zone_id: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "diseaseZoneType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub disease_zone_type: ::std::option::Option<
        BwApiApiVesselTrackWeeksModelsDiseaseZoneType,
    >,
    ///First point of visit (inside the zone)s.
    #[serde(
        rename = "fromPoint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_point: ::std::option::Option<GeoJsonGeometry>,
    ///The start time of the visit. Null means visit started previous week.
    #[serde(
        rename = "fromTime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_time: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    ///The point that ends the visit (outside the zone).
    #[serde(
        rename = "toPoint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_point: ::std::option::Option<GeoJsonGeometry>,
    ///The end time of the visit. Null means visit has not ended (this week).
    #[serde(
        rename = "toTime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_time: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit>
for BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit {
    fn from(value: &BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit {
    fn default() -> Self {
        Self {
            disease_zone_id: Default::default(),
            disease_zone_type: Default::default(),
            from_point: Default::default(),
            from_time: Default::default(),
            to_point: Default::default(),
            to_time: Default::default(),
        }
    }
}
impl BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit {
    pub fn builder() -> builder::BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit {
        Default::default()
    }
}
///BwApiApiVesselTrackWeeksModelsTrackAnalysis
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "diseaseZoneVisits": {
///      "description": "List of passages through disease zones.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.VesselTrackWeeks.Models.DiseaseZoneVisit"
///      },
///      "nullable": true
///    },
///    "hasDiseaseZoneVisitsAnalysis": {
///      "description": "Whether a disease zone analysis has been performed or not.",
///      "type": "boolean"
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32",
///      "example": 1966012
///    },
///    "isBasedOnSurfaceArea": {
///      "description": "Whether surface geometries (polygon) of aquaculture sites was used in the analysis, or point\r\ngeometries.",
///      "type": "boolean",
///      "example": true
///    },
///    "localityWaypoints": {
///      "description": "List of waypoints (aquaculture sites) the vessel has been in close proximity to, with low speed.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.VesselTrackWeeks.Models.VesselTrackWaypoint"
///      },
///      "nullable": true
///    },
///    "vesselTrackWeekId": {
///      "type": "integer",
///      "format": "int32",
///      "example": 19660
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiVesselTrackWeeksModelsTrackAnalysis {
    ///List of passages through disease zones.
    #[serde(
        rename = "diseaseZoneVisits",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub disease_zone_visits: ::std::vec::Vec<
        BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit,
    >,
    ///Whether a disease zone analysis has been performed or not.
    #[serde(
        rename = "hasDiseaseZoneVisitsAnalysis",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_disease_zone_visits_analysis: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    /**Whether surface geometries (polygon) of aquaculture sites was used in the analysis, or point
geometries.*/
    #[serde(
        rename = "isBasedOnSurfaceArea",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_based_on_surface_area: ::std::option::Option<bool>,
    ///List of waypoints (aquaculture sites) the vessel has been in close proximity to, with low speed.
    #[serde(
        rename = "localityWaypoints",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub locality_waypoints: ::std::vec::Vec<
        BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint,
    >,
    #[serde(
        rename = "vesselTrackWeekId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub vessel_track_week_id: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiVesselTrackWeeksModelsTrackAnalysis>
for BwApiApiVesselTrackWeeksModelsTrackAnalysis {
    fn from(value: &BwApiApiVesselTrackWeeksModelsTrackAnalysis) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsTrackAnalysis {
    fn default() -> Self {
        Self {
            disease_zone_visits: Default::default(),
            has_disease_zone_visits_analysis: Default::default(),
            id: Default::default(),
            is_based_on_surface_area: Default::default(),
            locality_waypoints: Default::default(),
            vessel_track_week_id: Default::default(),
        }
    }
}
impl BwApiApiVesselTrackWeeksModelsTrackAnalysis {
    pub fn builder() -> builder::BwApiApiVesselTrackWeeksModelsTrackAnalysis {
        Default::default()
    }
}
///BwApiApiVesselTrackWeeksModelsVesselInfo
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "isSlaughterBoat": {
///      "description": "True if the vessel has a valid slaughterboat (bløggebåt) license from Mattilsynet this week",
///      "type": "boolean"
///    },
///    "isWellboat": {
///      "type": "boolean",
///      "example": true
///    },
///    "mmsi": {
///      "description": "Maritime Mobile Service Identity",
///      "type": "integer",
///      "format": "int32",
///      "example": 257001000
///    },
///    "shipRegisterVesselType": {
///      "description": "VesselType code from Shipregister",
///      "type": "string",
///      "example": "9C",
///      "nullable": true
///    },
///    "shipRegisterVesselTypeNameEn": {
///      "description": "VesselType name in English (from Shipregister)",
///      "type": "string",
///      "example": "PLEASURE CRAFT/YACHT",
///      "nullable": true
///    },
///    "shipRegisterVesselTypeNameNo": {
///      "description": "VesselType name in Norwegian (from Shipregister)",
///      "type": "string",
///      "example": "FRITIDSFARTØY",
///      "nullable": true
///    },
///    "shipType": {
///      "description": "AIS ship type",
///      "type": "integer",
///      "format": "int32",
///      "example": 70
///    },
///    "vesselName": {
///      "type": "string",
///      "example": "RO ARCTIC",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiVesselTrackWeeksModelsVesselInfo {
    ///True if the vessel has a valid slaughterboat (bløggebåt) license from Mattilsynet this week
    #[serde(
        rename = "isSlaughterBoat",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_slaughter_boat: ::std::option::Option<bool>,
    #[serde(
        rename = "isWellboat",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_wellboat: ::std::option::Option<bool>,
    ///Maritime Mobile Service Identity
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mmsi: ::std::option::Option<i32>,
    ///VesselType code from Shipregister
    #[serde(
        rename = "shipRegisterVesselType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type: ::std::option::Option<::std::string::String>,
    ///VesselType name in English (from Shipregister)
    #[serde(
        rename = "shipRegisterVesselTypeNameEn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type_name_en: ::std::option::Option<::std::string::String>,
    ///VesselType name in Norwegian (from Shipregister)
    #[serde(
        rename = "shipRegisterVesselTypeNameNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type_name_no: ::std::option::Option<::std::string::String>,
    ///AIS ship type
    #[serde(
        rename = "shipType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_type: ::std::option::Option<i32>,
    #[serde(
        rename = "vesselName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub vessel_name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiVesselTrackWeeksModelsVesselInfo>
for BwApiApiVesselTrackWeeksModelsVesselInfo {
    fn from(value: &BwApiApiVesselTrackWeeksModelsVesselInfo) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselInfo {
    fn default() -> Self {
        Self {
            is_slaughter_boat: Default::default(),
            is_wellboat: Default::default(),
            mmsi: Default::default(),
            ship_register_vessel_type: Default::default(),
            ship_register_vessel_type_name_en: Default::default(),
            ship_register_vessel_type_name_no: Default::default(),
            ship_type: Default::default(),
            vessel_name: Default::default(),
        }
    }
}
impl BwApiApiVesselTrackWeeksModelsVesselInfo {
    pub fn builder() -> builder::BwApiApiVesselTrackWeeksModelsVesselInfo {
        Default::default()
    }
}
///BwApiApiVesselTrackWeeksModelsVesselPosition
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "a": {
///      "description": "Ship dimension: Meters from the AIS antenna to the bow",
///      "type": "integer",
///      "format": "int32",
///      "example": 2,
///      "nullable": true
///    },
///    "b": {
///      "description": "Ship dimension: Meters from the AIS antenna to the stern",
///      "type": "integer",
///      "format": "int32",
///      "example": 15,
///      "nullable": true
///    },
///    "c": {
///      "description": "Ship dimension: Meters from the AIS antenna to port side of the vessel",
///      "type": "integer",
///      "format": "int32",
///      "example": 4,
///      "nullable": true
///    },
///    "callsign": {
///      "type": "string",
///      "example": "LLUZ",
///      "nullable": true
///    },
///    "cog": {
///      "description": "course over ground (degrees)",
///      "type": "number",
///      "format": "double",
///      "example": 289.5,
///      "nullable": true
///    },
///    "d": {
///      "description": "Ship dimension: Meters from the AIS antenna to starboard side of the vessel",
///      "type": "integer",
///      "format": "int32",
///      "example": 1,
///      "nullable": true
///    },
///    "destination": {
///      "type": "string",
///      "nullable": true
///    },
///    "draught": {
///      "type": "number",
///      "format": "double",
///      "nullable": true
///    },
///    "eta": {
///      "type": "string",
///      "format": "date-time",
///      "nullable": true
///    },
///    "geometry": {
///      "title": "GeoJson Geometry",
///      "description": "GeoJSON point geometry",
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "heading": {
///      "type": "number",
///      "format": "double",
///      "example": 195,
///      "nullable": true
///    },
///    "isSlaughterBoat": {
///      "description": "True if the vessel has a valid slaughterboat (bløggebåt) license from Mattilsynet",
///      "type": "boolean"
///    },
///    "isWellBoat": {
///      "type": "boolean"
///    },
///    "mmsi": {
///      "description": "Maritime Mobile Service Identity - Identification number for a vessel",
///      "type": "integer",
///      "format": "int32",
///      "example": 259584000
///    },
///    "name": {
///      "type": "string",
///      "example": "ROHAV",
///      "nullable": true
///    },
///    "navstat": {
///      "description": "Navigational status (as defined by AIS standard)\r\n- 0: Under way using engine\r\n- 1: At anchor\r\n- 2: Not under command\r\n- 3: Restricted manoeuverability\r\n- 4: Constrained by her draught\r\n- 5: Moored\r\n- 6: Aground\r\n- 7: Engaged in Fishing\r\n- 8: Under way sailing\r\n- 9: Reserved for future amendment of Navigational Status for HSC\r\n- 10: Reserved for future amendment of Navigational Status for WIG\r\n- 11: Reserved for future use\r\n- 12: Reserved for future use\r\n- 13: Reserved for future use\r\n- 14: AIS-SART is active\r\n- 15: Not defined (default)",
///      "type": "integer",
///      "format": "int32",
///      "example": 0
///    },
///    "rot": {
///      "description": "rate of turn",
///      "type": "number",
///      "format": "double",
///      "example": 0,
///      "nullable": true
///    },
///    "shipRegisterVesselType": {
///      "description": "VesselType code from Shipregister",
///      "type": "string",
///      "example": "9C",
///      "nullable": true
///    },
///    "shipRegisterVesselTypeNameEn": {
///      "description": "VesselType name in English (from Shipregister)",
///      "type": "string",
///      "example": "PLEASURE CRAFT/YACHT",
///      "nullable": true
///    },
///    "shipRegisterVesselTypeNameNo": {
///      "description": "VesselType name in Norwegian (from Shipregister)",
///      "type": "string",
///      "example": "FRITIDSFARTØY",
///      "nullable": true
///    },
///    "shipType": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "sog": {
///      "description": "speed over ground",
///      "type": "number",
///      "format": "double",
///      "example": 0
///    },
///    "timestamp": {
///      "description": "timestamp of data",
///      "type": "string",
///      "format": "date-time",
///      "example": "2020-06-05T09:58:09Z"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiVesselTrackWeeksModelsVesselPosition {
    ///Ship dimension: Meters from the AIS antenna to the bow
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub a: ::std::option::Option<i32>,
    ///Ship dimension: Meters from the AIS antenna to the stern
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub b: ::std::option::Option<i32>,
    ///Ship dimension: Meters from the AIS antenna to port side of the vessel
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub c: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub callsign: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cog: ::std::option::Option<f64>,
    ///Ship dimension: Meters from the AIS antenna to starboard side of the vessel
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub d: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub destination: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub draught: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub eta: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    ///GeoJSON point geometry
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geometry: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub heading: ::std::option::Option<f64>,
    ///True if the vessel has a valid slaughterboat (bløggebåt) license from Mattilsynet
    #[serde(
        rename = "isSlaughterBoat",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_slaughter_boat: ::std::option::Option<bool>,
    #[serde(
        rename = "isWellBoat",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_well_boat: ::std::option::Option<bool>,
    ///Maritime Mobile Service Identity - Identification number for a vessel
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mmsi: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    /**Navigational status (as defined by AIS standard)
- 0: Under way using engine
- 1: At anchor
- 2: Not under command
- 3: Restricted manoeuverability
- 4: Constrained by her draught
- 5: Moored
- 6: Aground
- 7: Engaged in Fishing
- 8: Under way sailing
- 9: Reserved for future amendment of Navigational Status for HSC
- 10: Reserved for future amendment of Navigational Status for WIG
- 11: Reserved for future use
- 12: Reserved for future use
- 13: Reserved for future use
- 14: AIS-SART is active
- 15: Not defined (default)*/
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub navstat: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub rot: ::std::option::Option<f64>,
    ///VesselType code from Shipregister
    #[serde(
        rename = "shipRegisterVesselType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type: ::std::option::Option<::std::string::String>,
    ///VesselType name in English (from Shipregister)
    #[serde(
        rename = "shipRegisterVesselTypeNameEn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type_name_en: ::std::option::Option<::std::string::String>,
    ///VesselType name in Norwegian (from Shipregister)
    #[serde(
        rename = "shipRegisterVesselTypeNameNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type_name_no: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "shipType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_type: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sog: ::std::option::Option<f64>,
    ///timestamp of data
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timestamp: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiVesselTrackWeeksModelsVesselPosition>
for BwApiApiVesselTrackWeeksModelsVesselPosition {
    fn from(value: &BwApiApiVesselTrackWeeksModelsVesselPosition) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselPosition {
    fn default() -> Self {
        Self {
            a: Default::default(),
            b: Default::default(),
            c: Default::default(),
            callsign: Default::default(),
            cog: Default::default(),
            d: Default::default(),
            destination: Default::default(),
            draught: Default::default(),
            eta: Default::default(),
            geometry: Default::default(),
            heading: Default::default(),
            is_slaughter_boat: Default::default(),
            is_well_boat: Default::default(),
            mmsi: Default::default(),
            name: Default::default(),
            navstat: Default::default(),
            rot: Default::default(),
            ship_register_vessel_type: Default::default(),
            ship_register_vessel_type_name_en: Default::default(),
            ship_register_vessel_type_name_no: Default::default(),
            ship_type: Default::default(),
            sog: Default::default(),
            timestamp: Default::default(),
        }
    }
}
impl BwApiApiVesselTrackWeeksModelsVesselPosition {
    pub fn builder() -> builder::BwApiApiVesselTrackWeeksModelsVesselPosition {
        Default::default()
    }
}
///BwApiApiVesselTrackWeeksModelsVesselTrack
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "fromTime": {
///      "description": "Timestamp of the first point in the track.",
///      "type": "string",
///      "format": "date-time"
///    },
///    "id": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "isNoSignal": {
///      "description": "If true, this is a line between two points where one hour or more passed between received AIS positions.\r\nIf false it is a normal track.",
///      "type": "boolean"
///    },
///    "points": {
///      "description": "Detailed information (with speed, course etc) for some of the points in the track.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.Ais.Models.AisRestPositionDto"
///      },
///      "nullable": true
///    },
///    "toTime": {
///      "description": "Timestamp of the last point in the track.",
///      "type": "string",
///      "format": "date-time"
///    },
///    "vesselTrackWeekId": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiVesselTrackWeeksModelsVesselTrack {
    ///Timestamp of the first point in the track.
    #[serde(
        rename = "fromTime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_time: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i32>,
    /**If true, this is a line between two points where one hour or more passed between received AIS positions.
If false it is a normal track.*/
    #[serde(
        rename = "isNoSignal",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_no_signal: ::std::option::Option<bool>,
    ///Detailed information (with speed, course etc) for some of the points in the track.
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub points: ::std::vec::Vec<BwApiApiAisModelsAisRestPositionDto>,
    ///Timestamp of the last point in the track.
    #[serde(
        rename = "toTime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_time: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "vesselTrackWeekId",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub vessel_track_week_id: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiVesselTrackWeeksModelsVesselTrack>
for BwApiApiVesselTrackWeeksModelsVesselTrack {
    fn from(value: &BwApiApiVesselTrackWeeksModelsVesselTrack) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselTrack {
    fn default() -> Self {
        Self {
            from_time: Default::default(),
            id: Default::default(),
            is_no_signal: Default::default(),
            points: Default::default(),
            to_time: Default::default(),
            vessel_track_week_id: Default::default(),
        }
    }
}
impl BwApiApiVesselTrackWeeksModelsVesselTrack {
    pub fn builder() -> builder::BwApiApiVesselTrackWeeksModelsVesselTrack {
        Default::default()
    }
}
///BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "anlysisBasedOnSurfaceArea": {
///      "description": "If the analysis is based on the surface area of the aquaculture site. If false, the point location from the\r\naquaculture register is used.",
///      "type": "boolean",
///      "example": true,
///      "nullable": true
///    },
///    "localityNo": {
///      "description": "Site id",
///      "type": "integer",
///      "format": "int32",
///      "example": 31557
///    },
///    "vesselVisits": {
///      "description": "Vessel visits at requested site for the requested week.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.VesselTrackWeeks.Models.VesselVisit"
///      },
///      "nullable": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32",
///      "example": 50
///    },
///    "weekIsAnalyzed": {
///      "description": "If weekIsAnalysed is false, there is no wellboat analysis data available for this aquaculture site and week.",
///      "type": "boolean",
///      "example": true
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32",
///      "example": 2017
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek {
    /**If the analysis is based on the surface area of the aquaculture site. If false, the point location from the
aquaculture register is used.*/
    #[serde(
        rename = "anlysisBasedOnSurfaceArea",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub anlysis_based_on_surface_area: ::std::option::Option<bool>,
    ///Site id
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    ///Vessel visits at requested site for the requested week.
    #[serde(
        rename = "vesselVisits",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub vessel_visits: ::std::vec::Vec<BwApiApiVesselTrackWeeksModelsVesselVisit>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    ///If weekIsAnalysed is false, there is no wellboat analysis data available for this aquaculture site and week.
    #[serde(
        rename = "weekIsAnalyzed",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub week_is_analyzed: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek>
for BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek {
    fn from(value: &BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek {
    fn default() -> Self {
        Self {
            anlysis_based_on_surface_area: Default::default(),
            locality_no: Default::default(),
            vessel_visits: Default::default(),
            week: Default::default(),
            week_is_analyzed: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek {
    pub fn builder() -> builder::BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek {
        Default::default()
    }
}
///BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "diseases": {
///      "description": "A System.Collections.Generic.List`1 that is equal if its members are equal.\r\nUseful in records, to maintain equality when list properties have the same contents.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.VesselTrackWeeks.Models.Disease"
///      },
///      "nullable": true
///    },
///    "fromTime": {
///      "description": "The start time of the visit",
///      "type": "string",
///      "format": "date-time",
///      "example": "2017-12-12T04:10:04Z"
///    },
///    "isBasedOnSurfaceArea": {
///      "description": "Whether surface geometries (polygon) of aquaculture sites was used in the analysis, or point\r\ngeometries.",
///      "type": "boolean",
///      "example": true
///    },
///    "isJuvenile": {
///      "description": "Is the site a juvenile site, according to the aquaculture register",
///      "type": "boolean",
///      "example": false
///    },
///    "isOnLand": {
///      "type": "boolean",
///      "example": false
///    },
///    "isSlaughterHoldingCage": {
///      "description": "Is the site a slaughterholdingcage, according to the aquaculture register",
///      "type": "boolean",
///      "example": true
///    },
///    "localityNo": {
///      "description": "Site id",
///      "type": "integer",
///      "format": "int32",
///      "example": 13720
///    },
///    "name": {
///      "description": "Aquaculture site name",
///      "type": "string",
///      "example": "Ulvan",
///      "nullable": true
///    },
///    "toTime": {
///      "description": "The stop time of the visit (or end of week)",
///      "type": "string",
///      "format": "date-time",
///      "example": "2017-12-12T08:10:02Z",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint {
    /**A System.Collections.Generic.List`1 that is equal if its members are equal.
Useful in records, to maintain equality when list properties have the same contents.*/
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub diseases: ::std::vec::Vec<BwApiApiVesselTrackWeeksModelsDisease>,
    ///The start time of the visit
    #[serde(
        rename = "fromTime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub from_time: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    /**Whether surface geometries (polygon) of aquaculture sites was used in the analysis, or point
geometries.*/
    #[serde(
        rename = "isBasedOnSurfaceArea",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_based_on_surface_area: ::std::option::Option<bool>,
    ///Is the site a juvenile site, according to the aquaculture register
    #[serde(
        rename = "isJuvenile",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_juvenile: ::std::option::Option<bool>,
    #[serde(
        rename = "isOnLand",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_on_land: ::std::option::Option<bool>,
    ///Is the site a slaughterholdingcage, according to the aquaculture register
    #[serde(
        rename = "isSlaughterHoldingCage",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_slaughter_holding_cage: ::std::option::Option<bool>,
    ///Site id
    #[serde(
        rename = "localityNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub locality_no: ::std::option::Option<i32>,
    ///Aquaculture site name
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    ///The stop time of the visit (or end of week)
    #[serde(
        rename = "toTime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub to_time: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
}
impl ::std::convert::From<&BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint>
for BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint {
    fn from(value: &BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint {
    fn default() -> Self {
        Self {
            diseases: Default::default(),
            from_time: Default::default(),
            is_based_on_surface_area: Default::default(),
            is_juvenile: Default::default(),
            is_on_land: Default::default(),
            is_slaughter_holding_cage: Default::default(),
            locality_no: Default::default(),
            name: Default::default(),
            to_time: Default::default(),
        }
    }
}
impl BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint {
    pub fn builder() -> builder::BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint {
        Default::default()
    }
}
///BwApiApiVesselTrackWeeksModelsVesselTrackWeek
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "id": {
///      "type": "integer",
///      "format": "int64"
///    },
///    "isSlaughterBoat": {
///      "type": "boolean"
///    },
///    "isWellBoat": {
///      "type": "boolean"
///    },
///    "mmsi": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "shipRegisterVesselType": {
///      "description": "VesselType code from Shipregister",
///      "type": "string",
///      "example": "9C",
///      "nullable": true
///    },
///    "shipRegisterVesselTypeNameEn": {
///      "description": "VesselType name in English (from Shipregister)",
///      "type": "string",
///      "example": "PLEASURE CRAFT/YACHT",
///      "nullable": true
///    },
///    "shipRegisterVesselTypeNameNo": {
///      "description": "VesselType name in Norwegian (from Shipregister)",
///      "type": "string",
///      "example": "FRITIDSFARTØY",
///      "nullable": true
///    },
///    "shipType": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "trackAnalysis": {
///      "$ref": "#/components/schemas/BW.Api.Api.VesselTrackWeeks.Models.TrackAnalysis"
///    },
///    "vesselName": {
///      "type": "string",
///      "nullable": true
///    },
///    "vesselTracks": {
///      "description": "A System.Collections.Generic.List`1 that is equal if its members are equal.\r\nUseful in records, to maintain equality when list properties have the same contents.",
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/BW.Api.Api.VesselTrackWeeks.Models.VesselTrack"
///      },
///      "nullable": true
///    },
///    "week": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "year": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiVesselTrackWeeksModelsVesselTrackWeek {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<i64>,
    #[serde(
        rename = "isSlaughterBoat",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_slaughter_boat: ::std::option::Option<bool>,
    #[serde(
        rename = "isWellBoat",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_well_boat: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mmsi: ::std::option::Option<i32>,
    ///VesselType code from Shipregister
    #[serde(
        rename = "shipRegisterVesselType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type: ::std::option::Option<::std::string::String>,
    ///VesselType name in English (from Shipregister)
    #[serde(
        rename = "shipRegisterVesselTypeNameEn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type_name_en: ::std::option::Option<::std::string::String>,
    ///VesselType name in Norwegian (from Shipregister)
    #[serde(
        rename = "shipRegisterVesselTypeNameNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type_name_no: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "shipType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_type: ::std::option::Option<i32>,
    #[serde(
        rename = "trackAnalysis",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub track_analysis: ::std::option::Option<
        BwApiApiVesselTrackWeeksModelsTrackAnalysis,
    >,
    #[serde(
        rename = "vesselName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub vessel_name: ::std::option::Option<::std::string::String>,
    /**A System.Collections.Generic.List`1 that is equal if its members are equal.
Useful in records, to maintain equality when list properties have the same contents.*/
    #[serde(
        rename = "vesselTracks",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub vessel_tracks: ::std::vec::Vec<BwApiApiVesselTrackWeeksModelsVesselTrack>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub week: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub year: ::std::option::Option<i32>,
}
impl ::std::convert::From<&BwApiApiVesselTrackWeeksModelsVesselTrackWeek>
for BwApiApiVesselTrackWeeksModelsVesselTrackWeek {
    fn from(value: &BwApiApiVesselTrackWeeksModelsVesselTrackWeek) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselTrackWeek {
    fn default() -> Self {
        Self {
            id: Default::default(),
            is_slaughter_boat: Default::default(),
            is_well_boat: Default::default(),
            mmsi: Default::default(),
            ship_register_vessel_type: Default::default(),
            ship_register_vessel_type_name_en: Default::default(),
            ship_register_vessel_type_name_no: Default::default(),
            ship_type: Default::default(),
            track_analysis: Default::default(),
            vessel_name: Default::default(),
            vessel_tracks: Default::default(),
            week: Default::default(),
            year: Default::default(),
        }
    }
}
impl BwApiApiVesselTrackWeeksModelsVesselTrackWeek {
    pub fn builder() -> builder::BwApiApiVesselTrackWeeksModelsVesselTrackWeek {
        Default::default()
    }
}
///BwApiApiVesselTrackWeeksModelsVesselVisit
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "isSlaughterBoat": {
///      "type": "boolean"
///    },
///    "isWellboat": {
///      "type": "boolean",
///      "example": true
///    },
///    "mmsi": {
///      "description": "Maritime Mobile Service Identity - Identification number for a vessel",
///      "type": "integer",
///      "format": "int32",
///      "example": 259634000
///    },
///    "shipRegisterVesselType": {
///      "description": "VesselType code from Shipregister",
///      "type": "string",
///      "example": "9C",
///      "nullable": true
///    },
///    "shipRegisterVesselTypeNameEn": {
///      "description": "VesselType name in English (from Shipregister)",
///      "type": "string",
///      "example": "PLEASURE CRAFT/YACHT",
///      "nullable": true
///    },
///    "shipRegisterVesselTypeNameNo": {
///      "description": "VesselType name in Norwegian (from Shipregister)",
///      "type": "string",
///      "example": "FRITIDSFARTØY",
///      "nullable": true
///    },
///    "shipType": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "startTime": {
///      "description": "The start time of the visit",
///      "type": "string",
///      "format": "date-time",
///      "example": "2017-12-12T08:10:02Z"
///    },
///    "stopTime": {
///      "description": "The stop time of the visit (or end of week)",
///      "type": "string",
///      "format": "date-time",
///      "example": "2017-12-12T08:10:02Z",
///      "nullable": true
///    },
///    "vesselName": {
///      "type": "string",
///      "example": "FRØYTIND",
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BwApiApiVesselTrackWeeksModelsVesselVisit {
    #[serde(
        rename = "isSlaughterBoat",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_slaughter_boat: ::std::option::Option<bool>,
    #[serde(
        rename = "isWellboat",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_wellboat: ::std::option::Option<bool>,
    ///Maritime Mobile Service Identity - Identification number for a vessel
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mmsi: ::std::option::Option<i32>,
    ///VesselType code from Shipregister
    #[serde(
        rename = "shipRegisterVesselType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type: ::std::option::Option<::std::string::String>,
    ///VesselType name in English (from Shipregister)
    #[serde(
        rename = "shipRegisterVesselTypeNameEn",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type_name_en: ::std::option::Option<::std::string::String>,
    ///VesselType name in Norwegian (from Shipregister)
    #[serde(
        rename = "shipRegisterVesselTypeNameNo",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_register_vessel_type_name_no: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "shipType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ship_type: ::std::option::Option<i32>,
    ///The start time of the visit
    #[serde(
        rename = "startTime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub start_time: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    ///The stop time of the visit (or end of week)
    #[serde(
        rename = "stopTime",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stop_time: ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
    #[serde(
        rename = "vesselName",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub vessel_name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&BwApiApiVesselTrackWeeksModelsVesselVisit>
for BwApiApiVesselTrackWeeksModelsVesselVisit {
    fn from(value: &BwApiApiVesselTrackWeeksModelsVesselVisit) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselVisit {
    fn default() -> Self {
        Self {
            is_slaughter_boat: Default::default(),
            is_wellboat: Default::default(),
            mmsi: Default::default(),
            ship_register_vessel_type: Default::default(),
            ship_register_vessel_type_name_en: Default::default(),
            ship_register_vessel_type_name_no: Default::default(),
            ship_type: Default::default(),
            start_time: Default::default(),
            stop_time: Default::default(),
            vessel_name: Default::default(),
        }
    }
}
impl BwApiApiVesselTrackWeeksModelsVesselVisit {
    pub fn builder() -> builder::BwApiApiVesselTrackWeeksModelsVesselVisit {
        Default::default()
    }
}
///GeoJsonGeometry
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "title": "GeoJson Geometry",
///  "type": "object",
///  "anyOf": [
///    {
///      "title": "GeoJson Point Geometry",
///      "type": "object",
///      "required": [
///        "coordinates",
///        "type"
///      ],
///      "properties": {
///        "coordinates": {
///          "type": "array",
///          "items": {
///            "type": "number"
///          },
///          "minItems": 2,
///          "example": [
///            10.4,
///            60.5
///          ]
///        },
///        "type": {
///          "default": "Point",
///          "type": "string",
///          "enum": [
///            "Point"
///          ]
///        }
///      }
///    },
///    {
///      "title": "GeoJson LineString Geometry",
///      "type": "object",
///      "required": [
///        "coordinates",
///        "type"
///      ],
///      "properties": {
///        "coordinates": {
///          "type": "array",
///          "items": {
///            "type": "array",
///            "items": {
///              "type": "number"
///            },
///            "minItems": 2,
///            "example": [
///              10.4,
///              60.5
///            ]
///          },
///          "minItems": 2
///        },
///        "type": {
///          "enum": [
///            "LineString"
///          ]
///        }
///      }
///    },
///    {
///      "title": "GeoJson Polygon Geometry",
///      "type": "object",
///      "required": [
///        "coordinates",
///        "type"
///      ],
///      "properties": {
///        "coordinates": {
///          "type": "array",
///          "items": {
///            "type": "array",
///            "items": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            }
///          },
///          "minItems": 4
///        },
///        "type": {
///          "enum": [
///            "Polygon"
///          ]
///        }
///      }
///    }
///  ],
///  "nullable": true
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(tag = "type", content = "coordinates")]
pub enum GeoJsonGeometry {
    ///GeoJson Point Geometry
    Point(::std::vec::Vec<f64>),
    ///GeoJson LineString Geometry
    LineString(::std::vec::Vec<::std::vec::Vec<f64>>),
    ///GeoJson Polygon Geometry
    Polygon(::std::vec::Vec<::std::vec::Vec<::std::vec::Vec<f64>>>),
}
impl ::std::convert::From<&Self> for GeoJsonGeometry {
    fn from(value: &GeoJsonGeometry) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<f64>> for GeoJsonGeometry {
    fn from(value: ::std::vec::Vec<f64>) -> Self {
        Self::Point(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::vec::Vec<f64>>> for GeoJsonGeometry {
    fn from(value: ::std::vec::Vec<::std::vec::Vec<f64>>) -> Self {
        Self::LineString(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::vec::Vec<::std::vec::Vec<f64>>>>
for GeoJsonGeometry {
    fn from(value: ::std::vec::Vec<::std::vec::Vec<::std::vec::Vec<f64>>>) -> Self {
        Self::Polygon(value)
    }
}
///MicrosoftAspNetCoreMvcProblemDetails
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "detail": {
///      "type": "string",
///      "nullable": true
///    },
///    "instance": {
///      "type": "string",
///      "nullable": true
///    },
///    "status": {
///      "type": "integer",
///      "format": "int32",
///      "nullable": true
///    },
///    "title": {
///      "type": "string",
///      "nullable": true
///    },
///    "type": {
///      "type": "string",
///      "nullable": true
///    }
///  },
///  "additionalProperties": {}
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
pub struct MicrosoftAspNetCoreMvcProblemDetails {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub detail: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub instance: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub status: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&MicrosoftAspNetCoreMvcProblemDetails>
for MicrosoftAspNetCoreMvcProblemDetails {
    fn from(value: &MicrosoftAspNetCoreMvcProblemDetails) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for MicrosoftAspNetCoreMvcProblemDetails {
    fn default() -> Self {
        Self {
            detail: Default::default(),
            instance: Default::default(),
            status: Default::default(),
            title: Default::default(),
            type_: Default::default(),
        }
    }
}
impl MicrosoftAspNetCoreMvcProblemDetails {
    pub fn builder() -> builder::MicrosoftAspNetCoreMvcProblemDetails {
        Default::default()
    }
}
///NetTopologySuiteGeometriesCoordinateEqualityComparer
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NetTopologySuiteGeometriesCoordinateEqualityComparer {}
impl ::std::convert::From<&NetTopologySuiteGeometriesCoordinateEqualityComparer>
for NetTopologySuiteGeometriesCoordinateEqualityComparer {
    fn from(value: &NetTopologySuiteGeometriesCoordinateEqualityComparer) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NetTopologySuiteGeometriesCoordinateEqualityComparer {
    fn default() -> Self {
        Self {}
    }
}
impl NetTopologySuiteGeometriesCoordinateEqualityComparer {
    pub fn builder() -> builder::NetTopologySuiteGeometriesCoordinateEqualityComparer {
        Default::default()
    }
}
///NetTopologySuiteGeometriesCoordinateSequence
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "count": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "dimension": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "first": {
///      "readOnly": true,
///      "type": "array",
///      "items": {
///        "type": "number"
///      },
///      "minItems": 2,
///      "example": [
///        10.4,
///        60.5
///      ],
///      "nullable": true
///    },
///    "hasM": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "hasZ": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "last": {
///      "readOnly": true,
///      "type": "array",
///      "items": {
///        "type": "number"
///      },
///      "minItems": 2,
///      "example": [
///        10.4,
///        60.5
///      ],
///      "nullable": true
///    },
///    "mOrdinateIndex": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "measures": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "ordinates": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Ordinates"
///    },
///    "spatial": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "zOrdinateIndex": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NetTopologySuiteGeometriesCoordinateSequence {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dimension: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub first: ::std::vec::Vec<f64>,
    #[serde(
        rename = "hasM",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_m: ::std::option::Option<bool>,
    #[serde(
        rename = "hasZ",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub has_z: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub last: ::std::vec::Vec<f64>,
    #[serde(
        rename = "mOrdinateIndex",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub m_ordinate_index: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub measures: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ordinates: ::std::option::Option<NetTopologySuiteGeometriesOrdinates>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub spatial: ::std::option::Option<i32>,
    #[serde(
        rename = "zOrdinateIndex",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub z_ordinate_index: ::std::option::Option<i32>,
}
impl ::std::convert::From<&NetTopologySuiteGeometriesCoordinateSequence>
for NetTopologySuiteGeometriesCoordinateSequence {
    fn from(value: &NetTopologySuiteGeometriesCoordinateSequence) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NetTopologySuiteGeometriesCoordinateSequence {
    fn default() -> Self {
        Self {
            count: Default::default(),
            dimension: Default::default(),
            first: Default::default(),
            has_m: Default::default(),
            has_z: Default::default(),
            last: Default::default(),
            m_ordinate_index: Default::default(),
            measures: Default::default(),
            ordinates: Default::default(),
            spatial: Default::default(),
            z_ordinate_index: Default::default(),
        }
    }
}
impl NetTopologySuiteGeometriesCoordinateSequence {
    pub fn builder() -> builder::NetTopologySuiteGeometriesCoordinateSequence {
        Default::default()
    }
}
///NetTopologySuiteGeometriesCoordinateSequenceFactory
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "ordinates": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Ordinates"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NetTopologySuiteGeometriesCoordinateSequenceFactory {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ordinates: ::std::option::Option<NetTopologySuiteGeometriesOrdinates>,
}
impl ::std::convert::From<&NetTopologySuiteGeometriesCoordinateSequenceFactory>
for NetTopologySuiteGeometriesCoordinateSequenceFactory {
    fn from(value: &NetTopologySuiteGeometriesCoordinateSequenceFactory) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NetTopologySuiteGeometriesCoordinateSequenceFactory {
    fn default() -> Self {
        Self {
            ordinates: Default::default(),
        }
    }
}
impl NetTopologySuiteGeometriesCoordinateSequenceFactory {
    pub fn builder() -> builder::NetTopologySuiteGeometriesCoordinateSequenceFactory {
        Default::default()
    }
}
///NetTopologySuiteGeometriesDimension
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "Point",
///    "Curve",
///    "A",
///    "Collapse",
///    "Dontcare",
///    "True",
///    "False"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum NetTopologySuiteGeometriesDimension {
    Point,
    Curve,
    A,
    Collapse,
    Dontcare,
    True,
    False,
}
impl ::std::convert::From<&Self> for NetTopologySuiteGeometriesDimension {
    fn from(value: &NetTopologySuiteGeometriesDimension) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NetTopologySuiteGeometriesDimension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Point => write!(f, "Point"),
            Self::Curve => write!(f, "Curve"),
            Self::A => write!(f, "A"),
            Self::Collapse => write!(f, "Collapse"),
            Self::Dontcare => write!(f, "Dontcare"),
            Self::True => write!(f, "True"),
            Self::False => write!(f, "False"),
        }
    }
}
impl ::std::str::FromStr for NetTopologySuiteGeometriesDimension {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Point" => Ok(Self::Point),
            "Curve" => Ok(Self::Curve),
            "A" => Ok(Self::A),
            "Collapse" => Ok(Self::Collapse),
            "Dontcare" => Ok(Self::Dontcare),
            "True" => Ok(Self::True),
            "False" => Ok(Self::False),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NetTopologySuiteGeometriesDimension {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for NetTopologySuiteGeometriesDimension {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for NetTopologySuiteGeometriesDimension {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///NetTopologySuiteGeometriesEnvelope
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "area": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "centre": {
///      "readOnly": true,
///      "type": "array",
///      "items": {
///        "type": "number"
///      },
///      "minItems": 2,
///      "example": [
///        10.4,
///        60.5
///      ],
///      "nullable": true
///    },
///    "diameter": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "height": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "isNull": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "maxExtent": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "maxX": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "maxY": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "minExtent": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "minX": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "minY": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "width": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NetTopologySuiteGeometriesEnvelope {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub area: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub centre: ::std::vec::Vec<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub diameter: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub height: ::std::option::Option<f64>,
    #[serde(
        rename = "isNull",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_null: ::std::option::Option<bool>,
    #[serde(
        rename = "maxExtent",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_extent: ::std::option::Option<f64>,
    #[serde(
        rename = "maxX",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_x: ::std::option::Option<f64>,
    #[serde(
        rename = "maxY",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_y: ::std::option::Option<f64>,
    #[serde(
        rename = "minExtent",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_extent: ::std::option::Option<f64>,
    #[serde(
        rename = "minX",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_x: ::std::option::Option<f64>,
    #[serde(
        rename = "minY",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_y: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub width: ::std::option::Option<f64>,
}
impl ::std::convert::From<&NetTopologySuiteGeometriesEnvelope>
for NetTopologySuiteGeometriesEnvelope {
    fn from(value: &NetTopologySuiteGeometriesEnvelope) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NetTopologySuiteGeometriesEnvelope {
    fn default() -> Self {
        Self {
            area: Default::default(),
            centre: Default::default(),
            diameter: Default::default(),
            height: Default::default(),
            is_null: Default::default(),
            max_extent: Default::default(),
            max_x: Default::default(),
            max_y: Default::default(),
            min_extent: Default::default(),
            min_x: Default::default(),
            min_y: Default::default(),
            width: Default::default(),
        }
    }
}
impl NetTopologySuiteGeometriesEnvelope {
    pub fn builder() -> builder::NetTopologySuiteGeometriesEnvelope {
        Default::default()
    }
}
///NetTopologySuiteGeometriesGeometryFactory
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "coordinateSequenceFactory": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.CoordinateSequenceFactory"
///    },
///    "geometryServices": {
///      "$ref": "#/components/schemas/NetTopologySuite.NtsGeometryServices"
///    },
///    "precisionModel": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.PrecisionModel"
///    },
///    "srid": {
///      "type": "integer",
///      "format": "int32"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NetTopologySuiteGeometriesGeometryFactory {
    #[serde(
        rename = "coordinateSequenceFactory",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub coordinate_sequence_factory: ::std::option::Option<
        NetTopologySuiteGeometriesCoordinateSequenceFactory,
    >,
    #[serde(
        rename = "geometryServices",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub geometry_services: ::std::option::Option<NetTopologySuiteNtsGeometryServices>,
    #[serde(
        rename = "precisionModel",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub precision_model: ::std::option::Option<NetTopologySuiteGeometriesPrecisionModel>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub srid: ::std::option::Option<i32>,
}
impl ::std::convert::From<&NetTopologySuiteGeometriesGeometryFactory>
for NetTopologySuiteGeometriesGeometryFactory {
    fn from(value: &NetTopologySuiteGeometriesGeometryFactory) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NetTopologySuiteGeometriesGeometryFactory {
    fn default() -> Self {
        Self {
            coordinate_sequence_factory: Default::default(),
            geometry_services: Default::default(),
            precision_model: Default::default(),
            srid: Default::default(),
        }
    }
}
impl NetTopologySuiteGeometriesGeometryFactory {
    pub fn builder() -> builder::NetTopologySuiteGeometriesGeometryFactory {
        Default::default()
    }
}
///NetTopologySuiteGeometriesGeometryOverlay
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NetTopologySuiteGeometriesGeometryOverlay {}
impl ::std::convert::From<&NetTopologySuiteGeometriesGeometryOverlay>
for NetTopologySuiteGeometriesGeometryOverlay {
    fn from(value: &NetTopologySuiteGeometriesGeometryOverlay) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NetTopologySuiteGeometriesGeometryOverlay {
    fn default() -> Self {
        Self {}
    }
}
impl NetTopologySuiteGeometriesGeometryOverlay {
    pub fn builder() -> builder::NetTopologySuiteGeometriesGeometryOverlay {
        Default::default()
    }
}
///NetTopologySuiteGeometriesLineString
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "area": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "boundary": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "boundaryDimension": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Dimension"
///    },
///    "centroid": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "coordinate": {
///      "readOnly": true,
///      "type": "array",
///      "items": {
///        "type": "number"
///      },
///      "minItems": 2,
///      "example": [
///        10.4,
///        60.5
///      ],
///      "nullable": true
///    },
///    "coordinateSequence": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.CoordinateSequence"
///    },
///    "coordinates": {
///      "readOnly": true,
///      "type": "array",
///      "items": {
///        "type": "array",
///        "items": {
///          "type": "number"
///        },
///        "minItems": 2,
///        "example": [
///          10.4,
///          60.5
///        ]
///      },
///      "nullable": true
///    },
///    "count": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "dimension": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Dimension"
///    },
///    "endPoint": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "envelope": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "envelopeInternal": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Envelope"
///    },
///    "factory": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.GeometryFactory"
///    },
///    "geometryType": {
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "interiorPoint": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "isClosed": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isEmpty": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isRectangle": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isRing": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isSimple": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isValid": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "length": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "numGeometries": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "numPoints": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "ogcGeometryType": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.OgcGeometryType"
///    },
///    "pointOnSurface": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "precisionModel": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.PrecisionModel"
///    },
///    "srid": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "startPoint": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "userData": {
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NetTopologySuiteGeometriesLineString {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub area: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub boundary: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "boundaryDimension",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub boundary_dimension: ::std::option::Option<NetTopologySuiteGeometriesDimension>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub centroid: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub coordinate: ::std::vec::Vec<f64>,
    #[serde(
        rename = "coordinateSequence",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub coordinate_sequence: ::std::option::Option<
        NetTopologySuiteGeometriesCoordinateSequence,
    >,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub coordinates: ::std::vec::Vec<::std::vec::Vec<f64>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dimension: ::std::option::Option<NetTopologySuiteGeometriesDimension>,
    #[serde(
        rename = "endPoint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_point: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub envelope: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "envelopeInternal",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub envelope_internal: ::std::option::Option<NetTopologySuiteGeometriesEnvelope>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub factory: ::std::option::Option<NetTopologySuiteGeometriesGeometryFactory>,
    #[serde(
        rename = "geometryType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub geometry_type: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "interiorPoint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub interior_point: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "isClosed",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_closed: ::std::option::Option<bool>,
    #[serde(
        rename = "isEmpty",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_empty: ::std::option::Option<bool>,
    #[serde(
        rename = "isRectangle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_rectangle: ::std::option::Option<bool>,
    #[serde(
        rename = "isRing",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_ring: ::std::option::Option<bool>,
    #[serde(
        rename = "isSimple",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_simple: ::std::option::Option<bool>,
    #[serde(
        rename = "isValid",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_valid: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub length: ::std::option::Option<f64>,
    #[serde(
        rename = "numGeometries",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub num_geometries: ::std::option::Option<i32>,
    #[serde(
        rename = "numPoints",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub num_points: ::std::option::Option<i32>,
    #[serde(
        rename = "ogcGeometryType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ogc_geometry_type: ::std::option::Option<
        NetTopologySuiteGeometriesOgcGeometryType,
    >,
    #[serde(
        rename = "pointOnSurface",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub point_on_surface: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "precisionModel",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub precision_model: ::std::option::Option<NetTopologySuiteGeometriesPrecisionModel>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub srid: ::std::option::Option<i32>,
    #[serde(
        rename = "startPoint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub start_point: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "userData",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub user_data: ::std::option::Option<::serde_json::Value>,
}
impl ::std::convert::From<&NetTopologySuiteGeometriesLineString>
for NetTopologySuiteGeometriesLineString {
    fn from(value: &NetTopologySuiteGeometriesLineString) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NetTopologySuiteGeometriesLineString {
    fn default() -> Self {
        Self {
            area: Default::default(),
            boundary: Default::default(),
            boundary_dimension: Default::default(),
            centroid: Default::default(),
            coordinate: Default::default(),
            coordinate_sequence: Default::default(),
            coordinates: Default::default(),
            count: Default::default(),
            dimension: Default::default(),
            end_point: Default::default(),
            envelope: Default::default(),
            envelope_internal: Default::default(),
            factory: Default::default(),
            geometry_type: Default::default(),
            interior_point: Default::default(),
            is_closed: Default::default(),
            is_empty: Default::default(),
            is_rectangle: Default::default(),
            is_ring: Default::default(),
            is_simple: Default::default(),
            is_valid: Default::default(),
            length: Default::default(),
            num_geometries: Default::default(),
            num_points: Default::default(),
            ogc_geometry_type: Default::default(),
            point_on_surface: Default::default(),
            precision_model: Default::default(),
            srid: Default::default(),
            start_point: Default::default(),
            user_data: Default::default(),
        }
    }
}
impl NetTopologySuiteGeometriesLineString {
    pub fn builder() -> builder::NetTopologySuiteGeometriesLineString {
        Default::default()
    }
}
///NetTopologySuiteGeometriesLinearRing
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "area": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "boundary": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "boundaryDimension": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Dimension"
///    },
///    "centroid": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "coordinate": {
///      "readOnly": true,
///      "type": "array",
///      "items": {
///        "type": "number"
///      },
///      "minItems": 2,
///      "example": [
///        10.4,
///        60.5
///      ],
///      "nullable": true
///    },
///    "coordinateSequence": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.CoordinateSequence"
///    },
///    "coordinates": {
///      "readOnly": true,
///      "type": "array",
///      "items": {
///        "type": "array",
///        "items": {
///          "type": "number"
///        },
///        "minItems": 2,
///        "example": [
///          10.4,
///          60.5
///        ]
///      },
///      "nullable": true
///    },
///    "count": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "dimension": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Dimension"
///    },
///    "endPoint": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "envelope": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "envelopeInternal": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Envelope"
///    },
///    "factory": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.GeometryFactory"
///    },
///    "geometryType": {
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "interiorPoint": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "isCCW": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isClosed": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isEmpty": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isRectangle": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isRing": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isSimple": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isValid": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "length": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "numGeometries": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "numPoints": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "ogcGeometryType": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.OgcGeometryType"
///    },
///    "pointOnSurface": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "precisionModel": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.PrecisionModel"
///    },
///    "srid": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "startPoint": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "userData": {
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NetTopologySuiteGeometriesLinearRing {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub area: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub boundary: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "boundaryDimension",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub boundary_dimension: ::std::option::Option<NetTopologySuiteGeometriesDimension>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub centroid: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub coordinate: ::std::vec::Vec<f64>,
    #[serde(
        rename = "coordinateSequence",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub coordinate_sequence: ::std::option::Option<
        NetTopologySuiteGeometriesCoordinateSequence,
    >,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub coordinates: ::std::vec::Vec<::std::vec::Vec<f64>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i32>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dimension: ::std::option::Option<NetTopologySuiteGeometriesDimension>,
    #[serde(
        rename = "endPoint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_point: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub envelope: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "envelopeInternal",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub envelope_internal: ::std::option::Option<NetTopologySuiteGeometriesEnvelope>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub factory: ::std::option::Option<NetTopologySuiteGeometriesGeometryFactory>,
    #[serde(
        rename = "geometryType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub geometry_type: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "interiorPoint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub interior_point: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "isCCW",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_ccw: ::std::option::Option<bool>,
    #[serde(
        rename = "isClosed",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_closed: ::std::option::Option<bool>,
    #[serde(
        rename = "isEmpty",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_empty: ::std::option::Option<bool>,
    #[serde(
        rename = "isRectangle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_rectangle: ::std::option::Option<bool>,
    #[serde(
        rename = "isRing",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_ring: ::std::option::Option<bool>,
    #[serde(
        rename = "isSimple",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_simple: ::std::option::Option<bool>,
    #[serde(
        rename = "isValid",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_valid: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub length: ::std::option::Option<f64>,
    #[serde(
        rename = "numGeometries",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub num_geometries: ::std::option::Option<i32>,
    #[serde(
        rename = "numPoints",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub num_points: ::std::option::Option<i32>,
    #[serde(
        rename = "ogcGeometryType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ogc_geometry_type: ::std::option::Option<
        NetTopologySuiteGeometriesOgcGeometryType,
    >,
    #[serde(
        rename = "pointOnSurface",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub point_on_surface: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "precisionModel",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub precision_model: ::std::option::Option<NetTopologySuiteGeometriesPrecisionModel>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub srid: ::std::option::Option<i32>,
    #[serde(
        rename = "startPoint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub start_point: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "userData",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub user_data: ::std::option::Option<::serde_json::Value>,
}
impl ::std::convert::From<&NetTopologySuiteGeometriesLinearRing>
for NetTopologySuiteGeometriesLinearRing {
    fn from(value: &NetTopologySuiteGeometriesLinearRing) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NetTopologySuiteGeometriesLinearRing {
    fn default() -> Self {
        Self {
            area: Default::default(),
            boundary: Default::default(),
            boundary_dimension: Default::default(),
            centroid: Default::default(),
            coordinate: Default::default(),
            coordinate_sequence: Default::default(),
            coordinates: Default::default(),
            count: Default::default(),
            dimension: Default::default(),
            end_point: Default::default(),
            envelope: Default::default(),
            envelope_internal: Default::default(),
            factory: Default::default(),
            geometry_type: Default::default(),
            interior_point: Default::default(),
            is_ccw: Default::default(),
            is_closed: Default::default(),
            is_empty: Default::default(),
            is_rectangle: Default::default(),
            is_ring: Default::default(),
            is_simple: Default::default(),
            is_valid: Default::default(),
            length: Default::default(),
            num_geometries: Default::default(),
            num_points: Default::default(),
            ogc_geometry_type: Default::default(),
            point_on_surface: Default::default(),
            precision_model: Default::default(),
            srid: Default::default(),
            start_point: Default::default(),
            user_data: Default::default(),
        }
    }
}
impl NetTopologySuiteGeometriesLinearRing {
    pub fn builder() -> builder::NetTopologySuiteGeometriesLinearRing {
        Default::default()
    }
}
///NetTopologySuiteGeometriesOgcGeometryType
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "Point",
///    "LineString",
///    "Polygon",
///    "MultiPoint",
///    "MultiLineString",
///    "MultiPolygon",
///    "GeometryCollection",
///    "CircularString",
///    "CompoundCurve",
///    "CurvePolygon",
///    "MultiCurve",
///    "MultiSurface",
///    "Curve",
///    "Surface",
///    "PolyhedralSurface",
///    "TIN"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum NetTopologySuiteGeometriesOgcGeometryType {
    Point,
    LineString,
    Polygon,
    MultiPoint,
    MultiLineString,
    MultiPolygon,
    GeometryCollection,
    CircularString,
    CompoundCurve,
    CurvePolygon,
    MultiCurve,
    MultiSurface,
    Curve,
    Surface,
    PolyhedralSurface,
    #[serde(rename = "TIN")]
    Tin,
}
impl ::std::convert::From<&Self> for NetTopologySuiteGeometriesOgcGeometryType {
    fn from(value: &NetTopologySuiteGeometriesOgcGeometryType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NetTopologySuiteGeometriesOgcGeometryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Point => write!(f, "Point"),
            Self::LineString => write!(f, "LineString"),
            Self::Polygon => write!(f, "Polygon"),
            Self::MultiPoint => write!(f, "MultiPoint"),
            Self::MultiLineString => write!(f, "MultiLineString"),
            Self::MultiPolygon => write!(f, "MultiPolygon"),
            Self::GeometryCollection => write!(f, "GeometryCollection"),
            Self::CircularString => write!(f, "CircularString"),
            Self::CompoundCurve => write!(f, "CompoundCurve"),
            Self::CurvePolygon => write!(f, "CurvePolygon"),
            Self::MultiCurve => write!(f, "MultiCurve"),
            Self::MultiSurface => write!(f, "MultiSurface"),
            Self::Curve => write!(f, "Curve"),
            Self::Surface => write!(f, "Surface"),
            Self::PolyhedralSurface => write!(f, "PolyhedralSurface"),
            Self::Tin => write!(f, "TIN"),
        }
    }
}
impl ::std::str::FromStr for NetTopologySuiteGeometriesOgcGeometryType {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Point" => Ok(Self::Point),
            "LineString" => Ok(Self::LineString),
            "Polygon" => Ok(Self::Polygon),
            "MultiPoint" => Ok(Self::MultiPoint),
            "MultiLineString" => Ok(Self::MultiLineString),
            "MultiPolygon" => Ok(Self::MultiPolygon),
            "GeometryCollection" => Ok(Self::GeometryCollection),
            "CircularString" => Ok(Self::CircularString),
            "CompoundCurve" => Ok(Self::CompoundCurve),
            "CurvePolygon" => Ok(Self::CurvePolygon),
            "MultiCurve" => Ok(Self::MultiCurve),
            "MultiSurface" => Ok(Self::MultiSurface),
            "Curve" => Ok(Self::Curve),
            "Surface" => Ok(Self::Surface),
            "PolyhedralSurface" => Ok(Self::PolyhedralSurface),
            "TIN" => Ok(Self::Tin),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NetTopologySuiteGeometriesOgcGeometryType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for NetTopologySuiteGeometriesOgcGeometryType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for NetTopologySuiteGeometriesOgcGeometryType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///NetTopologySuiteGeometriesOrdinates
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "None",
///    "Spatial1",
///    "Spatial2",
///    "XY",
///    "Spatial3",
///    "XYZ",
///    "Spatial4",
///    "Spatial5",
///    "Spatial6",
///    "Spatial7",
///    "Spatial8",
///    "Spatial9",
///    "Spatial10",
///    "Spatial11",
///    "Spatial12",
///    "Spatial13",
///    "Spatial14",
///    "Spatial15",
///    "Spatial16",
///    "AllSpatialOrdinates",
///    "Measure1",
///    "XYM",
///    "XYZM",
///    "Measure2",
///    "Measure3",
///    "Measure4",
///    "Measure5",
///    "Measure6",
///    "Measure7",
///    "Measure8",
///    "Measure9",
///    "Measure10",
///    "Measure11",
///    "Measure12",
///    "Measure13",
///    "Measure14",
///    "Measure15",
///    "Measure16",
///    "AllMeasureOrdinates",
///    "AllOrdinates"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum NetTopologySuiteGeometriesOrdinates {
    None,
    Spatial1,
    Spatial2,
    #[serde(rename = "XY")]
    Xy,
    Spatial3,
    #[serde(rename = "XYZ")]
    Xyz,
    Spatial4,
    Spatial5,
    Spatial6,
    Spatial7,
    Spatial8,
    Spatial9,
    Spatial10,
    Spatial11,
    Spatial12,
    Spatial13,
    Spatial14,
    Spatial15,
    Spatial16,
    AllSpatialOrdinates,
    Measure1,
    #[serde(rename = "XYM")]
    Xym,
    #[serde(rename = "XYZM")]
    Xyzm,
    Measure2,
    Measure3,
    Measure4,
    Measure5,
    Measure6,
    Measure7,
    Measure8,
    Measure9,
    Measure10,
    Measure11,
    Measure12,
    Measure13,
    Measure14,
    Measure15,
    Measure16,
    AllMeasureOrdinates,
    AllOrdinates,
}
impl ::std::convert::From<&Self> for NetTopologySuiteGeometriesOrdinates {
    fn from(value: &NetTopologySuiteGeometriesOrdinates) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NetTopologySuiteGeometriesOrdinates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "None"),
            Self::Spatial1 => write!(f, "Spatial1"),
            Self::Spatial2 => write!(f, "Spatial2"),
            Self::Xy => write!(f, "XY"),
            Self::Spatial3 => write!(f, "Spatial3"),
            Self::Xyz => write!(f, "XYZ"),
            Self::Spatial4 => write!(f, "Spatial4"),
            Self::Spatial5 => write!(f, "Spatial5"),
            Self::Spatial6 => write!(f, "Spatial6"),
            Self::Spatial7 => write!(f, "Spatial7"),
            Self::Spatial8 => write!(f, "Spatial8"),
            Self::Spatial9 => write!(f, "Spatial9"),
            Self::Spatial10 => write!(f, "Spatial10"),
            Self::Spatial11 => write!(f, "Spatial11"),
            Self::Spatial12 => write!(f, "Spatial12"),
            Self::Spatial13 => write!(f, "Spatial13"),
            Self::Spatial14 => write!(f, "Spatial14"),
            Self::Spatial15 => write!(f, "Spatial15"),
            Self::Spatial16 => write!(f, "Spatial16"),
            Self::AllSpatialOrdinates => write!(f, "AllSpatialOrdinates"),
            Self::Measure1 => write!(f, "Measure1"),
            Self::Xym => write!(f, "XYM"),
            Self::Xyzm => write!(f, "XYZM"),
            Self::Measure2 => write!(f, "Measure2"),
            Self::Measure3 => write!(f, "Measure3"),
            Self::Measure4 => write!(f, "Measure4"),
            Self::Measure5 => write!(f, "Measure5"),
            Self::Measure6 => write!(f, "Measure6"),
            Self::Measure7 => write!(f, "Measure7"),
            Self::Measure8 => write!(f, "Measure8"),
            Self::Measure9 => write!(f, "Measure9"),
            Self::Measure10 => write!(f, "Measure10"),
            Self::Measure11 => write!(f, "Measure11"),
            Self::Measure12 => write!(f, "Measure12"),
            Self::Measure13 => write!(f, "Measure13"),
            Self::Measure14 => write!(f, "Measure14"),
            Self::Measure15 => write!(f, "Measure15"),
            Self::Measure16 => write!(f, "Measure16"),
            Self::AllMeasureOrdinates => write!(f, "AllMeasureOrdinates"),
            Self::AllOrdinates => write!(f, "AllOrdinates"),
        }
    }
}
impl ::std::str::FromStr for NetTopologySuiteGeometriesOrdinates {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "None" => Ok(Self::None),
            "Spatial1" => Ok(Self::Spatial1),
            "Spatial2" => Ok(Self::Spatial2),
            "XY" => Ok(Self::Xy),
            "Spatial3" => Ok(Self::Spatial3),
            "XYZ" => Ok(Self::Xyz),
            "Spatial4" => Ok(Self::Spatial4),
            "Spatial5" => Ok(Self::Spatial5),
            "Spatial6" => Ok(Self::Spatial6),
            "Spatial7" => Ok(Self::Spatial7),
            "Spatial8" => Ok(Self::Spatial8),
            "Spatial9" => Ok(Self::Spatial9),
            "Spatial10" => Ok(Self::Spatial10),
            "Spatial11" => Ok(Self::Spatial11),
            "Spatial12" => Ok(Self::Spatial12),
            "Spatial13" => Ok(Self::Spatial13),
            "Spatial14" => Ok(Self::Spatial14),
            "Spatial15" => Ok(Self::Spatial15),
            "Spatial16" => Ok(Self::Spatial16),
            "AllSpatialOrdinates" => Ok(Self::AllSpatialOrdinates),
            "Measure1" => Ok(Self::Measure1),
            "XYM" => Ok(Self::Xym),
            "XYZM" => Ok(Self::Xyzm),
            "Measure2" => Ok(Self::Measure2),
            "Measure3" => Ok(Self::Measure3),
            "Measure4" => Ok(Self::Measure4),
            "Measure5" => Ok(Self::Measure5),
            "Measure6" => Ok(Self::Measure6),
            "Measure7" => Ok(Self::Measure7),
            "Measure8" => Ok(Self::Measure8),
            "Measure9" => Ok(Self::Measure9),
            "Measure10" => Ok(Self::Measure10),
            "Measure11" => Ok(Self::Measure11),
            "Measure12" => Ok(Self::Measure12),
            "Measure13" => Ok(Self::Measure13),
            "Measure14" => Ok(Self::Measure14),
            "Measure15" => Ok(Self::Measure15),
            "Measure16" => Ok(Self::Measure16),
            "AllMeasureOrdinates" => Ok(Self::AllMeasureOrdinates),
            "AllOrdinates" => Ok(Self::AllOrdinates),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NetTopologySuiteGeometriesOrdinates {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for NetTopologySuiteGeometriesOrdinates {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for NetTopologySuiteGeometriesOrdinates {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///NetTopologySuiteGeometriesPolygon
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "area": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "boundary": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "boundaryDimension": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Dimension"
///    },
///    "centroid": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "coordinate": {
///      "readOnly": true,
///      "type": "array",
///      "items": {
///        "type": "number"
///      },
///      "minItems": 2,
///      "example": [
///        10.4,
///        60.5
///      ],
///      "nullable": true
///    },
///    "coordinates": {
///      "readOnly": true,
///      "type": "array",
///      "items": {
///        "type": "array",
///        "items": {
///          "type": "number"
///        },
///        "minItems": 2,
///        "example": [
///          10.4,
///          60.5
///        ]
///      },
///      "nullable": true
///    },
///    "dimension": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Dimension"
///    },
///    "envelope": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "envelopeInternal": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.Envelope"
///    },
///    "exteriorRing": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.LineString"
///    },
///    "factory": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.GeometryFactory"
///    },
///    "geometryType": {
///      "readOnly": true,
///      "type": "string",
///      "nullable": true
///    },
///    "holes": {
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/NetTopologySuite.Geometries.LinearRing"
///      },
///      "nullable": true
///    },
///    "interiorPoint": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "interiorRings": {
///      "readOnly": true,
///      "type": "array",
///      "items": {
///        "$ref": "#/components/schemas/NetTopologySuite.Geometries.LineString"
///      },
///      "nullable": true
///    },
///    "isEmpty": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isRectangle": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isSimple": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "isValid": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "length": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "numGeometries": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "numInteriorRings": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "numPoints": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "ogcGeometryType": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.OgcGeometryType"
///    },
///    "pointOnSurface": {
///      "title": "GeoJson Geometry",
///      "readOnly": true,
///      "type": "object",
///      "anyOf": [
///        {
///          "title": "GeoJson Point Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "number"
///              },
///              "minItems": 2,
///              "example": [
///                10.4,
///                60.5
///              ]
///            },
///            "type": {
///              "default": "Point",
///              "type": "string",
///              "enum": [
///                "Point"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson LineString Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "number"
///                },
///                "minItems": 2,
///                "example": [
///                  10.4,
///                  60.5
///                ]
///              },
///              "minItems": 2
///            },
///            "type": {
///              "enum": [
///                "LineString"
///              ]
///            }
///          }
///        },
///        {
///          "title": "GeoJson Polygon Geometry",
///          "type": "object",
///          "required": [
///            "coordinates",
///            "type"
///          ],
///          "properties": {
///            "coordinates": {
///              "type": "array",
///              "items": {
///                "type": "array",
///                "items": {
///                  "type": "array",
///                  "items": {
///                    "type": "number"
///                  },
///                  "minItems": 2,
///                  "example": [
///                    10.4,
///                    60.5
///                  ]
///                }
///              },
///              "minItems": 4
///            },
///            "type": {
///              "enum": [
///                "Polygon"
///              ]
///            }
///          }
///        }
///      ],
///      "nullable": true
///    },
///    "precisionModel": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.PrecisionModel"
///    },
///    "shell": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.LinearRing"
///    },
///    "srid": {
///      "type": "integer",
///      "format": "int32"
///    },
///    "userData": {
///      "nullable": true
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NetTopologySuiteGeometriesPolygon {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub area: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub boundary: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "boundaryDimension",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub boundary_dimension: ::std::option::Option<NetTopologySuiteGeometriesDimension>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub centroid: ::std::option::Option<GeoJsonGeometry>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub coordinate: ::std::vec::Vec<f64>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub coordinates: ::std::vec::Vec<::std::vec::Vec<f64>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dimension: ::std::option::Option<NetTopologySuiteGeometriesDimension>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub envelope: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "envelopeInternal",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub envelope_internal: ::std::option::Option<NetTopologySuiteGeometriesEnvelope>,
    #[serde(
        rename = "exteriorRing",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub exterior_ring: ::std::option::Option<NetTopologySuiteGeometriesLineString>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub factory: ::std::option::Option<NetTopologySuiteGeometriesGeometryFactory>,
    #[serde(
        rename = "geometryType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub geometry_type: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub holes: ::std::vec::Vec<NetTopologySuiteGeometriesLinearRing>,
    #[serde(
        rename = "interiorPoint",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub interior_point: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "interiorRings",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub interior_rings: ::std::vec::Vec<NetTopologySuiteGeometriesLineString>,
    #[serde(
        rename = "isEmpty",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_empty: ::std::option::Option<bool>,
    #[serde(
        rename = "isRectangle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_rectangle: ::std::option::Option<bool>,
    #[serde(
        rename = "isSimple",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_simple: ::std::option::Option<bool>,
    #[serde(
        rename = "isValid",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_valid: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub length: ::std::option::Option<f64>,
    #[serde(
        rename = "numGeometries",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub num_geometries: ::std::option::Option<i32>,
    #[serde(
        rename = "numInteriorRings",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub num_interior_rings: ::std::option::Option<i32>,
    #[serde(
        rename = "numPoints",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub num_points: ::std::option::Option<i32>,
    #[serde(
        rename = "ogcGeometryType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ogc_geometry_type: ::std::option::Option<
        NetTopologySuiteGeometriesOgcGeometryType,
    >,
    #[serde(
        rename = "pointOnSurface",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub point_on_surface: ::std::option::Option<GeoJsonGeometry>,
    #[serde(
        rename = "precisionModel",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub precision_model: ::std::option::Option<NetTopologySuiteGeometriesPrecisionModel>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub shell: ::std::option::Option<NetTopologySuiteGeometriesLinearRing>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub srid: ::std::option::Option<i32>,
    #[serde(
        rename = "userData",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub user_data: ::std::option::Option<::serde_json::Value>,
}
impl ::std::convert::From<&NetTopologySuiteGeometriesPolygon>
for NetTopologySuiteGeometriesPolygon {
    fn from(value: &NetTopologySuiteGeometriesPolygon) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NetTopologySuiteGeometriesPolygon {
    fn default() -> Self {
        Self {
            area: Default::default(),
            boundary: Default::default(),
            boundary_dimension: Default::default(),
            centroid: Default::default(),
            coordinate: Default::default(),
            coordinates: Default::default(),
            dimension: Default::default(),
            envelope: Default::default(),
            envelope_internal: Default::default(),
            exterior_ring: Default::default(),
            factory: Default::default(),
            geometry_type: Default::default(),
            holes: Default::default(),
            interior_point: Default::default(),
            interior_rings: Default::default(),
            is_empty: Default::default(),
            is_rectangle: Default::default(),
            is_simple: Default::default(),
            is_valid: Default::default(),
            length: Default::default(),
            num_geometries: Default::default(),
            num_interior_rings: Default::default(),
            num_points: Default::default(),
            ogc_geometry_type: Default::default(),
            point_on_surface: Default::default(),
            precision_model: Default::default(),
            shell: Default::default(),
            srid: Default::default(),
            user_data: Default::default(),
        }
    }
}
impl NetTopologySuiteGeometriesPolygon {
    pub fn builder() -> builder::NetTopologySuiteGeometriesPolygon {
        Default::default()
    }
}
///NetTopologySuiteGeometriesPrecisionModel
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "gridSize": {
///      "readOnly": true,
///      "type": "number",
///      "format": "double"
///    },
///    "isFloating": {
///      "readOnly": true,
///      "type": "boolean"
///    },
///    "maximumSignificantDigits": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "precisionModelType": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.PrecisionModels"
///    },
///    "scale": {
///      "type": "number",
///      "format": "double"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NetTopologySuiteGeometriesPrecisionModel {
    #[serde(
        rename = "gridSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub grid_size: ::std::option::Option<f64>,
    #[serde(
        rename = "isFloating",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub is_floating: ::std::option::Option<bool>,
    #[serde(
        rename = "maximumSignificantDigits",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub maximum_significant_digits: ::std::option::Option<i32>,
    #[serde(
        rename = "precisionModelType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub precision_model_type: ::std::option::Option<
        NetTopologySuiteGeometriesPrecisionModels,
    >,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub scale: ::std::option::Option<f64>,
}
impl ::std::convert::From<&NetTopologySuiteGeometriesPrecisionModel>
for NetTopologySuiteGeometriesPrecisionModel {
    fn from(value: &NetTopologySuiteGeometriesPrecisionModel) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NetTopologySuiteGeometriesPrecisionModel {
    fn default() -> Self {
        Self {
            grid_size: Default::default(),
            is_floating: Default::default(),
            maximum_significant_digits: Default::default(),
            precision_model_type: Default::default(),
            scale: Default::default(),
        }
    }
}
impl NetTopologySuiteGeometriesPrecisionModel {
    pub fn builder() -> builder::NetTopologySuiteGeometriesPrecisionModel {
        Default::default()
    }
}
///NetTopologySuiteGeometriesPrecisionModels
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "string",
///  "enum": [
///    "Floating",
///    "FloatingSingle",
///    "Fixed"
///  ]
///}
/// ```
/// </details>
#[derive(
    ::serde::Deserialize,
    ::serde::Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd
)]
pub enum NetTopologySuiteGeometriesPrecisionModels {
    Floating,
    FloatingSingle,
    Fixed,
}
impl ::std::convert::From<&Self> for NetTopologySuiteGeometriesPrecisionModels {
    fn from(value: &NetTopologySuiteGeometriesPrecisionModels) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NetTopologySuiteGeometriesPrecisionModels {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Floating => write!(f, "Floating"),
            Self::FloatingSingle => write!(f, "FloatingSingle"),
            Self::Fixed => write!(f, "Fixed"),
        }
    }
}
impl ::std::str::FromStr for NetTopologySuiteGeometriesPrecisionModels {
    type Err = self::error::ConversionError;
    fn from_str(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Floating" => Ok(Self::Floating),
            "FloatingSingle" => Ok(Self::FloatingSingle),
            "Fixed" => Ok(Self::Fixed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NetTopologySuiteGeometriesPrecisionModels {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &str,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
for NetTopologySuiteGeometriesPrecisionModels {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
for NetTopologySuiteGeometriesPrecisionModels {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
///NetTopologySuiteNtsGeometryServices
///
/// <details><summary>JSON schema</summary>
///
/// ```json
///{
///  "type": "object",
///  "properties": {
///    "coordinateEqualityComparer": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.CoordinateEqualityComparer"
///    },
///    "defaultCoordinateSequenceFactory": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.CoordinateSequenceFactory"
///    },
///    "defaultPrecisionModel": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.PrecisionModel"
///    },
///    "defaultSRID": {
///      "readOnly": true,
///      "type": "integer",
///      "format": "int32"
///    },
///    "geometryOverlay": {
///      "$ref": "#/components/schemas/NetTopologySuite.Geometries.GeometryOverlay"
///    }
///  },
///  "additionalProperties": false
///}
/// ```
/// </details>
#[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NetTopologySuiteNtsGeometryServices {
    #[serde(
        rename = "coordinateEqualityComparer",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub coordinate_equality_comparer: ::std::option::Option<
        NetTopologySuiteGeometriesCoordinateEqualityComparer,
    >,
    #[serde(
        rename = "defaultCoordinateSequenceFactory",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub default_coordinate_sequence_factory: ::std::option::Option<
        NetTopologySuiteGeometriesCoordinateSequenceFactory,
    >,
    #[serde(
        rename = "defaultPrecisionModel",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub default_precision_model: ::std::option::Option<
        NetTopologySuiteGeometriesPrecisionModel,
    >,
    #[serde(
        rename = "defaultSRID",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub default_srid: ::std::option::Option<i32>,
    #[serde(
        rename = "geometryOverlay",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub geometry_overlay: ::std::option::Option<
        NetTopologySuiteGeometriesGeometryOverlay,
    >,
}
impl ::std::convert::From<&NetTopologySuiteNtsGeometryServices>
for NetTopologySuiteNtsGeometryServices {
    fn from(value: &NetTopologySuiteNtsGeometryServices) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NetTopologySuiteNtsGeometryServices {
    fn default() -> Self {
        Self {
            coordinate_equality_comparer: Default::default(),
            default_coordinate_sequence_factory: Default::default(),
            default_precision_model: Default::default(),
            default_srid: Default::default(),
            geometry_overlay: Default::default(),
        }
    }
}
impl NetTopologySuiteNtsGeometryServices {
    pub fn builder() -> builder::NetTopologySuiteNtsGeometryServices {
        Default::default()
    }
}
/// Types for composing complex structures.
pub mod builder {
    #[derive(Clone, Debug)]
    pub struct BwApiApiAisModelsAisRestPositionDto {
        cog: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        heading: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        lat: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        lon: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        msgt: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        rot: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        sog: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiAisModelsAisRestPositionDto {
        fn default() -> Self {
            Self {
                cog: Ok(Default::default()),
                heading: Ok(Default::default()),
                lat: Ok(Default::default()),
                lon: Ok(Default::default()),
                msgt: Ok(Default::default()),
                rot: Ok(Default::default()),
                sog: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiAisModelsAisRestPositionDto {
        pub fn cog<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.cog = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cog: {}", e));
            self
        }
        pub fn heading<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.heading = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for heading: {}", e)
                });
            self
        }
        pub fn lat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.lat = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lat: {}", e));
            self
        }
        pub fn lon<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.lon = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lon: {}", e));
            self
        }
        pub fn msgt<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.msgt = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for msgt: {}", e));
            self
        }
        pub fn rot<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.rot = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for rot: {}", e));
            self
        }
        pub fn sog<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.sog = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for sog: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiAisModelsAisRestPositionDto>
    for super::BwApiApiAisModelsAisRestPositionDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiAisModelsAisRestPositionDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                cog: value.cog?,
                heading: value.heading?,
                lat: value.lat?,
                lon: value.lon?,
                msgt: value.msgt?,
                rot: value.rot?,
                sog: value.sog?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiAisModelsAisRestPositionDto>
    for BwApiApiAisModelsAisRestPositionDto {
        fn from(value: super::BwApiApiAisModelsAisRestPositionDto) -> Self {
            Self {
                cog: Ok(value.cog),
                heading: Ok(value.heading),
                lat: Ok(value.lat),
                lon: Ok(value.lon),
                msgt: Ok(value.msgt),
                rot: Ok(value.rot),
                sog: Ok(value.sog),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount {
        category: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        count: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount {
        fn default() -> Self {
            Self {
                category: Ok(Default::default()),
                count: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount {
        pub fn category<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.category = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for category: {}", e)
                });
            self
        }
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount,
    > for super::BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                category: value.category?,
                count: value.count?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount,
    > for BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount {
        fn from(
            value: super::BwApiApiAquacultureRegisterModelsAquaCultureSpeciesCategoryCount,
        ) -> Self {
            Self {
                category: Ok(value.category),
                count: Ok(value.count),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto {
        aqua_culture_update_time: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        capacity: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        is_green: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        lat: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        licenses: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiAquacultureRegisterModelsDtoLicenseDto>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        lon: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        municipality: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        municipality_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        organizations: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiAquacultureRegisterModelsDtoOrganizationDto>,
            ::std::string::String,
        >,
        placement: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        production_types: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        purposes: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        species: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        species_list: ::std::result::Result<
            ::std::vec::Vec<::std::string::String>,
            ::std::string::String,
        >,
        unit: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto {
        fn default() -> Self {
            Self {
                aqua_culture_update_time: Ok(Default::default()),
                capacity: Ok(Default::default()),
                is_green: Ok(Default::default()),
                lat: Ok(Default::default()),
                licenses: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                lon: Ok(Default::default()),
                municipality: Ok(Default::default()),
                municipality_no: Ok(Default::default()),
                name: Ok(Default::default()),
                organizations: Ok(Default::default()),
                placement: Ok(Default::default()),
                production_types: Ok(Default::default()),
                purposes: Ok(Default::default()),
                species: Ok(Default::default()),
                species_list: Ok(Default::default()),
                unit: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto {
        pub fn aqua_culture_update_time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.aqua_culture_update_time = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for aqua_culture_update_time: {}",
                        e
                    )
                });
            self
        }
        pub fn capacity<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.capacity = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for capacity: {}", e)
                });
            self
        }
        pub fn is_green<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_green = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_green: {}", e)
                });
            self
        }
        pub fn lat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.lat = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lat: {}", e));
            self
        }
        pub fn licenses<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiAquacultureRegisterModelsDtoLicenseDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.licenses = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for licenses: {}", e)
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn lon<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.lon = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lon: {}", e));
            self
        }
        pub fn municipality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality: {}", e)
                });
            self
        }
        pub fn municipality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality_no: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn organizations<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiAquacultureRegisterModelsDtoOrganizationDto,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.organizations = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for organizations: {}", e)
                });
            self
        }
        pub fn placement<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.placement = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for placement: {}", e)
                });
            self
        }
        pub fn production_types<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.production_types = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for production_types: {}", e
                    )
                });
            self
        }
        pub fn purposes<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.purposes = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for purposes: {}", e)
                });
            self
        }
        pub fn species<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.species = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for species: {}", e)
                });
            self
        }
        pub fn species_list<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.species_list = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for species_list: {}", e)
                });
            self
        }
        pub fn unit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.unit = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for unit: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto,
    > for super::BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                aqua_culture_update_time: value.aqua_culture_update_time?,
                capacity: value.capacity?,
                is_green: value.is_green?,
                lat: value.lat?,
                licenses: value.licenses?,
                locality_no: value.locality_no?,
                lon: value.lon?,
                municipality: value.municipality?,
                municipality_no: value.municipality_no?,
                name: value.name?,
                organizations: value.organizations?,
                placement: value.placement?,
                production_types: value.production_types?,
                purposes: value.purposes?,
                species: value.species?,
                species_list: value.species_list?,
                unit: value.unit?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto,
    > for BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto {
        fn from(
            value: super::BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto,
        ) -> Self {
            Self {
                aqua_culture_update_time: Ok(value.aqua_culture_update_time),
                capacity: Ok(value.capacity),
                is_green: Ok(value.is_green),
                lat: Ok(value.lat),
                licenses: Ok(value.licenses),
                locality_no: Ok(value.locality_no),
                lon: Ok(value.lon),
                municipality: Ok(value.municipality),
                municipality_no: Ok(value.municipality_no),
                name: Ok(value.name),
                organizations: Ok(value.organizations),
                placement: Ok(value.placement),
                production_types: Ok(value.production_types),
                purposes: Ok(value.purposes),
                species: Ok(value.species),
                species_list: Ok(value.species_list),
                unit: Ok(value.unit),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink {
        is_reporting_locality: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        municipality: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink {
        fn default() -> Self {
            Self {
                is_reporting_locality: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                municipality: Ok(Default::default()),
                name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink {
        pub fn is_reporting_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_reporting_locality = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_reporting_locality: {}",
                        e
                    )
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn municipality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink,
    > for super::BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                is_reporting_locality: value.is_reporting_locality?,
                locality_no: value.locality_no?,
                municipality: value.municipality?,
                name: value.name?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink,
    > for BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink {
        fn from(
            value: super::BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink,
        ) -> Self {
            Self {
                is_reporting_locality: Ok(value.is_reporting_locality),
                locality_no: Ok(value.locality_no),
                municipality: Ok(value.municipality),
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiAquacultureRegisterModelsDtoLicenseDto {
        capacity: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        expiration_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        grant_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        is_green: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        license_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        licensee: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        localities: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink,
            >,
            ::std::string::String,
        >,
        production_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        purpose: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        species: ::std::result::Result<
            ::std::vec::Vec<::std::string::String>,
            ::std::string::String,
        >,
        unit: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiAquacultureRegisterModelsDtoLicenseDto {
        fn default() -> Self {
            Self {
                capacity: Ok(Default::default()),
                expiration_date: Ok(Default::default()),
                grant_date: Ok(Default::default()),
                is_green: Ok(Default::default()),
                license_no: Ok(Default::default()),
                licensee: Ok(Default::default()),
                localities: Ok(Default::default()),
                production_type: Ok(Default::default()),
                purpose: Ok(Default::default()),
                species: Ok(Default::default()),
                unit: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiAquacultureRegisterModelsDtoLicenseDto {
        pub fn capacity<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.capacity = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for capacity: {}", e)
                });
            self
        }
        pub fn expiration_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.expiration_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for expiration_date: {}", e)
                });
            self
        }
        pub fn grant_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.grant_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for grant_date: {}", e)
                });
            self
        }
        pub fn is_green<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_green = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_green: {}", e)
                });
            self
        }
        pub fn license_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.license_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for license_no: {}", e)
                });
            self
        }
        pub fn licensee<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.licensee = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for licensee: {}", e)
                });
            self
        }
        pub fn localities<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.localities = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for localities: {}", e)
                });
            self
        }
        pub fn production_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.production_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for production_type: {}", e)
                });
            self
        }
        pub fn purpose<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.purpose = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for purpose: {}", e)
                });
            self
        }
        pub fn species<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.species = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for species: {}", e)
                });
            self
        }
        pub fn unit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.unit = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for unit: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiAquacultureRegisterModelsDtoLicenseDto>
    for super::BwApiApiAquacultureRegisterModelsDtoLicenseDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiAquacultureRegisterModelsDtoLicenseDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                capacity: value.capacity?,
                expiration_date: value.expiration_date?,
                grant_date: value.grant_date?,
                is_green: value.is_green?,
                license_no: value.license_no?,
                licensee: value.licensee?,
                localities: value.localities?,
                production_type: value.production_type?,
                purpose: value.purpose?,
                species: value.species?,
                unit: value.unit?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiAquacultureRegisterModelsDtoLicenseDto>
    for BwApiApiAquacultureRegisterModelsDtoLicenseDto {
        fn from(value: super::BwApiApiAquacultureRegisterModelsDtoLicenseDto) -> Self {
            Self {
                capacity: Ok(value.capacity),
                expiration_date: Ok(value.expiration_date),
                grant_date: Ok(value.grant_date),
                is_green: Ok(value.is_green),
                license_no: Ok(value.license_no),
                licensee: Ok(value.licensee),
                localities: Ok(value.localities),
                production_type: Ok(value.production_type),
                purpose: Ok(value.purpose),
                species: Ok(value.species),
                unit: Ok(value.unit),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiAquacultureRegisterModelsDtoOrganizationDto {
        address: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        city: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        localities: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink,
            >,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        organization_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        postal_code: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiAquacultureRegisterModelsDtoOrganizationDto {
        fn default() -> Self {
            Self {
                address: Ok(Default::default()),
                city: Ok(Default::default()),
                localities: Ok(Default::default()),
                name: Ok(Default::default()),
                organization_no: Ok(Default::default()),
                postal_code: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiAquacultureRegisterModelsDtoOrganizationDto {
        pub fn address<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.address = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for address: {}", e)
                });
            self
        }
        pub fn city<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.city = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for city: {}", e));
            self
        }
        pub fn localities<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiAquacultureRegisterModelsDtoAquacultureLocalityLink,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.localities = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for localities: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn organization_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.organization_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for organization_no: {}", e)
                });
            self
        }
        pub fn postal_code<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.postal_code = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for postal_code: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiAquacultureRegisterModelsDtoOrganizationDto>
    for super::BwApiApiAquacultureRegisterModelsDtoOrganizationDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiAquacultureRegisterModelsDtoOrganizationDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                address: value.address?,
                city: value.city?,
                localities: value.localities?,
                name: value.name?,
                organization_no: value.organization_no?,
                postal_code: value.postal_code?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiAquacultureRegisterModelsDtoOrganizationDto>
    for BwApiApiAquacultureRegisterModelsDtoOrganizationDto {
        fn from(
            value: super::BwApiApiAquacultureRegisterModelsDtoOrganizationDto,
        ) -> Self {
            Self {
                address: Ok(value.address),
                city: Ok(value.city),
                localities: Ok(value.localities),
                name: Ok(value.name),
                organization_no: Ok(value.organization_no),
                postal_code: Ok(value.postal_code),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto {
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        org_no: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto {
        fn default() -> Self {
            Self {
                name: Ok(Default::default()),
                org_no: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto {
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn org_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.org_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for org_no: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto,
    > for super::BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                name: value.name?,
                org_no: value.org_no?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto,
    > for BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto {
        fn from(
            value: super::BwApiApiAquacultureRegisterModelsDtoOrganizationNameIdDto,
        ) -> Self {
            Self {
                name: Ok(value.name),
                org_no: Ok(value.org_no),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiAquacultureRegisterModelsDtoSpecies {
        id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiAquacultureRegisterModelsDtoSpecies {
        fn default() -> Self {
            Self {
                id: Ok(Default::default()),
                name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiAquacultureRegisterModelsDtoSpecies {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiAquacultureRegisterModelsDtoSpecies>
    for super::BwApiApiAquacultureRegisterModelsDtoSpecies {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiAquacultureRegisterModelsDtoSpecies,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                name: value.name?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiAquacultureRegisterModelsDtoSpecies>
    for BwApiApiAquacultureRegisterModelsDtoSpecies {
        fn from(value: super::BwApiApiAquacultureRegisterModelsDtoSpecies) -> Self {
            Self {
                id: Ok(value.id),
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCodSpawningGroundModelsCodSpawningGroundDto {
        area_description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        bmvalue: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        information: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        origin: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        place_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        registered_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        value: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiCodSpawningGroundModelsCodSpawningGroundDto {
        fn default() -> Self {
            Self {
                area_description: Ok(Default::default()),
                bmvalue: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                information: Ok(Default::default()),
                origin: Ok(Default::default()),
                place_name: Ok(Default::default()),
                registered_date: Ok(Default::default()),
                value: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCodSpawningGroundModelsCodSpawningGroundDto {
        pub fn area_description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.area_description = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for area_description: {}", e
                    )
                });
            self
        }
        pub fn bmvalue<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.bmvalue = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for bmvalue: {}", e)
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn information<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.information = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for information: {}", e)
                });
            self
        }
        pub fn origin<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.origin = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for origin: {}", e)
                });
            self
        }
        pub fn place_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.place_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for place_name: {}", e)
                });
            self
        }
        pub fn registered_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.registered_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for registered_date: {}", e)
                });
            self
        }
        pub fn value<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.value = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for value: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiCodSpawningGroundModelsCodSpawningGroundDto>
    for super::BwApiApiCodSpawningGroundModelsCodSpawningGroundDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCodSpawningGroundModelsCodSpawningGroundDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                area_description: value.area_description?,
                bmvalue: value.bmvalue?,
                geometry: value.geometry?,
                id: value.id?,
                information: value.information?,
                origin: value.origin?,
                place_name: value.place_name?,
                registered_date: value.registered_date?,
                value: value.value?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiCodSpawningGroundModelsCodSpawningGroundDto>
    for BwApiApiCodSpawningGroundModelsCodSpawningGroundDto {
        fn from(
            value: super::BwApiApiCodSpawningGroundModelsCodSpawningGroundDto,
        ) -> Self {
            Self {
                area_description: Ok(value.area_description),
                bmvalue: Ok(value.bmvalue),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                information: Ok(value.information),
                origin: Ok(value.origin),
                place_name: Ok(value.place_name),
                registered_date: Ok(value.registered_date),
                value: Ok(value.value),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiControlAreasModelsControlAreaLinkV1 {
        forsk_link: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        forsk_navn: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        forsk_nr: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        from_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        original_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        sist_endret: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        to_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        version: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiControlAreasModelsControlAreaLinkV1 {
        fn default() -> Self {
            Self {
                forsk_link: Ok(Default::default()),
                forsk_navn: Ok(Default::default()),
                forsk_nr: Ok(Default::default()),
                from_date: Ok(Default::default()),
                id: Ok(Default::default()),
                original_date: Ok(Default::default()),
                sist_endret: Ok(Default::default()),
                to_date: Ok(Default::default()),
                version: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiControlAreasModelsControlAreaLinkV1 {
        pub fn forsk_link<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_link = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_link: {}", e)
                });
            self
        }
        pub fn forsk_navn<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_navn = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_navn: {}", e)
                });
            self
        }
        pub fn forsk_nr<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_nr = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_nr: {}", e)
                });
            self
        }
        pub fn from_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_date: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn original_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.original_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for original_date: {}", e)
                });
            self
        }
        pub fn sist_endret<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.sist_endret = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for sist_endret: {}", e)
                });
            self
        }
        pub fn to_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_date: {}", e)
                });
            self
        }
        pub fn version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.version = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for version: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiControlAreasModelsControlAreaLinkV1>
    for super::BwApiApiControlAreasModelsControlAreaLinkV1 {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiControlAreasModelsControlAreaLinkV1,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                forsk_link: value.forsk_link?,
                forsk_navn: value.forsk_navn?,
                forsk_nr: value.forsk_nr?,
                from_date: value.from_date?,
                id: value.id?,
                original_date: value.original_date?,
                sist_endret: value.sist_endret?,
                to_date: value.to_date?,
                version: value.version?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiControlAreasModelsControlAreaLinkV1>
    for BwApiApiControlAreasModelsControlAreaLinkV1 {
        fn from(value: super::BwApiApiControlAreasModelsControlAreaLinkV1) -> Self {
            Self {
                forsk_link: Ok(value.forsk_link),
                forsk_navn: Ok(value.forsk_navn),
                forsk_nr: Ok(value.forsk_nr),
                from_date: Ok(value.from_date),
                id: Ok(value.id),
                original_date: Ok(value.original_date),
                sist_endret: Ok(value.sist_endret),
                to_date: Ok(value.to_date),
                version: Ok(value.version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiControlAreasModelsIlaControlArea {
        forsk_link: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        forsk_navn: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        forsk_nr: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        from_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        original_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        sist_endret: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        to_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        version: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiControlAreasModelsIlaControlArea {
        fn default() -> Self {
            Self {
                forsk_link: Ok(Default::default()),
                forsk_navn: Ok(Default::default()),
                forsk_nr: Ok(Default::default()),
                from_date: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                original_date: Ok(Default::default()),
                sist_endret: Ok(Default::default()),
                to_date: Ok(Default::default()),
                version: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiControlAreasModelsIlaControlArea {
        pub fn forsk_link<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_link = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_link: {}", e)
                });
            self
        }
        pub fn forsk_navn<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_navn = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_navn: {}", e)
                });
            self
        }
        pub fn forsk_nr<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_nr = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_nr: {}", e)
                });
            self
        }
        pub fn from_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_date: {}", e)
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn original_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.original_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for original_date: {}", e)
                });
            self
        }
        pub fn sist_endret<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.sist_endret = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for sist_endret: {}", e)
                });
            self
        }
        pub fn to_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_date: {}", e)
                });
            self
        }
        pub fn version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.version = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for version: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiControlAreasModelsIlaControlArea>
    for super::BwApiApiControlAreasModelsIlaControlArea {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiControlAreasModelsIlaControlArea,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                forsk_link: value.forsk_link?,
                forsk_navn: value.forsk_navn?,
                forsk_nr: value.forsk_nr?,
                from_date: value.from_date?,
                geometry: value.geometry?,
                id: value.id?,
                original_date: value.original_date?,
                sist_endret: value.sist_endret?,
                to_date: value.to_date?,
                version: value.version?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiControlAreasModelsIlaControlArea>
    for BwApiApiControlAreasModelsIlaControlArea {
        fn from(value: super::BwApiApiControlAreasModelsIlaControlArea) -> Self {
            Self {
                forsk_link: Ok(value.forsk_link),
                forsk_navn: Ok(value.forsk_navn),
                forsk_nr: Ok(value.forsk_nr),
                from_date: Ok(value.from_date),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                original_date: Ok(value.original_date),
                sist_endret: Ok(value.sist_endret),
                to_date: Ok(value.to_date),
                version: Ok(value.version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiControlAreasModelsIlaControlAreaDto {
        forsk_link: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        forsk_navn: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        forsk_nr: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        from_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        localities: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsIlaControlAreaLocalityLink>,
            ::std::string::String,
        >,
        original_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        sist_endret: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        to_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiControlAreasModelsIlaControlAreaDto {
        fn default() -> Self {
            Self {
                forsk_link: Ok(Default::default()),
                forsk_navn: Ok(Default::default()),
                forsk_nr: Ok(Default::default()),
                from_date: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                localities: Ok(Default::default()),
                original_date: Ok(Default::default()),
                sist_endret: Ok(Default::default()),
                to_date: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiControlAreasModelsIlaControlAreaDto {
        pub fn forsk_link<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_link = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_link: {}", e)
                });
            self
        }
        pub fn forsk_navn<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_navn = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_navn: {}", e)
                });
            self
        }
        pub fn forsk_nr<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_nr = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_nr: {}", e)
                });
            self
        }
        pub fn from_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_date: {}", e)
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn localities<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiControlAreasModelsIlaControlAreaLocalityLink,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.localities = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for localities: {}", e)
                });
            self
        }
        pub fn original_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.original_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for original_date: {}", e)
                });
            self
        }
        pub fn sist_endret<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.sist_endret = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for sist_endret: {}", e)
                });
            self
        }
        pub fn to_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_date: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiControlAreasModelsIlaControlAreaDto>
    for super::BwApiApiControlAreasModelsIlaControlAreaDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiControlAreasModelsIlaControlAreaDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                forsk_link: value.forsk_link?,
                forsk_navn: value.forsk_navn?,
                forsk_nr: value.forsk_nr?,
                from_date: value.from_date?,
                geometry: value.geometry?,
                id: value.id?,
                localities: value.localities?,
                original_date: value.original_date?,
                sist_endret: value.sist_endret?,
                to_date: value.to_date?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiControlAreasModelsIlaControlAreaDto>
    for BwApiApiControlAreasModelsIlaControlAreaDto {
        fn from(value: super::BwApiApiControlAreasModelsIlaControlAreaDto) -> Self {
            Self {
                forsk_link: Ok(value.forsk_link),
                forsk_navn: Ok(value.forsk_navn),
                forsk_nr: Ok(value.forsk_nr),
                from_date: Ok(value.from_date),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                localities: Ok(value.localities),
                original_date: Ok(value.original_date),
                sist_endret: Ok(value.sist_endret),
                to_date: Ok(value.to_date),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiControlAreasModelsIlaControlAreaLocalityLink {
        ila_confirmed: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        ila_suspected: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_reporting_locality: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        position: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiControlAreasModelsIlaControlAreaLocalityLink {
        fn default() -> Self {
            Self {
                ila_confirmed: Ok(Default::default()),
                ila_suspected: Ok(Default::default()),
                is_reporting_locality: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                name: Ok(Default::default()),
                position: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiControlAreasModelsIlaControlAreaLocalityLink {
        pub fn ila_confirmed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.ila_confirmed = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ila_confirmed: {}", e)
                });
            self
        }
        pub fn ila_suspected<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.ila_suspected = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ila_suspected: {}", e)
                });
            self
        }
        pub fn is_reporting_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_reporting_locality = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_reporting_locality: {}",
                        e
                    )
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn position<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.position = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for position: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiControlAreasModelsIlaControlAreaLocalityLink>
    for super::BwApiApiControlAreasModelsIlaControlAreaLocalityLink {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiControlAreasModelsIlaControlAreaLocalityLink,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                ila_confirmed: value.ila_confirmed?,
                ila_suspected: value.ila_suspected?,
                is_reporting_locality: value.is_reporting_locality?,
                locality_no: value.locality_no?,
                name: value.name?,
                position: value.position?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiControlAreasModelsIlaControlAreaLocalityLink,
    > for BwApiApiControlAreasModelsIlaControlAreaLocalityLink {
        fn from(
            value: super::BwApiApiControlAreasModelsIlaControlAreaLocalityLink,
        ) -> Self {
            Self {
                ila_confirmed: Ok(value.ila_confirmed),
                ila_suspected: Ok(value.ila_suspected),
                is_reporting_locality: Ok(value.is_reporting_locality),
                locality_no: Ok(value.locality_no),
                name: Ok(value.name),
                position: Ok(value.position),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiControlAreasModelsPdControlArea {
        forsk_link: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        forsk_navn: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        forsk_nr: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        from_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        original_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        sist_endret: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        to_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        version: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiControlAreasModelsPdControlArea {
        fn default() -> Self {
            Self {
                forsk_link: Ok(Default::default()),
                forsk_navn: Ok(Default::default()),
                forsk_nr: Ok(Default::default()),
                from_date: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                original_date: Ok(Default::default()),
                sist_endret: Ok(Default::default()),
                to_date: Ok(Default::default()),
                version: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiControlAreasModelsPdControlArea {
        pub fn forsk_link<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_link = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_link: {}", e)
                });
            self
        }
        pub fn forsk_navn<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_navn = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_navn: {}", e)
                });
            self
        }
        pub fn forsk_nr<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_nr = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_nr: {}", e)
                });
            self
        }
        pub fn from_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_date: {}", e)
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn original_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.original_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for original_date: {}", e)
                });
            self
        }
        pub fn sist_endret<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.sist_endret = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for sist_endret: {}", e)
                });
            self
        }
        pub fn to_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_date: {}", e)
                });
            self
        }
        pub fn version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.version = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for version: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiControlAreasModelsPdControlArea>
    for super::BwApiApiControlAreasModelsPdControlArea {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiControlAreasModelsPdControlArea,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                forsk_link: value.forsk_link?,
                forsk_navn: value.forsk_navn?,
                forsk_nr: value.forsk_nr?,
                from_date: value.from_date?,
                geometry: value.geometry?,
                id: value.id?,
                original_date: value.original_date?,
                sist_endret: value.sist_endret?,
                to_date: value.to_date?,
                version: value.version?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiControlAreasModelsPdControlArea>
    for BwApiApiControlAreasModelsPdControlArea {
        fn from(value: super::BwApiApiControlAreasModelsPdControlArea) -> Self {
            Self {
                forsk_link: Ok(value.forsk_link),
                forsk_navn: Ok(value.forsk_navn),
                forsk_nr: Ok(value.forsk_nr),
                from_date: Ok(value.from_date),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                original_date: Ok(value.original_date),
                sist_endret: Ok(value.sist_endret),
                to_date: Ok(value.to_date),
                version: Ok(value.version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiControlAreasModelsPdControlAreaDto {
        forsk_link: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        forsk_navn: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        forsk_nr: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        from_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        localities: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsPdControlAreaLocalityLink>,
            ::std::string::String,
        >,
        original_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        sist_endret: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        to_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiControlAreasModelsPdControlAreaDto {
        fn default() -> Self {
            Self {
                forsk_link: Ok(Default::default()),
                forsk_navn: Ok(Default::default()),
                forsk_nr: Ok(Default::default()),
                from_date: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                localities: Ok(Default::default()),
                original_date: Ok(Default::default()),
                sist_endret: Ok(Default::default()),
                to_date: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiControlAreasModelsPdControlAreaDto {
        pub fn forsk_link<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_link = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_link: {}", e)
                });
            self
        }
        pub fn forsk_navn<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_navn = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_navn: {}", e)
                });
            self
        }
        pub fn forsk_nr<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forsk_nr = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for forsk_nr: {}", e)
                });
            self
        }
        pub fn from_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_date: {}", e)
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn localities<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiControlAreasModelsPdControlAreaLocalityLink,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.localities = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for localities: {}", e)
                });
            self
        }
        pub fn original_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.original_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for original_date: {}", e)
                });
            self
        }
        pub fn sist_endret<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.sist_endret = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for sist_endret: {}", e)
                });
            self
        }
        pub fn to_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_date: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiControlAreasModelsPdControlAreaDto>
    for super::BwApiApiControlAreasModelsPdControlAreaDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiControlAreasModelsPdControlAreaDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                forsk_link: value.forsk_link?,
                forsk_navn: value.forsk_navn?,
                forsk_nr: value.forsk_nr?,
                from_date: value.from_date?,
                geometry: value.geometry?,
                id: value.id?,
                localities: value.localities?,
                original_date: value.original_date?,
                sist_endret: value.sist_endret?,
                to_date: value.to_date?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiControlAreasModelsPdControlAreaDto>
    for BwApiApiControlAreasModelsPdControlAreaDto {
        fn from(value: super::BwApiApiControlAreasModelsPdControlAreaDto) -> Self {
            Self {
                forsk_link: Ok(value.forsk_link),
                forsk_navn: Ok(value.forsk_navn),
                forsk_nr: Ok(value.forsk_nr),
                from_date: Ok(value.from_date),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                localities: Ok(value.localities),
                original_date: Ok(value.original_date),
                sist_endret: Ok(value.sist_endret),
                to_date: Ok(value.to_date),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiControlAreasModelsPdControlAreaLocalityLink {
        is_reporting_locality: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        pd_confirmed: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        pd_suspected: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiControlAreasModelsPdControlAreaLocalityLink {
        fn default() -> Self {
            Self {
                is_reporting_locality: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                name: Ok(Default::default()),
                pd_confirmed: Ok(Default::default()),
                pd_suspected: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiControlAreasModelsPdControlAreaLocalityLink {
        pub fn is_reporting_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_reporting_locality = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_reporting_locality: {}",
                        e
                    )
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn pd_confirmed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.pd_confirmed = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for pd_confirmed: {}", e)
                });
            self
        }
        pub fn pd_suspected<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.pd_suspected = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for pd_suspected: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiControlAreasModelsPdControlAreaLocalityLink>
    for super::BwApiApiControlAreasModelsPdControlAreaLocalityLink {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiControlAreasModelsPdControlAreaLocalityLink,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                is_reporting_locality: value.is_reporting_locality?,
                locality_no: value.locality_no?,
                name: value.name?,
                pd_confirmed: value.pd_confirmed?,
                pd_suspected: value.pd_suspected?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiControlAreasModelsPdControlAreaLocalityLink>
    for BwApiApiControlAreasModelsPdControlAreaLocalityLink {
        fn from(
            value: super::BwApiApiControlAreasModelsPdControlAreaLocalityLink,
        ) -> Self {
            Self {
                is_reporting_locality: Ok(value.is_reporting_locality),
                locality_no: Ok(value.locality_no),
                name: Ok(value.name),
                pd_confirmed: Ok(value.pd_confirmed),
                pd_suspected: Ok(value.pd_suspected),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount {
        count: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        type_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount {
        fn default() -> Self {
            Self {
                count: Ok(Default::default()),
                type_: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount {
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count: {}", e)
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount,
    > for super::BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                count: value.count?,
                type_: value.type_?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount,
    > for BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsEnvironmentalSurveysYearCount,
        ) -> Self {
            Self {
                count: Ok(value.count),
                type_: Ok(value.type_),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount {
        condition: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiCountyAndMunicipalityModelsMomBCondition,
            >,
            ::std::string::String,
        >,
        count: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        municipality_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount {
        fn default() -> Self {
            Self {
                condition: Ok(Default::default()),
                count: Ok(Default::default()),
                municipality_number: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount {
        pub fn condition<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiCountyAndMunicipalityModelsMomBCondition,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.condition = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for condition: {}", e)
                });
            self
        }
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count: {}", e)
                });
            self
        }
        pub fn municipality_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_number = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_number: {}", e
                    )
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount,
    > for super::BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                condition: value.condition?,
                count: value.count?,
                municipality_number: value.municipality_number?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount,
    > for BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMomBYearConditionCount,
        ) -> Self {
            Self {
                condition: Ok(value.condition),
                count: Ok(value.count),
                municipality_number: Ok(value.municipality_number),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityArea {
        alternative_names: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        is_sami_territory: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        name_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        retrieved: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        updated: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalityArea {
        fn default() -> Self {
            Self {
                alternative_names: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                is_sami_territory: Ok(Default::default()),
                name: Ok(Default::default()),
                name_no: Ok(Default::default()),
                number: Ok(Default::default()),
                retrieved: Ok(Default::default()),
                updated: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalityArea {
        pub fn alternative_names<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::collections::HashMap<::std::string::String, ::std::string::String>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.alternative_names = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for alternative_names: {}", e
                    )
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn is_sami_territory<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_sami_territory = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_sami_territory: {}", e
                    )
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn name_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for name_no: {}", e)
                });
            self
        }
        pub fn number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.number = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for number: {}", e)
                });
            self
        }
        pub fn retrieved<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.retrieved = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for retrieved: {}", e)
                });
            self
        }
        pub fn updated<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.updated = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for updated: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiCountyAndMunicipalityModelsMunicipalityArea>
    for super::BwApiApiCountyAndMunicipalityModelsMunicipalityArea {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalityArea,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                alternative_names: value.alternative_names?,
                geometry: value.geometry?,
                id: value.id?,
                is_sami_territory: value.is_sami_territory?,
                name: value.name?,
                name_no: value.name_no?,
                number: value.number?,
                retrieved: value.retrieved?,
                updated: value.updated?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiCountyAndMunicipalityModelsMunicipalityArea>
    for BwApiApiCountyAndMunicipalityModelsMunicipalityArea {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalityArea,
        ) -> Self {
            Self {
                alternative_names: Ok(value.alternative_names),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                is_sami_territory: Ok(value.is_sami_territory),
                name: Ok(value.name),
                name_no: Ok(value.name_no),
                number: Ok(value.number),
                retrieved: Ok(value.retrieved),
                updated: Ok(value.updated),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics {
        capacity: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        municipality_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType,
            >,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics {
        fn default() -> Self {
            Self {
                capacity: Ok(Default::default()),
                municipality_number: Ok(Default::default()),
                type_: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics {
        pub fn capacity<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.capacity = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for capacity: {}", e)
                });
            self
        }
        pub fn municipality_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_number = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_number: {}", e
                    )
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityType,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics,
    > for super::BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                capacity: value.capacity?,
                municipality_number: value.municipality_number?,
                type_: value.type_?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics,
    > for BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalityCapacityStatistics,
        ) -> Self {
            Self {
                capacity: Ok(value.capacity),
                municipality_number: Ok(value.municipality_number),
                type_: Ok(value.type_),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes {
        count: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        municipality_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes {
        fn default() -> Self {
            Self {
                count: Ok(Default::default()),
                municipality_number: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes {
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count: {}", e)
                });
            self
        }
        pub fn municipality_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_number = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_number: {}", e
                    )
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes,
    > for super::BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                count: value.count?,
                municipality_number: value.municipality_number?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes,
    > for BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalityFarmedFishEscapes,
        ) -> Self {
            Self {
                count: Ok(value.count),
                municipality_number: Ok(value.municipality_number),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics {
        cases: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        municipality_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics {
        fn default() -> Self {
            Self {
                cases: Ok(Default::default()),
                municipality_number: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics {
        pub fn cases<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.cases = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for cases: {}", e)
                });
            self
        }
        pub fn municipality_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_number = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_number: {}", e
                    )
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics,
    >
    for super::BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                cases: value.cases?,
                municipality_number: value.municipality_number?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics,
    > for BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalityFishHealthDiseaseStatistics,
        ) -> Self {
            Self {
                cases: Ok(value.cases),
                municipality_number: Ok(value.municipality_number),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics {
        area: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        municipality: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        municipality_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics {
        fn default() -> Self {
            Self {
                area: Ok(Default::default()),
                municipality: Ok(Default::default()),
                municipality_number: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics {
        pub fn area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.area = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for area: {}", e));
            self
        }
        pub fn municipality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality: {}", e)
                });
            self
        }
        pub fn municipality_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_number = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_number: {}", e
                    )
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics,
    > for super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                area: value.area?,
                municipality: value.municipality?,
                municipality_number: value.municipality_number?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics,
    > for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics,
        ) -> Self {
            Self {
                area: Ok(value.area),
                municipality: Ok(value.municipality),
                municipality_number: Ok(value.municipality_number),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary {
        last_updated: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        statistics: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics,
            >,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary {
        fn default() -> Self {
            Self {
                last_updated: Ok(Default::default()),
                statistics: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary {
        pub fn last_updated<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.last_updated = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for last_updated: {}", e)
                });
            self
        }
        pub fn statistics<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatistics,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.statistics = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for statistics: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary,
    >
    for super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                last_updated: value.last_updated?,
                statistics: value.statistics?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary,
    > for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityAreaStatisticsSummary,
        ) -> Self {
            Self {
                last_updated: Ok(value.last_updated),
                statistics: Ok(value.statistics),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics {
        count: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        municipality_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType,
            >,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics {
        fn default() -> Self {
            Self {
                count: Ok(Default::default()),
                municipality_number: Ok(Default::default()),
                type_: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics {
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count: {}", e)
                });
            self
        }
        pub fn municipality_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_number = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_number: {}", e
                    )
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityType,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics,
    > for super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                count: value.count?,
                municipality_number: value.municipality_number?,
                type_: value.type_?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics,
    > for BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalityLocalityStatistics,
        ) -> Self {
            Self {
                count: Ok(value.count),
                municipality_number: Ok(value.municipality_number),
                type_: Ok(value.type_),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization {
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization {
        fn default() -> Self {
            Self {
                name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization {
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization,
    > for super::BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { name: value.name? })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization,
    > for BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalityOrganization,
        ) -> Self {
            Self { name: Ok(value.name) }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage {
        area_used_square_meters: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        municipality_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage {
        fn default() -> Self {
            Self {
                area_used_square_meters: Ok(Default::default()),
                municipality_number: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage {
        pub fn area_used_square_meters<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.area_used_square_meters = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for area_used_square_meters: {}",
                        e
                    )
                });
            self
        }
        pub fn municipality_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_number = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_number: {}", e
                    )
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage,
    > for super::BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                area_used_square_meters: value.area_used_square_meters?,
                municipality_number: value.municipality_number?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage,
    > for BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalityRealAreaUsage,
        ) -> Self {
            Self {
                area_used_square_meters: Ok(value.area_used_square_meters),
                municipality_number: Ok(value.municipality_number),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount {
        catch: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        count: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        species: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount {
        fn default() -> Self {
            Self {
                catch: Ok(Default::default()),
                count: Ok(Default::default()),
                species: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount {
        pub fn catch<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.catch = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for catch: {}", e)
                });
            self
        }
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count: {}", e)
                });
            self
        }
        pub fn species<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.species = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for species: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount,
    > for super::BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                catch: value.catch?,
                count: value.count?,
                species: value.species?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount,
    > for BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalityRiverCatchCount,
        ) -> Self {
            Self {
                catch: Ok(value.catch),
                count: Ok(value.count),
                species: Ok(value.species),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel {
        municipality_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        salmon_lice_report_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        total_report_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel {
        fn default() -> Self {
            Self {
                municipality_number: Ok(Default::default()),
                salmon_lice_report_count: Ok(Default::default()),
                total_report_count: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel {
        pub fn municipality_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_number = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_number: {}", e
                    )
                });
            self
        }
        pub fn salmon_lice_report_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.salmon_lice_report_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for salmon_lice_report_count: {}",
                        e
                    )
                });
            self
        }
        pub fn total_report_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.total_report_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for total_report_count: {}", e
                    )
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel,
    > for super::BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                municipality_number: value.municipality_number?,
                salmon_lice_report_count: value.salmon_lice_report_count?,
                total_report_count: value.total_report_count?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel,
    > for BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalitySalmonLiceReportsModel,
        ) -> Self {
            Self {
                municipality_number: Ok(value.municipality_number),
                salmon_lice_report_count: Ok(value.salmon_lice_report_count),
                total_report_count: Ok(value.total_report_count),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount {
        bath_treatment_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        fresh_water_treatment_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        in_feed_treatment_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        mechanical_removal_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        mechanical_treatment_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        municipality_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        other_medical_treatment_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        other_non_medical_treatment_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        thermal_treatment_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        treatment_year: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount {
        fn default() -> Self {
            Self {
                bath_treatment_count: Ok(Default::default()),
                fresh_water_treatment_count: Ok(Default::default()),
                in_feed_treatment_count: Ok(Default::default()),
                mechanical_removal_count: Ok(Default::default()),
                mechanical_treatment_count: Ok(Default::default()),
                municipality_number: Ok(Default::default()),
                other_medical_treatment_count: Ok(Default::default()),
                other_non_medical_treatment_count: Ok(Default::default()),
                thermal_treatment_count: Ok(Default::default()),
                treatment_year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount {
        pub fn bath_treatment_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.bath_treatment_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for bath_treatment_count: {}", e
                    )
                });
            self
        }
        pub fn fresh_water_treatment_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.fresh_water_treatment_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for fresh_water_treatment_count: {}",
                        e
                    )
                });
            self
        }
        pub fn in_feed_treatment_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.in_feed_treatment_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for in_feed_treatment_count: {}",
                        e
                    )
                });
            self
        }
        pub fn mechanical_removal_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.mechanical_removal_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for mechanical_removal_count: {}",
                        e
                    )
                });
            self
        }
        pub fn mechanical_treatment_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.mechanical_treatment_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for mechanical_treatment_count: {}",
                        e
                    )
                });
            self
        }
        pub fn municipality_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_number = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_number: {}", e
                    )
                });
            self
        }
        pub fn other_medical_treatment_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.other_medical_treatment_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for other_medical_treatment_count: {}",
                        e
                    )
                });
            self
        }
        pub fn other_non_medical_treatment_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.other_non_medical_treatment_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for other_non_medical_treatment_count: {}",
                        e
                    )
                });
            self
        }
        pub fn thermal_treatment_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.thermal_treatment_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for thermal_treatment_count: {}",
                        e
                    )
                });
            self
        }
        pub fn treatment_year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.treatment_year = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for treatment_year: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount,
    > for super::BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                bath_treatment_count: value.bath_treatment_count?,
                fresh_water_treatment_count: value.fresh_water_treatment_count?,
                in_feed_treatment_count: value.in_feed_treatment_count?,
                mechanical_removal_count: value.mechanical_removal_count?,
                mechanical_treatment_count: value.mechanical_treatment_count?,
                municipality_number: value.municipality_number?,
                other_medical_treatment_count: value.other_medical_treatment_count?,
                other_non_medical_treatment_count: value
                    .other_non_medical_treatment_count?,
                thermal_treatment_count: value.thermal_treatment_count?,
                treatment_year: value.treatment_year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount,
    > for BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount {
        fn from(
            value: super::BwApiApiCountyAndMunicipalityModelsMunicipalityTreatmentCount,
        ) -> Self {
            Self {
                bath_treatment_count: Ok(value.bath_treatment_count),
                fresh_water_treatment_count: Ok(value.fresh_water_treatment_count),
                in_feed_treatment_count: Ok(value.in_feed_treatment_count),
                mechanical_removal_count: Ok(value.mechanical_removal_count),
                mechanical_treatment_count: Ok(value.mechanical_treatment_count),
                municipality_number: Ok(value.municipality_number),
                other_medical_treatment_count: Ok(value.other_medical_treatment_count),
                other_non_medical_treatment_count: Ok(
                    value.other_non_medical_treatment_count,
                ),
                thermal_treatment_count: Ok(value.thermal_treatment_count),
                treatment_year: Ok(value.treatment_year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiEscapesModelsEscapesGraphDataDto {
        escapes: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiEscapesModelsEscapesWeekDataDto>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiEscapesModelsEscapesGraphDataDto {
        fn default() -> Self {
            Self {
                escapes: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiEscapesModelsEscapesGraphDataDto {
        pub fn escapes<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiEscapesModelsEscapesWeekDataDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.escapes = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for escapes: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiEscapesModelsEscapesGraphDataDto>
    for super::BwApiApiEscapesModelsEscapesGraphDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiEscapesModelsEscapesGraphDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                escapes: value.escapes?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiEscapesModelsEscapesGraphDataDto>
    for BwApiApiEscapesModelsEscapesGraphDataDto {
        fn from(value: super::BwApiApiEscapesModelsEscapesGraphDataDto) -> Self {
            Self {
                escapes: Ok(value.escapes),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiEscapesModelsEscapesWeekDataDto {
        escape_cases: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiEscapesModelsEscapesWeekDataDto {
        fn default() -> Self {
            Self {
                escape_cases: Ok(Default::default()),
                week: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiEscapesModelsEscapesWeekDataDto {
        pub fn escape_cases<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.escape_cases = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for escape_cases: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiEscapesModelsEscapesWeekDataDto>
    for super::BwApiApiEscapesModelsEscapesWeekDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiEscapesModelsEscapesWeekDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                escape_cases: value.escape_cases?,
                week: value.week?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiEscapesModelsEscapesWeekDataDto>
    for BwApiApiEscapesModelsEscapesWeekDataDto {
        fn from(value: super::BwApiApiEscapesModelsEscapesWeekDataDto) -> Self {
            Self {
                escape_cases: Ok(value.escape_cases),
                week: Ok(value.week),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiExportRestrictionsModelsExportRestrictionAreaLink {
        locality_no: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiExportRestrictionsModelsExportRestrictionAreaLink {
        fn default() -> Self {
            Self {
                locality_no: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiExportRestrictionsModelsExportRestrictionAreaLink {
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiExportRestrictionsModelsExportRestrictionAreaLink,
    > for super::BwApiApiExportRestrictionsModelsExportRestrictionAreaLink {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiExportRestrictionsModelsExportRestrictionAreaLink,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                locality_no: value.locality_no?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiExportRestrictionsModelsExportRestrictionAreaLink,
    > for BwApiApiExportRestrictionsModelsExportRestrictionAreaLink {
        fn from(
            value: super::BwApiApiExportRestrictionsModelsExportRestrictionAreaLink,
        ) -> Self {
            Self {
                locality_no: Ok(value.locality_no),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiExportRestrictionsModelsExportRestrictionDto {
        localities: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsIlaControlAreaLocalityLink>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiExportRestrictionsModelsExportRestrictionDto {
        fn default() -> Self {
            Self {
                localities: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiExportRestrictionsModelsExportRestrictionDto {
        pub fn localities<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiControlAreasModelsIlaControlAreaLocalityLink,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.localities = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for localities: {}", e)
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiExportRestrictionsModelsExportRestrictionDto>
    for super::BwApiApiExportRestrictionsModelsExportRestrictionDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiExportRestrictionsModelsExportRestrictionDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                localities: value.localities?,
                locality_no: value.locality_no?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiExportRestrictionsModelsExportRestrictionDto,
    > for BwApiApiExportRestrictionsModelsExportRestrictionDto {
        fn from(
            value: super::BwApiApiExportRestrictionsModelsExportRestrictionDto,
        ) -> Self {
            Self {
                localities: Ok(value.localities),
                locality_no: Ok(value.locality_no),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFairwaysModelsFairwayDto {
        fairway_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        fairway_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        object_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        place_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        region: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        status: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiFairwaysModelsFairwayDto {
        fn default() -> Self {
            Self {
                fairway_number: Ok(Default::default()),
                fairway_type: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                object_id: Ok(Default::default()),
                place_name: Ok(Default::default()),
                region: Ok(Default::default()),
                status: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFairwaysModelsFairwayDto {
        pub fn fairway_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.fairway_number = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for fairway_number: {}", e)
                });
            self
        }
        pub fn fairway_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.fairway_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for fairway_type: {}", e)
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn object_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.object_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for object_id: {}", e)
                });
            self
        }
        pub fn place_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.place_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for place_name: {}", e)
                });
            self
        }
        pub fn region<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.region = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for region: {}", e)
                });
            self
        }
        pub fn status<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.status = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for status: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFairwaysModelsFairwayDto>
    for super::BwApiApiFairwaysModelsFairwayDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFairwaysModelsFairwayDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                fairway_number: value.fairway_number?,
                fairway_type: value.fairway_type?,
                geometry: value.geometry?,
                id: value.id?,
                object_id: value.object_id?,
                place_name: value.place_name?,
                region: value.region?,
                status: value.status?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiFairwaysModelsFairwayDto>
    for BwApiApiFairwaysModelsFairwayDto {
        fn from(value: super::BwApiApiFairwaysModelsFairwayDto) -> Self {
            Self {
                fairway_number: Ok(value.fairway_number),
                fairway_type: Ok(value.fairway_type),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                object_id: Ok(value.object_id),
                place_name: Ok(value.place_name),
                region: Ok(value.region),
                status: Ok(value.status),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto {
        cleaner_fish: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        comment: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        count: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        count_category: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        count_estimated: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        count_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        county: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        county_code: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        created_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        global_id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        last_edited_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        locality_capacity: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        locality_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        municipality_number: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        object_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        parent_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        recapture_description: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        recapture_started: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        recaptures_completed: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        size: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        size_estimated: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        species: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        status: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        status_locality: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        water_environment: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        water_environment_code: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto {
        fn default() -> Self {
            Self {
                cleaner_fish: Ok(Default::default()),
                comment: Ok(Default::default()),
                count: Ok(Default::default()),
                count_category: Ok(Default::default()),
                count_estimated: Ok(Default::default()),
                count_type: Ok(Default::default()),
                county: Ok(Default::default()),
                county_code: Ok(Default::default()),
                created_date: Ok(Default::default()),
                date: Ok(Default::default()),
                description: Ok(Default::default()),
                global_id: Ok(Default::default()),
                last_edited_date: Ok(Default::default()),
                locality_capacity: Ok(Default::default()),
                locality_name: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                municipality_number: Ok(Default::default()),
                object_id: Ok(Default::default()),
                parent_id: Ok(Default::default()),
                recapture_description: Ok(Default::default()),
                recapture_started: Ok(Default::default()),
                recaptures_completed: Ok(Default::default()),
                size: Ok(Default::default()),
                size_estimated: Ok(Default::default()),
                species: Ok(Default::default()),
                status: Ok(Default::default()),
                status_locality: Ok(Default::default()),
                water_environment: Ok(Default::default()),
                water_environment_code: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto {
        pub fn cleaner_fish<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.cleaner_fish = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for cleaner_fish: {}", e)
                });
            self
        }
        pub fn comment<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.comment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for comment: {}", e)
                });
            self
        }
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count: {}", e)
                });
            self
        }
        pub fn count_category<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.count_category = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count_category: {}", e)
                });
            self
        }
        pub fn count_estimated<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.count_estimated = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count_estimated: {}", e)
                });
            self
        }
        pub fn count_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.count_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count_type: {}", e)
                });
            self
        }
        pub fn county<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.county = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for county: {}", e)
                });
            self
        }
        pub fn county_code<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.county_code = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for county_code: {}", e)
                });
            self
        }
        pub fn created_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.created_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for created_date: {}", e)
                });
            self
        }
        pub fn date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.date = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for date: {}", e));
            self
        }
        pub fn description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.description = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for description: {}", e)
                });
            self
        }
        pub fn global_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.global_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for global_id: {}", e)
                });
            self
        }
        pub fn last_edited_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.last_edited_date = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for last_edited_date: {}", e
                    )
                });
            self
        }
        pub fn locality_capacity<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_capacity = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for locality_capacity: {}", e
                    )
                });
            self
        }
        pub fn locality_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_name: {}", e)
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn municipality_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_number = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_number: {}", e
                    )
                });
            self
        }
        pub fn object_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.object_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for object_id: {}", e)
                });
            self
        }
        pub fn parent_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.parent_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for parent_id: {}", e)
                });
            self
        }
        pub fn recapture_description<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.recapture_description = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for recapture_description: {}",
                        e
                    )
                });
            self
        }
        pub fn recapture_started<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.recapture_started = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for recapture_started: {}", e
                    )
                });
            self
        }
        pub fn recaptures_completed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.recaptures_completed = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for recaptures_completed: {}", e
                    )
                });
            self
        }
        pub fn size<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.size = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for size: {}", e));
            self
        }
        pub fn size_estimated<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.size_estimated = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for size_estimated: {}", e)
                });
            self
        }
        pub fn species<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.species = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for species: {}", e)
                });
            self
        }
        pub fn status<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.status = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for status: {}", e)
                });
            self
        }
        pub fn status_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.status_locality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for status_locality: {}", e)
                });
            self
        }
        pub fn water_environment<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.water_environment = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for water_environment: {}", e
                    )
                });
            self
        }
        pub fn water_environment_code<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.water_environment_code = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for water_environment_code: {}",
                        e
                    )
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>
    for super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                cleaner_fish: value.cleaner_fish?,
                comment: value.comment?,
                count: value.count?,
                count_category: value.count_category?,
                count_estimated: value.count_estimated?,
                count_type: value.count_type?,
                county: value.county?,
                county_code: value.county_code?,
                created_date: value.created_date?,
                date: value.date?,
                description: value.description?,
                global_id: value.global_id?,
                last_edited_date: value.last_edited_date?,
                locality_capacity: value.locality_capacity?,
                locality_name: value.locality_name?,
                locality_no: value.locality_no?,
                municipality_number: value.municipality_number?,
                object_id: value.object_id?,
                parent_id: value.parent_id?,
                recapture_description: value.recapture_description?,
                recapture_started: value.recapture_started?,
                recaptures_completed: value.recaptures_completed?,
                size: value.size?,
                size_estimated: value.size_estimated?,
                species: value.species?,
                status: value.status?,
                status_locality: value.status_locality?,
                water_environment: value.water_environment?,
                water_environment_code: value.water_environment_code?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>
    for BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto {
        fn from(
            value: super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto,
        ) -> Self {
            Self {
                cleaner_fish: Ok(value.cleaner_fish),
                comment: Ok(value.comment),
                count: Ok(value.count),
                count_category: Ok(value.count_category),
                count_estimated: Ok(value.count_estimated),
                count_type: Ok(value.count_type),
                county: Ok(value.county),
                county_code: Ok(value.county_code),
                created_date: Ok(value.created_date),
                date: Ok(value.date),
                description: Ok(value.description),
                global_id: Ok(value.global_id),
                last_edited_date: Ok(value.last_edited_date),
                locality_capacity: Ok(value.locality_capacity),
                locality_name: Ok(value.locality_name),
                locality_no: Ok(value.locality_no),
                municipality_number: Ok(value.municipality_number),
                object_id: Ok(value.object_id),
                parent_id: Ok(value.parent_id),
                recapture_description: Ok(value.recapture_description),
                recapture_started: Ok(value.recapture_started),
                recaptures_completed: Ok(value.recaptures_completed),
                size: Ok(value.size),
                size_estimated: Ok(value.size_estimated),
                species: Ok(value.species),
                status: Ok(value.status),
                status_locality: Ok(value.status_locality),
                water_environment: Ok(value.water_environment),
                water_environment_code: Ok(value.water_environment_code),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto {
        escapes: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto {
        fn default() -> Self {
            Self {
                escapes: Ok(Default::default()),
                week: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto {
        pub fn escapes<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.escapes = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for escapes: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto>
    for super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                escapes: value.escapes?,
                week: value.week?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto,
    > for BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto {
        fn from(
            value: super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto,
        ) -> Self {
            Self {
                escapes: Ok(value.escapes),
                week: Ok(value.week),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto {
        data: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto,
            >,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto {
        fn default() -> Self {
            Self {
                data: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto {
        pub fn data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeWeekDto,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.data = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for data: {}", e));
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto,
    > for super::BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                data: value.data?,
                locality_no: value.locality_no?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto,
    > for BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto {
        fn from(
            value: super::BwApiApiFarmedFishEscapeModelsLocalityEscapesGraphDataDto,
        ) -> Self {
            Self {
                data: Ok(value.data),
                locality_no: Ok(value.locality_no),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory {
        export_restrictions: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiExportRestrictionsModelsExportRestrictionAreaLink,
            >,
            ::std::string::String,
        >,
        ila_protection_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsControlAreaLinkV1>,
            ::std::string::String,
        >,
        ila_surveilanze_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsControlAreaLinkV1>,
            ::std::string::String,
        >,
        pd_protection_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsControlAreaLinkV1>,
            ::std::string::String,
        >,
        pd_surveilanze_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsControlAreaLinkV1>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory {
        fn default() -> Self {
            Self {
                export_restrictions: Ok(Default::default()),
                ila_protection_zones: Ok(Default::default()),
                ila_surveilanze_zones: Ok(Default::default()),
                pd_protection_zones: Ok(Default::default()),
                pd_surveilanze_zones: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory {
        pub fn export_restrictions<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiExportRestrictionsModelsExportRestrictionAreaLink,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.export_restrictions = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for export_restrictions: {}", e
                    )
                });
            self
        }
        pub fn ila_protection_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsControlAreaLinkV1>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ila_protection_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ila_protection_zones: {}", e
                    )
                });
            self
        }
        pub fn ila_surveilanze_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsControlAreaLinkV1>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ila_surveilanze_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ila_surveilanze_zones: {}",
                        e
                    )
                });
            self
        }
        pub fn pd_protection_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsControlAreaLinkV1>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.pd_protection_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for pd_protection_zones: {}", e
                    )
                });
            self
        }
        pub fn pd_surveilanze_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsControlAreaLinkV1>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.pd_surveilanze_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for pd_surveilanze_zones: {}", e
                    )
                });
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory,
    > for super::BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                export_restrictions: value.export_restrictions?,
                ila_protection_zones: value.ila_protection_zones?,
                ila_surveilanze_zones: value.ila_surveilanze_zones?,
                pd_protection_zones: value.pd_protection_zones?,
                pd_surveilanze_zones: value.pd_surveilanze_zones?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory,
    > for BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory {
        fn from(
            value: super::BwApiApiFishhealthDiseaseHistoryModelsDiseaseZoneHistory,
        ) -> Self {
            Self {
                export_restrictions: Ok(value.export_restrictions),
                ila_protection_zones: Ok(value.ila_protection_zones),
                ila_surveilanze_zones: Ok(value.ila_surveilanze_zones),
                pd_protection_zones: Ok(value.pd_protection_zones),
                pd_surveilanze_zones: Ok(value.pd_surveilanze_zones),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthDownloadModelsLocalityWeekExportDto {
        above_lice_limit: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        avg_adult_female_lice_rounded: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        avg_mobile_lice_rounded: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        avg_stationary_lice_rounded: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        county: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        county_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        fallow_string: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        has_reported_lice_string: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        lat: ::std::result::Result<::std::option::Option<f32>, ::std::string::String>,
        lice_limit: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        locality_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        lon: ::std::result::Result<::std::option::Option<f32>, ::std::string::String>,
        municipality: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        municipality_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        production_area_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        production_area_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        sea_temperature_rounded: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthDownloadModelsLocalityWeekExportDto {
        fn default() -> Self {
            Self {
                above_lice_limit: Ok(Default::default()),
                avg_adult_female_lice_rounded: Ok(Default::default()),
                avg_mobile_lice_rounded: Ok(Default::default()),
                avg_stationary_lice_rounded: Ok(Default::default()),
                county: Ok(Default::default()),
                county_number: Ok(Default::default()),
                fallow_string: Ok(Default::default()),
                has_reported_lice_string: Ok(Default::default()),
                lat: Ok(Default::default()),
                lice_limit: Ok(Default::default()),
                locality_name: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                lon: Ok(Default::default()),
                municipality: Ok(Default::default()),
                municipality_no: Ok(Default::default()),
                production_area_id: Ok(Default::default()),
                production_area_name: Ok(Default::default()),
                sea_temperature_rounded: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthDownloadModelsLocalityWeekExportDto {
        pub fn above_lice_limit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.above_lice_limit = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for above_lice_limit: {}", e
                    )
                });
            self
        }
        pub fn avg_adult_female_lice_rounded<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_adult_female_lice_rounded = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for avg_adult_female_lice_rounded: {}",
                        e
                    )
                });
            self
        }
        pub fn avg_mobile_lice_rounded<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_mobile_lice_rounded = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for avg_mobile_lice_rounded: {}",
                        e
                    )
                });
            self
        }
        pub fn avg_stationary_lice_rounded<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_stationary_lice_rounded = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for avg_stationary_lice_rounded: {}",
                        e
                    )
                });
            self
        }
        pub fn county<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.county = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for county: {}", e)
                });
            self
        }
        pub fn county_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.county_number = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for county_number: {}", e)
                });
            self
        }
        pub fn fallow_string<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.fallow_string = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for fallow_string: {}", e)
                });
            self
        }
        pub fn has_reported_lice_string<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_reported_lice_string = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_reported_lice_string: {}",
                        e
                    )
                });
            self
        }
        pub fn lat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.lat = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lat: {}", e));
            self
        }
        pub fn lice_limit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.lice_limit = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for lice_limit: {}", e)
                });
            self
        }
        pub fn locality_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_name: {}", e)
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn lon<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.lon = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lon: {}", e));
            self
        }
        pub fn municipality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality: {}", e)
                });
            self
        }
        pub fn municipality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality_no: {}", e)
                });
            self
        }
        pub fn production_area_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.production_area_id = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for production_area_id: {}", e
                    )
                });
            self
        }
        pub fn production_area_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.production_area_name = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for production_area_name: {}", e
                    )
                });
            self
        }
        pub fn sea_temperature_rounded<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.sea_temperature_rounded = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for sea_temperature_rounded: {}",
                        e
                    )
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthDownloadModelsLocalityWeekExportDto>
    for super::BwApiApiFishhealthDownloadModelsLocalityWeekExportDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthDownloadModelsLocalityWeekExportDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                above_lice_limit: value.above_lice_limit?,
                avg_adult_female_lice_rounded: value.avg_adult_female_lice_rounded?,
                avg_mobile_lice_rounded: value.avg_mobile_lice_rounded?,
                avg_stationary_lice_rounded: value.avg_stationary_lice_rounded?,
                county: value.county?,
                county_number: value.county_number?,
                fallow_string: value.fallow_string?,
                has_reported_lice_string: value.has_reported_lice_string?,
                lat: value.lat?,
                lice_limit: value.lice_limit?,
                locality_name: value.locality_name?,
                locality_no: value.locality_no?,
                lon: value.lon?,
                municipality: value.municipality?,
                municipality_no: value.municipality_no?,
                production_area_id: value.production_area_id?,
                production_area_name: value.production_area_name?,
                sea_temperature_rounded: value.sea_temperature_rounded?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthDownloadModelsLocalityWeekExportDto,
    > for BwApiApiFishhealthDownloadModelsLocalityWeekExportDto {
        fn from(
            value: super::BwApiApiFishhealthDownloadModelsLocalityWeekExportDto,
        ) -> Self {
            Self {
                above_lice_limit: Ok(value.above_lice_limit),
                avg_adult_female_lice_rounded: Ok(value.avg_adult_female_lice_rounded),
                avg_mobile_lice_rounded: Ok(value.avg_mobile_lice_rounded),
                avg_stationary_lice_rounded: Ok(value.avg_stationary_lice_rounded),
                county: Ok(value.county),
                county_number: Ok(value.county_number),
                fallow_string: Ok(value.fallow_string),
                has_reported_lice_string: Ok(value.has_reported_lice_string),
                lat: Ok(value.lat),
                lice_limit: Ok(value.lice_limit),
                locality_name: Ok(value.locality_name),
                locality_no: Ok(value.locality_no),
                lon: Ok(value.lon),
                municipality: Ok(value.municipality),
                municipality_no: Ok(value.municipality_no),
                production_area_id: Ok(value.production_area_id),
                production_area_name: Ok(value.production_area_name),
                sea_temperature_rounded: Ok(value.sea_temperature_rounded),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto {
        avsluttetdato: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        county: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        county_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        disease: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        disease_sub_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        from_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        lat: ::std::result::Result<::std::option::Option<f32>, ::std::string::String>,
        locality_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        lon: ::std::result::Result<::std::option::Option<f32>, ::std::string::String>,
        mistankedato: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        municipality: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        municipality_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        paavistdato: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        production_area_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        production_area_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ruling: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        to_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        tomtdato: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        utbrudds_id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto {
        fn default() -> Self {
            Self {
                avsluttetdato: Ok(Default::default()),
                county: Ok(Default::default()),
                county_number: Ok(Default::default()),
                disease: Ok(Default::default()),
                disease_sub_type: Ok(Default::default()),
                from_date: Ok(Default::default()),
                lat: Ok(Default::default()),
                locality_name: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                lon: Ok(Default::default()),
                mistankedato: Ok(Default::default()),
                municipality: Ok(Default::default()),
                municipality_no: Ok(Default::default()),
                paavistdato: Ok(Default::default()),
                production_area_id: Ok(Default::default()),
                production_area_name: Ok(Default::default()),
                ruling: Ok(Default::default()),
                to_date: Ok(Default::default()),
                tomtdato: Ok(Default::default()),
                utbrudds_id: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto {
        pub fn avsluttetdato<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.avsluttetdato = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for avsluttetdato: {}", e)
                });
            self
        }
        pub fn county<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.county = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for county: {}", e)
                });
            self
        }
        pub fn county_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.county_number = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for county_number: {}", e)
                });
            self
        }
        pub fn disease<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.disease = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disease: {}", e)
                });
            self
        }
        pub fn disease_sub_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.disease_sub_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for disease_sub_type: {}", e
                    )
                });
            self
        }
        pub fn from_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_date: {}", e)
                });
            self
        }
        pub fn lat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.lat = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lat: {}", e));
            self
        }
        pub fn locality_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_name: {}", e)
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn lon<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.lon = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lon: {}", e));
            self
        }
        pub fn mistankedato<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.mistankedato = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for mistankedato: {}", e)
                });
            self
        }
        pub fn municipality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality: {}", e)
                });
            self
        }
        pub fn municipality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality_no: {}", e)
                });
            self
        }
        pub fn paavistdato<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.paavistdato = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for paavistdato: {}", e)
                });
            self
        }
        pub fn production_area_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.production_area_id = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for production_area_id: {}", e
                    )
                });
            self
        }
        pub fn production_area_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.production_area_name = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for production_area_name: {}", e
                    )
                });
            self
        }
        pub fn ruling<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ruling = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ruling: {}", e)
                });
            self
        }
        pub fn to_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_date: {}", e)
                });
            self
        }
        pub fn tomtdato<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.tomtdato = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for tomtdato: {}", e)
                });
            self
        }
        pub fn utbrudds_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.utbrudds_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for utbrudds_id: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto,
    > for super::BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                avsluttetdato: value.avsluttetdato?,
                county: value.county?,
                county_number: value.county_number?,
                disease: value.disease?,
                disease_sub_type: value.disease_sub_type?,
                from_date: value.from_date?,
                lat: value.lat?,
                locality_name: value.locality_name?,
                locality_no: value.locality_no?,
                lon: value.lon?,
                mistankedato: value.mistankedato?,
                municipality: value.municipality?,
                municipality_no: value.municipality_no?,
                paavistdato: value.paavistdato?,
                production_area_id: value.production_area_id?,
                production_area_name: value.production_area_name?,
                ruling: value.ruling?,
                to_date: value.to_date?,
                tomtdato: value.tomtdato?,
                utbrudds_id: value.utbrudds_id?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto,
    > for BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto {
        fn from(
            value: super::BwApiApiFishhealthDownloadModelsLocalityWeekIlaPdExportDto,
        ) -> Self {
            Self {
                avsluttetdato: Ok(value.avsluttetdato),
                county: Ok(value.county),
                county_number: Ok(value.county_number),
                disease: Ok(value.disease),
                disease_sub_type: Ok(value.disease_sub_type),
                from_date: Ok(value.from_date),
                lat: Ok(value.lat),
                locality_name: Ok(value.locality_name),
                locality_no: Ok(value.locality_no),
                lon: Ok(value.lon),
                mistankedato: Ok(value.mistankedato),
                municipality: Ok(value.municipality),
                municipality_no: Ok(value.municipality_no),
                paavistdato: Ok(value.paavistdato),
                production_area_id: Ok(value.production_area_id),
                production_area_name: Ok(value.production_area_name),
                ruling: Ok(value.ruling),
                to_date: Ok(value.to_date),
                tomtdato: Ok(value.tomtdato),
                utbrudds_id: Ok(value.utbrudds_id),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthDownloadModelsTreatmentsExportDto {
        county: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        county_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        lat: ::std::result::Result<::std::option::Option<f32>, ::std::string::String>,
        locality_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        lon: ::std::result::Result<::std::option::Option<f32>, ::std::string::String>,
        municipality: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        municipality_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        number_of_cages: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        production_area_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        production_area_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        quantity: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        species: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        species_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        substance: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        treatment_scope: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        treatment_sub_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        treatment_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthDownloadModelsTreatmentsExportDto {
        fn default() -> Self {
            Self {
                county: Ok(Default::default()),
                county_number: Ok(Default::default()),
                lat: Ok(Default::default()),
                locality_name: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                lon: Ok(Default::default()),
                municipality: Ok(Default::default()),
                municipality_no: Ok(Default::default()),
                number_of_cages: Ok(Default::default()),
                production_area_id: Ok(Default::default()),
                production_area_name: Ok(Default::default()),
                quantity: Ok(Default::default()),
                species: Ok(Default::default()),
                species_id: Ok(Default::default()),
                substance: Ok(Default::default()),
                treatment_scope: Ok(Default::default()),
                treatment_sub_type: Ok(Default::default()),
                treatment_type: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthDownloadModelsTreatmentsExportDto {
        pub fn county<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.county = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for county: {}", e)
                });
            self
        }
        pub fn county_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.county_number = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for county_number: {}", e)
                });
            self
        }
        pub fn lat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.lat = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lat: {}", e));
            self
        }
        pub fn locality_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_name: {}", e)
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn lon<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.lon = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lon: {}", e));
            self
        }
        pub fn municipality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality: {}", e)
                });
            self
        }
        pub fn municipality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality_no: {}", e)
                });
            self
        }
        pub fn number_of_cages<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_cages = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for number_of_cages: {}", e)
                });
            self
        }
        pub fn production_area_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.production_area_id = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for production_area_id: {}", e
                    )
                });
            self
        }
        pub fn production_area_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.production_area_name = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for production_area_name: {}", e
                    )
                });
            self
        }
        pub fn quantity<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.quantity = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for quantity: {}", e)
                });
            self
        }
        pub fn species<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.species = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for species: {}", e)
                });
            self
        }
        pub fn species_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.species_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for species_id: {}", e)
                });
            self
        }
        pub fn substance<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.substance = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for substance: {}", e)
                });
            self
        }
        pub fn treatment_scope<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.treatment_scope = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for treatment_scope: {}", e)
                });
            self
        }
        pub fn treatment_sub_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.treatment_sub_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for treatment_sub_type: {}", e
                    )
                });
            self
        }
        pub fn treatment_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.treatment_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for treatment_type: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthDownloadModelsTreatmentsExportDto>
    for super::BwApiApiFishhealthDownloadModelsTreatmentsExportDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthDownloadModelsTreatmentsExportDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                county: value.county?,
                county_number: value.county_number?,
                lat: value.lat?,
                locality_name: value.locality_name?,
                locality_no: value.locality_no?,
                lon: value.lon?,
                municipality: value.municipality?,
                municipality_no: value.municipality_no?,
                number_of_cages: value.number_of_cages?,
                production_area_id: value.production_area_id?,
                production_area_name: value.production_area_name?,
                quantity: value.quantity?,
                species: value.species?,
                species_id: value.species_id?,
                substance: value.substance?,
                treatment_scope: value.treatment_scope?,
                treatment_sub_type: value.treatment_sub_type?,
                treatment_type: value.treatment_type?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiFishhealthDownloadModelsTreatmentsExportDto>
    for BwApiApiFishhealthDownloadModelsTreatmentsExportDto {
        fn from(
            value: super::BwApiApiFishhealthDownloadModelsTreatmentsExportDto,
        ) -> Self {
            Self {
                county: Ok(value.county),
                county_number: Ok(value.county_number),
                lat: Ok(value.lat),
                locality_name: Ok(value.locality_name),
                locality_no: Ok(value.locality_no),
                lon: Ok(value.lon),
                municipality: Ok(value.municipality),
                municipality_no: Ok(value.municipality_no),
                number_of_cages: Ok(value.number_of_cages),
                production_area_id: Ok(value.production_area_id),
                production_area_name: Ok(value.production_area_name),
                quantity: Ok(value.quantity),
                species: Ok(value.species),
                species_id: Ok(value.species_id),
                substance: Ok(value.substance),
                treatment_scope: Ok(value.treatment_scope),
                treatment_sub_type: Ok(value.treatment_sub_type),
                treatment_type: Ok(value.treatment_type),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto {
        data: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek,
            >,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto {
        fn default() -> Self {
            Self {
                data: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto {
        pub fn data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.data = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for data: {}", e));
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto,
    > for super::BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                data: value.data?,
                locality_no: value.locality_no?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto,
    > for BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsAllTreatmentsGraphDataDto,
        ) -> Self {
            Self {
                data: Ok(value.data),
                locality_no: Ok(value.locality_no),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail {
        case_detail: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiIlaPdCasesModelsIlaPdCaseDetail>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail {
        fn default() -> Self {
            Self {
                case_detail: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail {
        pub fn case_detail<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiIlaPdCasesModelsIlaPdCaseDetail>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.case_detail = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for case_detail: {}", e)
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail>
    for super::BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                case_detail: value.case_detail?,
                locality_no: value.locality_no?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail,
    > for BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsAnnualDiseaseCaseDetail,
        ) -> Self {
            Self {
                case_detail: Ok(value.case_detail),
                locality_no: Ok(value.locality_no),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto {
        data: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiFishhealthLocalityModelsDiseasePeriodDto>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto {
        fn default() -> Self {
            Self {
                data: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto {
        pub fn data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiFishhealthLocalityModelsDiseasePeriodDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.data = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for data: {}", e));
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto>
    for super::BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                data: value.data?,
                locality_no: value.locality_no?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto,
    > for BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsAnnualDiseaseDataDto,
        ) -> Self {
            Self {
                data: Ok(value.data),
                locality_no: Ok(value.locality_no),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsCleanerFishTreatment {
        entire_locality: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        quantity: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsCleanerFishTreatment {
        fn default() -> Self {
            Self {
                entire_locality: Ok(Default::default()),
                name: Ok(Default::default()),
                quantity: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsCleanerFishTreatment {
        pub fn entire_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.entire_locality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for entire_locality: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn quantity<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.quantity = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for quantity: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsCleanerFishTreatment>
    for super::BwApiApiFishhealthLocalityModelsCleanerFishTreatment {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsCleanerFishTreatment,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                entire_locality: value.entire_locality?,
                name: value.name?,
                quantity: value.quantity?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsCleanerFishTreatment,
    > for BwApiApiFishhealthLocalityModelsCleanerFishTreatment {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsCleanerFishTreatment,
        ) -> Self {
            Self {
                entire_locality: Ok(value.entire_locality),
                name: Ok(value.name),
                quantity: Ok(value.quantity),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsDiseaseCount {
        confirmed: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        suspected: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiFishhealthLocalityModelsDiseaseCount {
        fn default() -> Self {
            Self {
                confirmed: Ok(Default::default()),
                suspected: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsDiseaseCount {
        pub fn confirmed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.confirmed = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for confirmed: {}", e)
                });
            self
        }
        pub fn suspected<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.suspected = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for suspected: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsDiseaseCount>
    for super::BwApiApiFishhealthLocalityModelsDiseaseCount {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsDiseaseCount,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                confirmed: value.confirmed?,
                suspected: value.suspected?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiFishhealthLocalityModelsDiseaseCount>
    for BwApiApiFishhealthLocalityModelsDiseaseCount {
        fn from(value: super::BwApiApiFishhealthLocalityModelsDiseaseCount) -> Self {
            Self {
                confirmed: Ok(value.confirmed),
                suspected: Ok(value.suspected),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsDiseasePeriodDto {
        disease: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        end_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        end_week: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        ruling: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        start_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        start_week: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiFishhealthLocalityModelsDiseasePeriodDto {
        fn default() -> Self {
            Self {
                disease: Ok(Default::default()),
                end_date: Ok(Default::default()),
                end_week: Ok(Default::default()),
                ruling: Ok(Default::default()),
                start_date: Ok(Default::default()),
                start_week: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsDiseasePeriodDto {
        pub fn disease<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.disease = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disease: {}", e)
                });
            self
        }
        pub fn end_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.end_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for end_date: {}", e)
                });
            self
        }
        pub fn end_week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.end_week = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for end_week: {}", e)
                });
            self
        }
        pub fn ruling<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ruling = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ruling: {}", e)
                });
            self
        }
        pub fn start_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.start_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for start_date: {}", e)
                });
            self
        }
        pub fn start_week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.start_week = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for start_week: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsDiseasePeriodDto>
    for super::BwApiApiFishhealthLocalityModelsDiseasePeriodDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsDiseasePeriodDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                disease: value.disease?,
                end_date: value.end_date?,
                end_week: value.end_week?,
                ruling: value.ruling?,
                start_date: value.start_date?,
                start_week: value.start_week?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiFishhealthLocalityModelsDiseasePeriodDto>
    for BwApiApiFishhealthLocalityModelsDiseasePeriodDto {
        fn from(value: super::BwApiApiFishhealthLocalityModelsDiseasePeriodDto) -> Self {
            Self {
                disease: Ok(value.disease),
                end_date: Ok(value.end_date),
                end_week: Ok(value.end_week),
                ruling: Ok(value.ruling),
                start_date: Ok(value.start_date),
                start_week: Ok(value.start_week),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek {
        above_limit_locality_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek {
        fn default() -> Self {
            Self {
                above_limit_locality_count: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek {
        pub fn above_limit_locality_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.above_limit_locality_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for above_limit_locality_count: {}",
                        e
                    )
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek,
    > for super::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                above_limit_locality_count: value.above_limit_locality_count?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek,
    > for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByWeek,
        ) -> Self {
            Self {
                above_limit_locality_count: Ok(value.above_limit_locality_count),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear {
        average_proportion_of_localities_over_limit: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        weighted_average_localities_over_limit: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear {
        fn default() -> Self {
            Self {
                average_proportion_of_localities_over_limit: Ok(Default::default()),
                weighted_average_localities_over_limit: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear {
        pub fn average_proportion_of_localities_over_limit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.average_proportion_of_localities_over_limit = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for average_proportion_of_localities_over_limit: {}",
                        e
                    )
                });
            self
        }
        pub fn weighted_average_localities_over_limit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.weighted_average_localities_over_limit = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for weighted_average_localities_over_limit: {}",
                        e
                    )
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear,
    > for super::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                average_proportion_of_localities_over_limit: value
                    .average_proportion_of_localities_over_limit?,
                weighted_average_localities_over_limit: value
                    .weighted_average_localities_over_limit?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear,
    > for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYear,
        ) -> Self {
            Self {
                average_proportion_of_localities_over_limit: Ok(
                    value.average_proportion_of_localities_over_limit,
                ),
                weighted_average_localities_over_limit: Ok(
                    value.weighted_average_localities_over_limit,
                ),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion {
        average_proportion_of_localities_over_limit: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        region_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        weighted_average_localities_over_limit: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion {
        fn default() -> Self {
            Self {
                average_proportion_of_localities_over_limit: Ok(Default::default()),
                region_name: Ok(Default::default()),
                weighted_average_localities_over_limit: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion {
        pub fn average_proportion_of_localities_over_limit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.average_proportion_of_localities_over_limit = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for average_proportion_of_localities_over_limit: {}",
                        e
                    )
                });
            self
        }
        pub fn region_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.region_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for region_name: {}", e)
                });
            self
        }
        pub fn weighted_average_localities_over_limit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.weighted_average_localities_over_limit = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for weighted_average_localities_over_limit: {}",
                        e
                    )
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion,
    > for super::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                average_proportion_of_localities_over_limit: value
                    .average_proportion_of_localities_over_limit?,
                region_name: value.region_name?,
                weighted_average_localities_over_limit: value
                    .weighted_average_localities_over_limit?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion,
    > for BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalitiesOverLimitByYearAndRegion,
        ) -> Self {
            Self {
                average_proportion_of_localities_over_limit: Ok(
                    value.average_proportion_of_localities_over_limit,
                ),
                region_name: Ok(value.region_name),
                weighted_average_localities_over_limit: Ok(
                    value.weighted_average_localities_over_limit,
                ),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalityDto {
        avg_adult_female_lice: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        has_cleanerfish_deployed: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        has_ila: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        has_mechanical_removal: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        has_pd: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        has_reported_lice: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        has_salmonoids: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        has_substance_treatments: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        in_filtered_selection: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_fallow: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_on_land: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_slaughter_holding_cage: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        lat: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        locality_no: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        locality_week_id: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        lon: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        municipality: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        municipality_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityDto {
        fn default() -> Self {
            Self {
                avg_adult_female_lice: Ok(Default::default()),
                has_cleanerfish_deployed: Ok(Default::default()),
                has_ila: Ok(Default::default()),
                has_mechanical_removal: Ok(Default::default()),
                has_pd: Ok(Default::default()),
                has_reported_lice: Ok(Default::default()),
                has_salmonoids: Ok(Default::default()),
                has_substance_treatments: Ok(Default::default()),
                in_filtered_selection: Ok(Default::default()),
                is_fallow: Ok(Default::default()),
                is_on_land: Ok(Default::default()),
                is_slaughter_holding_cage: Ok(Default::default()),
                lat: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                locality_week_id: Ok(Default::default()),
                lon: Ok(Default::default()),
                municipality: Ok(Default::default()),
                municipality_no: Ok(Default::default()),
                name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalityDto {
        pub fn avg_adult_female_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_adult_female_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for avg_adult_female_lice: {}",
                        e
                    )
                });
            self
        }
        pub fn has_cleanerfish_deployed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_cleanerfish_deployed = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_cleanerfish_deployed: {}",
                        e
                    )
                });
            self
        }
        pub fn has_ila<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_ila = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for has_ila: {}", e)
                });
            self
        }
        pub fn has_mechanical_removal<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_mechanical_removal = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_mechanical_removal: {}",
                        e
                    )
                });
            self
        }
        pub fn has_pd<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_pd = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for has_pd: {}", e)
                });
            self
        }
        pub fn has_reported_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_reported_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_reported_lice: {}", e
                    )
                });
            self
        }
        pub fn has_salmonoids<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_salmonoids = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for has_salmonoids: {}", e)
                });
            self
        }
        pub fn has_substance_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_substance_treatments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_substance_treatments: {}",
                        e
                    )
                });
            self
        }
        pub fn in_filtered_selection<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.in_filtered_selection = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for in_filtered_selection: {}",
                        e
                    )
                });
            self
        }
        pub fn is_fallow<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_fallow = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_fallow: {}", e)
                });
            self
        }
        pub fn is_on_land<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_on_land = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_on_land: {}", e)
                });
            self
        }
        pub fn is_slaughter_holding_cage<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_slaughter_holding_cage = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_slaughter_holding_cage: {}",
                        e
                    )
                });
            self
        }
        pub fn lat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.lat = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lat: {}", e));
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn locality_week_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_week_id = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for locality_week_id: {}", e
                    )
                });
            self
        }
        pub fn lon<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.lon = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for lon: {}", e));
            self
        }
        pub fn municipality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality: {}", e)
                });
            self
        }
        pub fn municipality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality_no: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsLocalityDto>
    for super::BwApiApiFishhealthLocalityModelsLocalityDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalityDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                avg_adult_female_lice: value.avg_adult_female_lice?,
                has_cleanerfish_deployed: value.has_cleanerfish_deployed?,
                has_ila: value.has_ila?,
                has_mechanical_removal: value.has_mechanical_removal?,
                has_pd: value.has_pd?,
                has_reported_lice: value.has_reported_lice?,
                has_salmonoids: value.has_salmonoids?,
                has_substance_treatments: value.has_substance_treatments?,
                in_filtered_selection: value.in_filtered_selection?,
                is_fallow: value.is_fallow?,
                is_on_land: value.is_on_land?,
                is_slaughter_holding_cage: value.is_slaughter_holding_cage?,
                lat: value.lat?,
                locality_no: value.locality_no?,
                locality_week_id: value.locality_week_id?,
                lon: value.lon?,
                municipality: value.municipality?,
                municipality_no: value.municipality_no?,
                name: value.name?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiFishhealthLocalityModelsLocalityDto>
    for BwApiApiFishhealthLocalityModelsLocalityDto {
        fn from(value: super::BwApiApiFishhealthLocalityModelsLocalityDto) -> Self {
            Self {
                avg_adult_female_lice: Ok(value.avg_adult_female_lice),
                has_cleanerfish_deployed: Ok(value.has_cleanerfish_deployed),
                has_ila: Ok(value.has_ila),
                has_mechanical_removal: Ok(value.has_mechanical_removal),
                has_pd: Ok(value.has_pd),
                has_reported_lice: Ok(value.has_reported_lice),
                has_salmonoids: Ok(value.has_salmonoids),
                has_substance_treatments: Ok(value.has_substance_treatments),
                in_filtered_selection: Ok(value.in_filtered_selection),
                is_fallow: Ok(value.is_fallow),
                is_on_land: Ok(value.is_on_land),
                is_slaughter_holding_cage: Ok(value.is_slaughter_holding_cage),
                lat: Ok(value.lat),
                locality_no: Ok(value.locality_no),
                locality_week_id: Ok(value.locality_week_id),
                lon: Ok(value.lon),
                municipality: Ok(value.municipality),
                municipality_no: Ok(value.municipality_no),
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalityGraphDataDto {
        value: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsLocalityGraphDataDto {
        fn default() -> Self {
            Self {
                value: Ok(Default::default()),
                week: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalityGraphDataDto {
        pub fn value<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.value = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for value: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsLocalityGraphDataDto>
    for super::BwApiApiFishhealthLocalityModelsLocalityGraphDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalityGraphDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                value: value.value?,
                week: value.week?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsLocalityGraphDataDto,
    > for BwApiApiFishhealthLocalityModelsLocalityGraphDataDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalityGraphDataDto,
        ) -> Self {
            Self {
                value: Ok(value.value),
                week: Ok(value.week),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalityIlaPdLink {
        confirmed: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        disease: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        is_on_land: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        suspected: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityIlaPdLink {
        fn default() -> Self {
            Self {
                confirmed: Ok(Default::default()),
                disease: Ok(Default::default()),
                is_on_land: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                name: Ok(Default::default()),
                suspected: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalityIlaPdLink {
        pub fn confirmed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.confirmed = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for confirmed: {}", e)
                });
            self
        }
        pub fn disease<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.disease = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disease: {}", e)
                });
            self
        }
        pub fn is_on_land<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_on_land = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_on_land: {}", e)
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn suspected<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.suspected = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for suspected: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsLocalityIlaPdLink>
    for super::BwApiApiFishhealthLocalityModelsLocalityIlaPdLink {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalityIlaPdLink,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                confirmed: value.confirmed?,
                disease: value.disease?,
                is_on_land: value.is_on_land?,
                locality_no: value.locality_no?,
                name: value.name?,
                suspected: value.suspected?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiFishhealthLocalityModelsLocalityIlaPdLink>
    for BwApiApiFishhealthLocalityModelsLocalityIlaPdLink {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalityIlaPdLink,
        ) -> Self {
            Self {
                confirmed: Ok(value.confirmed),
                disease: Ok(value.disease),
                is_on_land: Ok(value.is_on_land),
                locality_no: Ok(value.locality_no),
                name: Ok(value.name),
                suspected: Ok(value.suspected),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalityLiceCountDto {
        avg_adult_female_lice: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        avg_mobile_lice: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        avg_stationary_lice: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        has_reported_lice: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsLocalityLiceCountDto {
        fn default() -> Self {
            Self {
                avg_adult_female_lice: Ok(Default::default()),
                avg_mobile_lice: Ok(Default::default()),
                avg_stationary_lice: Ok(Default::default()),
                has_reported_lice: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalityLiceCountDto {
        pub fn avg_adult_female_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_adult_female_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for avg_adult_female_lice: {}",
                        e
                    )
                });
            self
        }
        pub fn avg_mobile_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_mobile_lice = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for avg_mobile_lice: {}", e)
                });
            self
        }
        pub fn avg_stationary_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_stationary_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for avg_stationary_lice: {}", e
                    )
                });
            self
        }
        pub fn has_reported_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_reported_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_reported_lice: {}", e
                    )
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsLocalityLiceCountDto>
    for super::BwApiApiFishhealthLocalityModelsLocalityLiceCountDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalityLiceCountDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                avg_adult_female_lice: value.avg_adult_female_lice?,
                avg_mobile_lice: value.avg_mobile_lice?,
                avg_stationary_lice: value.avg_stationary_lice?,
                has_reported_lice: value.has_reported_lice?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsLocalityLiceCountDto,
    > for BwApiApiFishhealthLocalityModelsLocalityLiceCountDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalityLiceCountDto,
        ) -> Self {
            Self {
                avg_adult_female_lice: Ok(value.avg_adult_female_lice),
                avg_mobile_lice: Ok(value.avg_mobile_lice),
                avg_stationary_lice: Ok(value.avg_stationary_lice),
                has_reported_lice: Ok(value.has_reported_lice),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto {
        data: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto,
            >,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        max_combined_number_of_lice: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto {
        fn default() -> Self {
            Self {
                data: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                max_combined_number_of_lice: Ok(Default::default()),
                type_: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto {
        pub fn data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.data = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for data: {}", e));
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn max_combined_number_of_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.max_combined_number_of_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for max_combined_number_of_lice: {}",
                        e
                    )
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto,
    > for super::BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                data: value.data?,
                locality_no: value.locality_no?,
                max_combined_number_of_lice: value.max_combined_number_of_lice?,
                type_: value.type_?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto,
    > for BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataDto,
        ) -> Self {
            Self {
                data: Ok(value.data),
                locality_no: Ok(value.locality_no),
                max_combined_number_of_lice: Ok(value.max_combined_number_of_lice),
                type_: Ok(value.type_),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto {
        avg_adult_female_lice: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        avg_mobile_lice: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        avg_stationary_lice: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        has_reported_lice: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto {
        fn default() -> Self {
            Self {
                avg_adult_female_lice: Ok(Default::default()),
                avg_mobile_lice: Ok(Default::default()),
                avg_stationary_lice: Ok(Default::default()),
                has_reported_lice: Ok(Default::default()),
                week: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto {
        pub fn avg_adult_female_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_adult_female_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for avg_adult_female_lice: {}",
                        e
                    )
                });
            self
        }
        pub fn avg_mobile_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_mobile_lice = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for avg_mobile_lice: {}", e)
                });
            self
        }
        pub fn avg_stationary_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_stationary_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for avg_stationary_lice: {}", e
                    )
                });
            self
        }
        pub fn has_reported_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_reported_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_reported_lice: {}", e
                    )
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto,
    >
    for super::BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                avg_adult_female_lice: value.avg_adult_female_lice?,
                avg_mobile_lice: value.avg_mobile_lice?,
                avg_stationary_lice: value.avg_stationary_lice?,
                has_reported_lice: value.has_reported_lice?,
                week: value.week?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto,
    > for BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalityLiceDistributionGraphDataWeekDto,
        ) -> Self {
            Self {
                avg_adult_female_lice: Ok(value.avg_adult_female_lice),
                avg_mobile_lice: Ok(value.avg_mobile_lice),
                avg_stationary_lice: Ok(value.avg_stationary_lice),
                has_reported_lice: Ok(value.has_reported_lice),
                week: Ok(value.week),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto {
        data: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiFishhealthLocalityModelsLocalityGraphDataDto>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto {
        fn default() -> Self {
            Self {
                data: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                type_: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto {
        pub fn data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiFishhealthLocalityModelsLocalityGraphDataDto,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.data = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for data: {}", e));
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto,
    > for super::BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                data: value.data?,
                locality_no: value.locality_no?,
                type_: value.type_?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto,
    > for BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalityLiceGraphDataDto,
        ) -> Self {
            Self {
                data: Ok(value.data),
                locality_no: Ok(value.locality_no),
                type_: Ok(value.type_),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalityNameIdDto {
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityNameIdDto {
        fn default() -> Self {
            Self {
                locality_no: Ok(Default::default()),
                name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalityNameIdDto {
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsLocalityNameIdDto>
    for super::BwApiApiFishhealthLocalityModelsLocalityNameIdDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalityNameIdDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                locality_no: value.locality_no?,
                name: value.name?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiFishhealthLocalityModelsLocalityNameIdDto>
    for BwApiApiFishhealthLocalityModelsLocalityNameIdDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalityNameIdDto,
        ) -> Self {
            Self {
                locality_no: Ok(value.locality_no),
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto {
        aqua_culture_registry_version: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        municipality: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        municipality_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto {
        fn default() -> Self {
            Self {
                aqua_culture_registry_version: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                municipality: Ok(Default::default()),
                municipality_no: Ok(Default::default()),
                name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto {
        pub fn aqua_culture_registry_version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.aqua_culture_registry_version = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for aqua_culture_registry_version: {}",
                        e
                    )
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn municipality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality: {}", e)
                });
            self
        }
        pub fn municipality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality_no: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto,
    > for super::BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                aqua_culture_registry_version: value.aqua_culture_registry_version?,
                locality_no: value.locality_no?,
                municipality: value.municipality?,
                municipality_no: value.municipality_no?,
                name: value.name?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto,
    > for BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalityNameIdMunicipalityDto,
        ) -> Self {
            Self {
                aqua_culture_registry_version: Ok(value.aqua_culture_registry_version),
                locality_no: Ok(value.locality_no),
                municipality: Ok(value.municipality),
                municipality_no: Ok(value.municipality_no),
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalityReportV1 {
        aqua_culture_register: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto,
            >,
            ::std::string::String,
        >,
        escapes: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>,
            ::std::string::String,
        >,
        export_restriction_areas: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiExportRestrictionsModelsExportRestrictionAreaLink,
            >,
            ::std::string::String,
        >,
        ila_pd: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiIlaPdsModelsIlaPd>,
            ::std::string::String,
        >,
        ila_pd_case: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiIlaPdCasesModelsIlaPdCase>,
            ::std::string::String,
        >,
        ila_protection_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsIlaControlAreaDto>,
            ::std::string::String,
        >,
        ila_surveillance_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsIlaControlAreaDto>,
            ::std::string::String,
        >,
        lice_count_previous_week: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiFishhealthLocalityModelsLocalityLiceCountDto,
            >,
            ::std::string::String,
        >,
        locality_is_in_aqua_culture_register: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        locality_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        locality_week: ::std::result::Result<
            ::std::option::Option<super::BwApiApiLicereportModelsLocalityWeek>,
            ::std::string::String,
        >,
        pd_protection_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsPdControlAreaDto>,
            ::std::string::String,
        >,
        pd_surveillance_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsPdControlAreaDto>,
            ::std::string::String,
        >,
        pd_zone_id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        production_area: ::std::result::Result<
            ::std::option::Option<super::BwApiApiProductionAreasModelsProductionArea>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityReportV1 {
        fn default() -> Self {
            Self {
                aqua_culture_register: Ok(Default::default()),
                escapes: Ok(Default::default()),
                export_restriction_areas: Ok(Default::default()),
                ila_pd: Ok(Default::default()),
                ila_pd_case: Ok(Default::default()),
                ila_protection_zones: Ok(Default::default()),
                ila_surveillance_zones: Ok(Default::default()),
                lice_count_previous_week: Ok(Default::default()),
                locality_is_in_aqua_culture_register: Ok(Default::default()),
                locality_name: Ok(Default::default()),
                locality_week: Ok(Default::default()),
                pd_protection_zones: Ok(Default::default()),
                pd_surveillance_zones: Ok(Default::default()),
                pd_zone_id: Ok(Default::default()),
                production_area: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalityReportV1 {
        pub fn aqua_culture_register<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiAquacultureRegisterModelsDtoAquaCultureLocalityDto,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.aqua_culture_register = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for aqua_culture_register: {}",
                        e
                    )
                });
            self
        }
        pub fn escapes<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.escapes = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for escapes: {}", e)
                });
            self
        }
        pub fn export_restriction_areas<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiExportRestrictionsModelsExportRestrictionAreaLink,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.export_restriction_areas = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for export_restriction_areas: {}",
                        e
                    )
                });
            self
        }
        pub fn ila_pd<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiIlaPdsModelsIlaPd>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ila_pd = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ila_pd: {}", e)
                });
            self
        }
        pub fn ila_pd_case<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiIlaPdCasesModelsIlaPdCase>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ila_pd_case = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ila_pd_case: {}", e)
                });
            self
        }
        pub fn ila_protection_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsIlaControlAreaDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ila_protection_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ila_protection_zones: {}", e
                    )
                });
            self
        }
        pub fn ila_surveillance_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsIlaControlAreaDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ila_surveillance_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ila_surveillance_zones: {}",
                        e
                    )
                });
            self
        }
        pub fn lice_count_previous_week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiFishhealthLocalityModelsLocalityLiceCountDto,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.lice_count_previous_week = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for lice_count_previous_week: {}",
                        e
                    )
                });
            self
        }
        pub fn locality_is_in_aqua_culture_register<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_is_in_aqua_culture_register = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for locality_is_in_aqua_culture_register: {}",
                        e
                    )
                });
            self
        }
        pub fn locality_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_name: {}", e)
                });
            self
        }
        pub fn locality_week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::BwApiApiLicereportModelsLocalityWeek>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.locality_week = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_week: {}", e)
                });
            self
        }
        pub fn pd_protection_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsPdControlAreaDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.pd_protection_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for pd_protection_zones: {}", e
                    )
                });
            self
        }
        pub fn pd_surveillance_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsPdControlAreaDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.pd_surveillance_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for pd_surveillance_zones: {}",
                        e
                    )
                });
            self
        }
        pub fn pd_zone_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.pd_zone_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for pd_zone_id: {}", e)
                });
            self
        }
        pub fn production_area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::BwApiApiProductionAreasModelsProductionArea>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.production_area = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for production_area: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsLocalityReportV1>
    for super::BwApiApiFishhealthLocalityModelsLocalityReportV1 {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalityReportV1,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                aqua_culture_register: value.aqua_culture_register?,
                escapes: value.escapes?,
                export_restriction_areas: value.export_restriction_areas?,
                ila_pd: value.ila_pd?,
                ila_pd_case: value.ila_pd_case?,
                ila_protection_zones: value.ila_protection_zones?,
                ila_surveillance_zones: value.ila_surveillance_zones?,
                lice_count_previous_week: value.lice_count_previous_week?,
                locality_is_in_aqua_culture_register: value
                    .locality_is_in_aqua_culture_register?,
                locality_name: value.locality_name?,
                locality_week: value.locality_week?,
                pd_protection_zones: value.pd_protection_zones?,
                pd_surveillance_zones: value.pd_surveillance_zones?,
                pd_zone_id: value.pd_zone_id?,
                production_area: value.production_area?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiFishhealthLocalityModelsLocalityReportV1>
    for BwApiApiFishhealthLocalityModelsLocalityReportV1 {
        fn from(value: super::BwApiApiFishhealthLocalityModelsLocalityReportV1) -> Self {
            Self {
                aqua_culture_register: Ok(value.aqua_culture_register),
                escapes: Ok(value.escapes),
                export_restriction_areas: Ok(value.export_restriction_areas),
                ila_pd: Ok(value.ila_pd),
                ila_pd_case: Ok(value.ila_pd_case),
                ila_protection_zones: Ok(value.ila_protection_zones),
                ila_surveillance_zones: Ok(value.ila_surveillance_zones),
                lice_count_previous_week: Ok(value.lice_count_previous_week),
                locality_is_in_aqua_culture_register: Ok(
                    value.locality_is_in_aqua_culture_register,
                ),
                locality_name: Ok(value.locality_name),
                locality_week: Ok(value.locality_week),
                pd_protection_zones: Ok(value.pd_protection_zones),
                pd_surveillance_zones: Ok(value.pd_surveillance_zones),
                pd_zone_id: Ok(value.pd_zone_id),
                production_area: Ok(value.production_area),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto {
        data: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto,
            >,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        max_sea_temperature: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        min_max_temperature_is_set: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        min_sea_temperature: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto {
        fn default() -> Self {
            Self {
                data: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                max_sea_temperature: Ok(Default::default()),
                min_max_temperature_is_set: Ok(Default::default()),
                min_sea_temperature: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto {
        pub fn data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.data = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for data: {}", e));
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn max_sea_temperature<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.max_sea_temperature = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for max_sea_temperature: {}", e
                    )
                });
            self
        }
        pub fn min_max_temperature_is_set<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.min_max_temperature_is_set = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for min_max_temperature_is_set: {}",
                        e
                    )
                });
            self
        }
        pub fn min_sea_temperature<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.min_sea_temperature = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for min_sea_temperature: {}", e
                    )
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto,
    > for super::BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                data: value.data?,
                locality_no: value.locality_no?,
                max_sea_temperature: value.max_sea_temperature?,
                min_max_temperature_is_set: value.min_max_temperature_is_set?,
                min_sea_temperature: value.min_sea_temperature?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto,
    > for BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsLocalitySeaTemperatureGraphDataDto,
        ) -> Self {
            Self {
                data: Ok(value.data),
                locality_no: Ok(value.locality_no),
                max_sea_temperature: Ok(value.max_sea_temperature),
                min_max_temperature_is_set: Ok(value.min_max_temperature_is_set),
                min_sea_temperature: Ok(value.min_sea_temperature),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsLocalityWeekData {
        localities: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiFishhealthLocalityModelsLocalityDto>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiFishhealthLocalityModelsLocalityWeekData {
        fn default() -> Self {
            Self {
                localities: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsLocalityWeekData {
        pub fn localities<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiFishhealthLocalityModelsLocalityDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.localities = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for localities: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsLocalityWeekData>
    for super::BwApiApiFishhealthLocalityModelsLocalityWeekData {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsLocalityWeekData,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                localities: value.localities?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiFishhealthLocalityModelsLocalityWeekData>
    for BwApiApiFishhealthLocalityModelsLocalityWeekData {
        fn from(value: super::BwApiApiFishhealthLocalityModelsLocalityWeekData) -> Self {
            Self {
                localities: Ok(value.localities),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto {
        entire_locality: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        number_of_cages: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        substance_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto {
        fn default() -> Self {
            Self {
                entire_locality: Ok(Default::default()),
                name: Ok(Default::default()),
                number_of_cages: Ok(Default::default()),
                substance_id: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto {
        pub fn entire_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.entire_locality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for entire_locality: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn number_of_cages<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_cages = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for number_of_cages: {}", e)
                });
            self
        }
        pub fn substance_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.substance_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for substance_id: {}", e)
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto>
    for super::BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                entire_locality: value.entire_locality?,
                name: value.name?,
                number_of_cages: value.number_of_cages?,
                substance_id: value.substance_id?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto,
    > for BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto,
        ) -> Self {
            Self {
                entire_locality: Ok(value.entire_locality),
                name: Ok(value.name),
                number_of_cages: Ok(value.number_of_cages),
                substance_id: Ok(value.substance_id),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsNationalReportV1 {
        escapes: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>,
            ::std::string::String,
        >,
        escapes_annual: ::std::result::Result<
            ::std::option::Option<super::BwApiApiEscapesModelsEscapesGraphDataDto>,
            ::std::string::String,
        >,
        localities_above_lice_limit_annual: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto,
            >,
            ::std::string::String,
        >,
        localities_above_threshold: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        localities_below_minimum_threshold: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        localities_below_threshold: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        new_localities_with_disease: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiFishhealthLocalityModelsLocalityIlaPdLink>,
            ::std::string::String,
        >,
        new_localities_with_disease_annual: ::std::result::Result<
            ::std::option::Option<super::BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto>,
            ::std::string::String,
        >,
        number_of_filtered_localities: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        number_of_localities_with_ila: ::std::result::Result<
            ::std::option::Option<super::BwApiApiFishhealthLocalityModelsDiseaseCount>,
            ::std::string::String,
        >,
        number_of_localities_with_pd: ::std::result::Result<
            ::std::option::Option<super::BwApiApiFishhealthLocalityModelsDiseaseCount>,
            ::std::string::String,
        >,
        number_of_reporting_localities: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        percentage_of_localities_above_threshold: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        percentage_of_localities_below_minimum_threshold: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        percentage_of_localities_below_threshold: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        total_number_of_localities: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiFishhealthLocalityModelsNationalReportV1 {
        fn default() -> Self {
            Self {
                escapes: Ok(Default::default()),
                escapes_annual: Ok(Default::default()),
                localities_above_lice_limit_annual: Ok(Default::default()),
                localities_above_threshold: Ok(Default::default()),
                localities_below_minimum_threshold: Ok(Default::default()),
                localities_below_threshold: Ok(Default::default()),
                new_localities_with_disease: Ok(Default::default()),
                new_localities_with_disease_annual: Ok(Default::default()),
                number_of_filtered_localities: Ok(Default::default()),
                number_of_localities_with_ila: Ok(Default::default()),
                number_of_localities_with_pd: Ok(Default::default()),
                number_of_reporting_localities: Ok(Default::default()),
                percentage_of_localities_above_threshold: Ok(Default::default()),
                percentage_of_localities_below_minimum_threshold: Ok(Default::default()),
                percentage_of_localities_below_threshold: Ok(Default::default()),
                total_number_of_localities: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsNationalReportV1 {
        pub fn escapes<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiFarmedFishEscapeModelsFarmedFishEscapeDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.escapes = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for escapes: {}", e)
                });
            self
        }
        pub fn escapes_annual<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::BwApiApiEscapesModelsEscapesGraphDataDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.escapes_annual = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for escapes_annual: {}", e)
                });
            self
        }
        pub fn localities_above_lice_limit_annual<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.localities_above_lice_limit_annual = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for localities_above_lice_limit_annual: {}",
                        e
                    )
                });
            self
        }
        pub fn localities_above_threshold<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.localities_above_threshold = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for localities_above_threshold: {}",
                        e
                    )
                });
            self
        }
        pub fn localities_below_minimum_threshold<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.localities_below_minimum_threshold = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for localities_below_minimum_threshold: {}",
                        e
                    )
                });
            self
        }
        pub fn localities_below_threshold<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.localities_below_threshold = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for localities_below_threshold: {}",
                        e
                    )
                });
            self
        }
        pub fn new_localities_with_disease<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiFishhealthLocalityModelsLocalityIlaPdLink>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.new_localities_with_disease = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for new_localities_with_disease: {}",
                        e
                    )
                });
            self
        }
        pub fn new_localities_with_disease_annual<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.new_localities_with_disease_annual = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for new_localities_with_disease_annual: {}",
                        e
                    )
                });
            self
        }
        pub fn number_of_filtered_localities<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_filtered_localities = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for number_of_filtered_localities: {}",
                        e
                    )
                });
            self
        }
        pub fn number_of_localities_with_ila<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiFishhealthLocalityModelsDiseaseCount,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_localities_with_ila = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for number_of_localities_with_ila: {}",
                        e
                    )
                });
            self
        }
        pub fn number_of_localities_with_pd<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiFishhealthLocalityModelsDiseaseCount,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_localities_with_pd = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for number_of_localities_with_pd: {}",
                        e
                    )
                });
            self
        }
        pub fn number_of_reporting_localities<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_reporting_localities = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for number_of_reporting_localities: {}",
                        e
                    )
                });
            self
        }
        pub fn percentage_of_localities_above_threshold<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.percentage_of_localities_above_threshold = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for percentage_of_localities_above_threshold: {}",
                        e
                    )
                });
            self
        }
        pub fn percentage_of_localities_below_minimum_threshold<T>(
            mut self,
            value: T,
        ) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.percentage_of_localities_below_minimum_threshold = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for percentage_of_localities_below_minimum_threshold: {}",
                        e
                    )
                });
            self
        }
        pub fn percentage_of_localities_below_threshold<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.percentage_of_localities_below_threshold = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for percentage_of_localities_below_threshold: {}",
                        e
                    )
                });
            self
        }
        pub fn total_number_of_localities<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.total_number_of_localities = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for total_number_of_localities: {}",
                        e
                    )
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsNationalReportV1>
    for super::BwApiApiFishhealthLocalityModelsNationalReportV1 {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsNationalReportV1,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                escapes: value.escapes?,
                escapes_annual: value.escapes_annual?,
                localities_above_lice_limit_annual: value
                    .localities_above_lice_limit_annual?,
                localities_above_threshold: value.localities_above_threshold?,
                localities_below_minimum_threshold: value
                    .localities_below_minimum_threshold?,
                localities_below_threshold: value.localities_below_threshold?,
                new_localities_with_disease: value.new_localities_with_disease?,
                new_localities_with_disease_annual: value
                    .new_localities_with_disease_annual?,
                number_of_filtered_localities: value.number_of_filtered_localities?,
                number_of_localities_with_ila: value.number_of_localities_with_ila?,
                number_of_localities_with_pd: value.number_of_localities_with_pd?,
                number_of_reporting_localities: value.number_of_reporting_localities?,
                percentage_of_localities_above_threshold: value
                    .percentage_of_localities_above_threshold?,
                percentage_of_localities_below_minimum_threshold: value
                    .percentage_of_localities_below_minimum_threshold?,
                percentage_of_localities_below_threshold: value
                    .percentage_of_localities_below_threshold?,
                total_number_of_localities: value.total_number_of_localities?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiFishhealthLocalityModelsNationalReportV1>
    for BwApiApiFishhealthLocalityModelsNationalReportV1 {
        fn from(value: super::BwApiApiFishhealthLocalityModelsNationalReportV1) -> Self {
            Self {
                escapes: Ok(value.escapes),
                escapes_annual: Ok(value.escapes_annual),
                localities_above_lice_limit_annual: Ok(
                    value.localities_above_lice_limit_annual,
                ),
                localities_above_threshold: Ok(value.localities_above_threshold),
                localities_below_minimum_threshold: Ok(
                    value.localities_below_minimum_threshold,
                ),
                localities_below_threshold: Ok(value.localities_below_threshold),
                new_localities_with_disease: Ok(value.new_localities_with_disease),
                new_localities_with_disease_annual: Ok(
                    value.new_localities_with_disease_annual,
                ),
                number_of_filtered_localities: Ok(value.number_of_filtered_localities),
                number_of_localities_with_ila: Ok(value.number_of_localities_with_ila),
                number_of_localities_with_pd: Ok(value.number_of_localities_with_pd),
                number_of_reporting_localities: Ok(value.number_of_reporting_localities),
                percentage_of_localities_above_threshold: Ok(
                    value.percentage_of_localities_above_threshold,
                ),
                percentage_of_localities_below_minimum_threshold: Ok(
                    value.percentage_of_localities_below_minimum_threshold,
                ),
                percentage_of_localities_below_threshold: Ok(
                    value.percentage_of_localities_below_threshold,
                ),
                total_number_of_localities: Ok(value.total_number_of_localities),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek {
        cleaner_fish_treatments: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiFishhealthLocalityModelsCleanerFishTreatment>,
            ::std::string::String,
        >,
        combination_treatments: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiLicereportModelsLiceReportCombinationTreatment,
            >,
            ::std::string::String,
        >,
        mechanical_removal: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        mechanical_removal_entire_locality: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        medicinal_treatments: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto,
            >,
            ::std::string::String,
        >,
        non_medicinal_treatments: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
            >,
            ::std::string::String,
        >,
        version: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek {
        fn default() -> Self {
            Self {
                cleaner_fish_treatments: Ok(Default::default()),
                combination_treatments: Ok(Default::default()),
                mechanical_removal: Ok(Default::default()),
                mechanical_removal_entire_locality: Ok(Default::default()),
                medicinal_treatments: Ok(Default::default()),
                non_medicinal_treatments: Ok(Default::default()),
                version: Ok(Default::default()),
                week: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek {
        pub fn cleaner_fish_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiFishhealthLocalityModelsCleanerFishTreatment,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.cleaner_fish_treatments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for cleaner_fish_treatments: {}",
                        e
                    )
                });
            self
        }
        pub fn combination_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiLicereportModelsLiceReportCombinationTreatment,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.combination_treatments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for combination_treatments: {}",
                        e
                    )
                });
            self
        }
        pub fn mechanical_removal<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.mechanical_removal = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for mechanical_removal: {}", e
                    )
                });
            self
        }
        pub fn mechanical_removal_entire_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.mechanical_removal_entire_locality = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for mechanical_removal_entire_locality: {}",
                        e
                    )
                });
            self
        }
        pub fn medicinal_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiFishhealthLocalityModelsMedicinalTreatmentDto,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.medicinal_treatments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for medicinal_treatments: {}", e
                    )
                });
            self
        }
        pub fn non_medicinal_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.non_medicinal_treatments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for non_medicinal_treatments: {}",
                        e
                    )
                });
            self
        }
        pub fn version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.version = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for version: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek>
    for super::BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                cleaner_fish_treatments: value.cleaner_fish_treatments?,
                combination_treatments: value.combination_treatments?,
                mechanical_removal: value.mechanical_removal?,
                mechanical_removal_entire_locality: value
                    .mechanical_removal_entire_locality?,
                medicinal_treatments: value.medicinal_treatments?,
                non_medicinal_treatments: value.non_medicinal_treatments?,
                version: value.version?,
                week: value.week?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek,
    > for BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsTreatmentGraphDataWeek,
        ) -> Self {
            Self {
                cleaner_fish_treatments: Ok(value.cleaner_fish_treatments),
                combination_treatments: Ok(value.combination_treatments),
                mechanical_removal: Ok(value.mechanical_removal),
                mechanical_removal_entire_locality: Ok(
                    value.mechanical_removal_entire_locality,
                ),
                medicinal_treatments: Ok(value.medicinal_treatments),
                non_medicinal_treatments: Ok(value.non_medicinal_treatments),
                version: Ok(value.version),
                week: Ok(value.week),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto {
        has_reported: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        sea_temperature: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto {
        fn default() -> Self {
            Self {
                has_reported: Ok(Default::default()),
                sea_temperature: Ok(Default::default()),
                week: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto {
        pub fn has_reported<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_reported = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for has_reported: {}", e)
                });
            self
        }
        pub fn sea_temperature<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.sea_temperature = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for sea_temperature: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto>
    for super::BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                has_reported: value.has_reported?,
                sea_temperature: value.sea_temperature?,
                week: value.week?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto,
    > for BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto {
        fn from(
            value: super::BwApiApiFishhealthLocalityModelsWeekSeaTemparatureDto,
        ) -> Self {
            Self {
                has_reported: Ok(value.has_reported),
                sea_temperature: Ok(value.sea_temperature),
                week: Ok(value.week),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling {
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        objectid: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        version: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling {
        fn default() -> Self {
            Self {
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                objectid: Ok(Default::default()),
                type_: Ok(Default::default()),
                version: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling {
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn objectid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.objectid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for objectid: {}", e)
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
        pub fn version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.version = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for version: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling,
    >
    for super::BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                geometry: value.geometry?,
                id: value.id?,
                objectid: value.objectid?,
                type_: value.type_?,
                version: value.version?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling,
    > for BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling {
        fn from(
            value: super::BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneBadebehandling,
        ) -> Self {
            Self {
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                objectid: Ok(value.objectid),
                type_: Ok(value.type_),
                version: Ok(value.version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere {
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        objectid: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        version: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere {
        fn default() -> Self {
            Self {
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                objectid: Ok(Default::default()),
                type_: Ok(Default::default()),
                version: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere {
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn objectid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.objectid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for objectid: {}", e)
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
        pub fn version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.version = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for version: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere,
    >
    for super::BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                geometry: value.geometry?,
                id: value.id?,
                objectid: value.objectid?,
                type_: value.type_?,
                version: value.version?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere,
    >
    for BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere {
        fn from(
            value: super::BwApiApiForbiddenMedicinalZonesModelsForbiddenMedicinalZoneKitinsyntesehemmere,
        ) -> Self {
            Self {
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                objectid: Ok(value.objectid),
                type_: Ok(value.type_),
                version: Ok(value.version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiIlaPdCasesModelsIlaPdCase {
        changed_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        closed_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        confirmed_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        created_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        disease: ::std::result::Result<
            ::std::option::Option<super::BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName>,
            ::std::string::String,
        >,
        disproved: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        disproved_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        emptied_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        subtype: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType,
            >,
            ::std::string::String,
        >,
        suspected_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiIlaPdCasesModelsIlaPdCase {
        fn default() -> Self {
            Self {
                changed_date: Ok(Default::default()),
                closed_date: Ok(Default::default()),
                confirmed_date: Ok(Default::default()),
                created_date: Ok(Default::default()),
                disease: Ok(Default::default()),
                disproved: Ok(Default::default()),
                disproved_date: Ok(Default::default()),
                emptied_date: Ok(Default::default()),
                id: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                subtype: Ok(Default::default()),
                suspected_date: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiIlaPdCasesModelsIlaPdCase {
        pub fn changed_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.changed_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for changed_date: {}", e)
                });
            self
        }
        pub fn closed_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.closed_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for closed_date: {}", e)
                });
            self
        }
        pub fn confirmed_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.confirmed_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for confirmed_date: {}", e)
                });
            self
        }
        pub fn created_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.created_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for created_date: {}", e)
                });
            self
        }
        pub fn disease<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.disease = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disease: {}", e)
                });
            self
        }
        pub fn disproved<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.disproved = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disproved: {}", e)
                });
            self
        }
        pub fn disproved_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.disproved_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disproved_date: {}", e)
                });
            self
        }
        pub fn emptied_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.emptied_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for emptied_date: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn subtype<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.subtype = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for subtype: {}", e)
                });
            self
        }
        pub fn suspected_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.suspected_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for suspected_date: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiIlaPdCasesModelsIlaPdCase>
    for super::BwApiApiIlaPdCasesModelsIlaPdCase {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiIlaPdCasesModelsIlaPdCase,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                changed_date: value.changed_date?,
                closed_date: value.closed_date?,
                confirmed_date: value.confirmed_date?,
                created_date: value.created_date?,
                disease: value.disease?,
                disproved: value.disproved?,
                disproved_date: value.disproved_date?,
                emptied_date: value.emptied_date?,
                id: value.id?,
                locality_no: value.locality_no?,
                subtype: value.subtype?,
                suspected_date: value.suspected_date?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiIlaPdCasesModelsIlaPdCase>
    for BwApiApiIlaPdCasesModelsIlaPdCase {
        fn from(value: super::BwApiApiIlaPdCasesModelsIlaPdCase) -> Self {
            Self {
                changed_date: Ok(value.changed_date),
                closed_date: Ok(value.closed_date),
                confirmed_date: Ok(value.confirmed_date),
                created_date: Ok(value.created_date),
                disease: Ok(value.disease),
                disproved: Ok(value.disproved),
                disproved_date: Ok(value.disproved_date),
                emptied_date: Ok(value.emptied_date),
                id: Ok(value.id),
                locality_no: Ok(value.locality_no),
                subtype: Ok(value.subtype),
                suspected_date: Ok(value.suspected_date),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiIlaPdCasesModelsIlaPdCaseDetail {
        closed_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        confirmed_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        disease: ::std::result::Result<
            ::std::option::Option<super::BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName>,
            ::std::string::String,
        >,
        disproved: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        disproved_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        emptied_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        subtype: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType,
            >,
            ::std::string::String,
        >,
        suspected_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiIlaPdCasesModelsIlaPdCaseDetail {
        fn default() -> Self {
            Self {
                closed_date: Ok(Default::default()),
                confirmed_date: Ok(Default::default()),
                disease: Ok(Default::default()),
                disproved: Ok(Default::default()),
                disproved_date: Ok(Default::default()),
                emptied_date: Ok(Default::default()),
                subtype: Ok(Default::default()),
                suspected_date: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiIlaPdCasesModelsIlaPdCaseDetail {
        pub fn closed_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.closed_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for closed_date: {}", e)
                });
            self
        }
        pub fn confirmed_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.confirmed_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for confirmed_date: {}", e)
                });
            self
        }
        pub fn disease<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseName,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.disease = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disease: {}", e)
                });
            self
        }
        pub fn disproved<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.disproved = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disproved: {}", e)
                });
            self
        }
        pub fn disproved_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.disproved_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disproved_date: {}", e)
                });
            self
        }
        pub fn emptied_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.emptied_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for emptied_date: {}", e)
                });
            self
        }
        pub fn subtype<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiIlaPdCasesModelsIlaPdCaseDiseaseSubType,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.subtype = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for subtype: {}", e)
                });
            self
        }
        pub fn suspected_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.suspected_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for suspected_date: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiIlaPdCasesModelsIlaPdCaseDetail>
    for super::BwApiApiIlaPdCasesModelsIlaPdCaseDetail {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiIlaPdCasesModelsIlaPdCaseDetail,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                closed_date: value.closed_date?,
                confirmed_date: value.confirmed_date?,
                disease: value.disease?,
                disproved: value.disproved?,
                disproved_date: value.disproved_date?,
                emptied_date: value.emptied_date?,
                subtype: value.subtype?,
                suspected_date: value.suspected_date?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiIlaPdCasesModelsIlaPdCaseDetail>
    for BwApiApiIlaPdCasesModelsIlaPdCaseDetail {
        fn from(value: super::BwApiApiIlaPdCasesModelsIlaPdCaseDetail) -> Self {
            Self {
                closed_date: Ok(value.closed_date),
                confirmed_date: Ok(value.confirmed_date),
                disease: Ok(value.disease),
                disproved: Ok(value.disproved),
                disproved_date: Ok(value.disproved_date),
                emptied_date: Ok(value.emptied_date),
                subtype: Ok(value.subtype),
                suspected_date: Ok(value.suspected_date),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiIlaPdsModelsIlaPd {
        disease: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        from_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        locality_no: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        ruling: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        to_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiIlaPdsModelsIlaPd {
        fn default() -> Self {
            Self {
                disease: Ok(Default::default()),
                from_date: Ok(Default::default()),
                id: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                ruling: Ok(Default::default()),
                to_date: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiIlaPdsModelsIlaPd {
        pub fn disease<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.disease = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disease: {}", e)
                });
            self
        }
        pub fn from_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_date: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn ruling<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ruling = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ruling: {}", e)
                });
            self
        }
        pub fn to_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_date: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiIlaPdsModelsIlaPd>
    for super::BwApiApiIlaPdsModelsIlaPd {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiIlaPdsModelsIlaPd,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                disease: value.disease?,
                from_date: value.from_date?,
                id: value.id?,
                locality_no: value.locality_no?,
                ruling: value.ruling?,
                to_date: value.to_date?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiIlaPdsModelsIlaPd>
    for BwApiApiIlaPdsModelsIlaPd {
        fn from(value: super::BwApiApiIlaPdsModelsIlaPd) -> Self {
            Self {
                disease: Ok(value.disease),
                from_date: Ok(value.from_date),
                id: Ok(value.id),
                locality_no: Ok(value.locality_no),
                ruling: Ok(value.ruling),
                to_date: Ok(value.to_date),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto {
        included_new_ila_cases: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        included_new_pd_cases: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        new_disease_cases: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto>,
            ::std::string::String,
        >,
        total_new_ila_cases: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        total_new_pd_cases: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto {
        fn default() -> Self {
            Self {
                included_new_ila_cases: Ok(Default::default()),
                included_new_pd_cases: Ok(Default::default()),
                new_disease_cases: Ok(Default::default()),
                total_new_ila_cases: Ok(Default::default()),
                total_new_pd_cases: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto {
        pub fn included_new_ila_cases<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.included_new_ila_cases = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for included_new_ila_cases: {}",
                        e
                    )
                });
            self
        }
        pub fn included_new_pd_cases<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.included_new_pd_cases = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for included_new_pd_cases: {}",
                        e
                    )
                });
            self
        }
        pub fn new_disease_cases<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.new_disease_cases = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for new_disease_cases: {}", e
                    )
                });
            self
        }
        pub fn total_new_ila_cases<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.total_new_ila_cases = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for total_new_ila_cases: {}", e
                    )
                });
            self
        }
        pub fn total_new_pd_cases<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.total_new_pd_cases = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for total_new_pd_cases: {}", e
                    )
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto>
    for super::BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                included_new_ila_cases: value.included_new_ila_cases?,
                included_new_pd_cases: value.included_new_pd_cases?,
                new_disease_cases: value.new_disease_cases?,
                total_new_ila_cases: value.total_new_ila_cases?,
                total_new_pd_cases: value.total_new_pd_cases?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto>
    for BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto {
        fn from(value: super::BwApiApiIlaPdsModelsNewIlapdCasesGraphDataDto) -> Self {
            Self {
                included_new_ila_cases: Ok(value.included_new_ila_cases),
                included_new_pd_cases: Ok(value.included_new_pd_cases),
                new_disease_cases: Ok(value.new_disease_cases),
                total_new_ila_cases: Ok(value.total_new_ila_cases),
                total_new_pd_cases: Ok(value.total_new_pd_cases),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto {
        ila: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        pd: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto {
        fn default() -> Self {
            Self {
                ila: Ok(Default::default()),
                pd: Ok(Default::default()),
                week: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto {
        pub fn ila<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.ila = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for ila: {}", e));
            self
        }
        pub fn pd<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.pd = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for pd: {}", e));
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto>
    for super::BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                ila: value.ila?,
                pd: value.pd?,
                week: value.week?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto>
    for BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto {
        fn from(value: super::BwApiApiIlaPdsModelsNewIlapdCasesWeekDataDto) -> Self {
            Self {
                ila: Ok(value.ila),
                pd: Ok(value.pd),
                week: Ok(value.week),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiIlaPdsModelsPdZone {
        from_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        to_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiIlaPdsModelsPdZone {
        fn default() -> Self {
            Self {
                from_date: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                to_date: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiIlaPdsModelsPdZone {
        pub fn from_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_date: {}", e)
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn to_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_date: {}", e)
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiIlaPdsModelsPdZone>
    for super::BwApiApiIlaPdsModelsPdZone {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiIlaPdsModelsPdZone,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                from_date: value.from_date?,
                geometry: value.geometry?,
                id: value.id?,
                to_date: value.to_date?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiIlaPdsModelsPdZone>
    for BwApiApiIlaPdsModelsPdZone {
        fn from(value: super::BwApiApiIlaPdsModelsPdZone) -> Self {
            Self {
                from_date: Ok(value.from_date),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                to_date: Ok(value.to_date),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiLicereportModelsLiceReportCleanerFish {
        cleaner_fish_detail: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiLicereportModelsLiceReportCleanerFishDetail>,
            ::std::string::String,
        >,
        entire_locality: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiLicereportModelsLiceReportCleanerFish {
        fn default() -> Self {
            Self {
                cleaner_fish_detail: Ok(Default::default()),
                entire_locality: Ok(Default::default()),
                id: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiLicereportModelsLiceReportCleanerFish {
        pub fn cleaner_fish_detail<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiLicereportModelsLiceReportCleanerFishDetail,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.cleaner_fish_detail = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for cleaner_fish_detail: {}", e
                    )
                });
            self
        }
        pub fn entire_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.entire_locality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for entire_locality: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiLicereportModelsLiceReportCleanerFish>
    for super::BwApiApiLicereportModelsLiceReportCleanerFish {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiLicereportModelsLiceReportCleanerFish,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                cleaner_fish_detail: value.cleaner_fish_detail?,
                entire_locality: value.entire_locality?,
                id: value.id?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiLicereportModelsLiceReportCleanerFish>
    for BwApiApiLicereportModelsLiceReportCleanerFish {
        fn from(value: super::BwApiApiLicereportModelsLiceReportCleanerFish) -> Self {
            Self {
                cleaner_fish_detail: Ok(value.cleaner_fish_detail),
                entire_locality: Ok(value.entire_locality),
                id: Ok(value.id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiLicereportModelsLiceReportCleanerFishDetail {
        id: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        quantity: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        species: ::std::result::Result<
            ::std::option::Option<super::BwApiApiLicereportModelsLiceReportSpecies>,
            ::std::string::String,
        >,
        species_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiLicereportModelsLiceReportCleanerFishDetail {
        fn default() -> Self {
            Self {
                id: Ok(Default::default()),
                quantity: Ok(Default::default()),
                species: Ok(Default::default()),
                species_id: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiLicereportModelsLiceReportCleanerFishDetail {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn quantity<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.quantity = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for quantity: {}", e)
                });
            self
        }
        pub fn species<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::BwApiApiLicereportModelsLiceReportSpecies>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.species = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for species: {}", e)
                });
            self
        }
        pub fn species_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.species_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for species_id: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiLicereportModelsLiceReportCleanerFishDetail>
    for super::BwApiApiLicereportModelsLiceReportCleanerFishDetail {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiLicereportModelsLiceReportCleanerFishDetail,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                quantity: value.quantity?,
                species: value.species?,
                species_id: value.species_id?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiLicereportModelsLiceReportCleanerFishDetail>
    for BwApiApiLicereportModelsLiceReportCleanerFishDetail {
        fn from(
            value: super::BwApiApiLicereportModelsLiceReportCleanerFishDetail,
        ) -> Self {
            Self {
                id: Ok(value.id),
                quantity: Ok(value.quantity),
                species: Ok(value.species),
                species_id: Ok(value.species_id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiLicereportModelsLiceReportCombinationTreatment {
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        lice_report_id: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        medicinal_treatments: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiLicereportModelsLiceReportMedicinalTreatment>,
            ::std::string::String,
        >,
        non_medicinal_treatments: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
            >,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiLicereportModelsLiceReportCombinationTreatment {
        fn default() -> Self {
            Self {
                id: Ok(Default::default()),
                lice_report_id: Ok(Default::default()),
                medicinal_treatments: Ok(Default::default()),
                non_medicinal_treatments: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiLicereportModelsLiceReportCombinationTreatment {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn lice_report_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.lice_report_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for lice_report_id: {}", e)
                });
            self
        }
        pub fn medicinal_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiLicereportModelsLiceReportMedicinalTreatment,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.medicinal_treatments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for medicinal_treatments: {}", e
                    )
                });
            self
        }
        pub fn non_medicinal_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.non_medicinal_treatments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for non_medicinal_treatments: {}",
                        e
                    )
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiLicereportModelsLiceReportCombinationTreatment>
    for super::BwApiApiLicereportModelsLiceReportCombinationTreatment {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiLicereportModelsLiceReportCombinationTreatment,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                lice_report_id: value.lice_report_id?,
                medicinal_treatments: value.medicinal_treatments?,
                non_medicinal_treatments: value.non_medicinal_treatments?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiLicereportModelsLiceReportCombinationTreatment,
    > for BwApiApiLicereportModelsLiceReportCombinationTreatment {
        fn from(
            value: super::BwApiApiLicereportModelsLiceReportCombinationTreatment,
        ) -> Self {
            Self {
                id: Ok(value.id),
                lice_report_id: Ok(value.lice_report_id),
                medicinal_treatments: Ok(value.medicinal_treatments),
                non_medicinal_treatments: Ok(value.non_medicinal_treatments),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiLicereportModelsLiceReportMechanicalRemoval {
        entire_locality: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        method: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiLicereportModelsLiceReportMechanicalRemoval {
        fn default() -> Self {
            Self {
                entire_locality: Ok(Default::default()),
                id: Ok(Default::default()),
                method: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiLicereportModelsLiceReportMechanicalRemoval {
        pub fn entire_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.entire_locality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for entire_locality: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for method: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiLicereportModelsLiceReportMechanicalRemoval>
    for super::BwApiApiLicereportModelsLiceReportMechanicalRemoval {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiLicereportModelsLiceReportMechanicalRemoval,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                entire_locality: value.entire_locality?,
                id: value.id?,
                method: value.method?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiLicereportModelsLiceReportMechanicalRemoval>
    for BwApiApiLicereportModelsLiceReportMechanicalRemoval {
        fn from(
            value: super::BwApiApiLicereportModelsLiceReportMechanicalRemoval,
        ) -> Self {
            Self {
                entire_locality: Ok(value.entire_locality),
                id: Ok(value.id),
                method: Ok(value.method),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiLicereportModelsLiceReportMedicinalTreatment {
        amount_unit: ::std::result::Result<
            ::std::option::Option<super::BwApiApiLicereportModelsLiceReportAmountUnit>,
            ::std::string::String,
        >,
        amount_value: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        concentration_unit: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiLicereportModelsLiceReportConcentrationUnit,
            >,
            ::std::string::String,
        >,
        concentration_value: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        done_before_lice_count: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        entire_locality: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        number_of_cages: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        other_substance: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        substance_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiLicereportModelsLiceReportMedicinalTreatmentType,
            >,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiLicereportModelsLiceReportMedicinalTreatment {
        fn default() -> Self {
            Self {
                amount_unit: Ok(Default::default()),
                amount_value: Ok(Default::default()),
                concentration_unit: Ok(Default::default()),
                concentration_value: Ok(Default::default()),
                done_before_lice_count: Ok(Default::default()),
                entire_locality: Ok(Default::default()),
                id: Ok(Default::default()),
                number_of_cages: Ok(Default::default()),
                other_substance: Ok(Default::default()),
                substance_id: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiLicereportModelsLiceReportMedicinalTreatment {
        pub fn amount_unit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiLicereportModelsLiceReportAmountUnit,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.amount_unit = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for amount_unit: {}", e)
                });
            self
        }
        pub fn amount_value<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.amount_value = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for amount_value: {}", e)
                });
            self
        }
        pub fn concentration_unit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiLicereportModelsLiceReportConcentrationUnit,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.concentration_unit = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for concentration_unit: {}", e
                    )
                });
            self
        }
        pub fn concentration_value<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.concentration_value = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for concentration_value: {}", e
                    )
                });
            self
        }
        pub fn done_before_lice_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.done_before_lice_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for done_before_lice_count: {}",
                        e
                    )
                });
            self
        }
        pub fn entire_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.entire_locality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for entire_locality: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn number_of_cages<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_cages = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for number_of_cages: {}", e)
                });
            self
        }
        pub fn other_substance<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.other_substance = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for other_substance: {}", e)
                });
            self
        }
        pub fn substance_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.substance_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for substance_id: {}", e)
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiLicereportModelsLiceReportMedicinalTreatmentType,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiLicereportModelsLiceReportMedicinalTreatment>
    for super::BwApiApiLicereportModelsLiceReportMedicinalTreatment {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiLicereportModelsLiceReportMedicinalTreatment,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                amount_unit: value.amount_unit?,
                amount_value: value.amount_value?,
                concentration_unit: value.concentration_unit?,
                concentration_value: value.concentration_value?,
                done_before_lice_count: value.done_before_lice_count?,
                entire_locality: value.entire_locality?,
                id: value.id?,
                number_of_cages: value.number_of_cages?,
                other_substance: value.other_substance?,
                substance_id: value.substance_id?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiLicereportModelsLiceReportMedicinalTreatment,
    > for BwApiApiLicereportModelsLiceReportMedicinalTreatment {
        fn from(
            value: super::BwApiApiLicereportModelsLiceReportMedicinalTreatment,
        ) -> Self {
            Self {
                amount_unit: Ok(value.amount_unit),
                amount_value: Ok(value.amount_value),
                concentration_unit: Ok(value.concentration_unit),
                concentration_value: Ok(value.concentration_value),
                done_before_lice_count: Ok(value.done_before_lice_count),
                entire_locality: Ok(value.entire_locality),
                id: Ok(value.id),
                number_of_cages: Ok(value.number_of_cages),
                other_substance: Ok(value.other_substance),
                substance_id: Ok(value.substance_id),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiLicereportModelsLiceReportNonMedicinalTreatment {
        done_before_lice_count: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        entire_locality: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        number_of_cages: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType,
            >,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiLicereportModelsLiceReportNonMedicinalTreatment {
        fn default() -> Self {
            Self {
                done_before_lice_count: Ok(Default::default()),
                entire_locality: Ok(Default::default()),
                id: Ok(Default::default()),
                number_of_cages: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiLicereportModelsLiceReportNonMedicinalTreatment {
        pub fn done_before_lice_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.done_before_lice_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for done_before_lice_count: {}",
                        e
                    )
                });
            self
        }
        pub fn entire_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.entire_locality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for entire_locality: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn number_of_cages<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_cages = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for number_of_cages: {}", e)
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiLicereportModelsLiceReportNonMedicinalTreatmentType,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiLicereportModelsLiceReportNonMedicinalTreatment>
    for super::BwApiApiLicereportModelsLiceReportNonMedicinalTreatment {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                done_before_lice_count: value.done_before_lice_count?,
                entire_locality: value.entire_locality?,
                id: value.id?,
                number_of_cages: value.number_of_cages?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
    > for BwApiApiLicereportModelsLiceReportNonMedicinalTreatment {
        fn from(
            value: super::BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
        ) -> Self {
            Self {
                done_before_lice_count: Ok(value.done_before_lice_count),
                entire_locality: Ok(value.entire_locality),
                id: Ok(value.id),
                number_of_cages: Ok(value.number_of_cages),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiLicereportModelsLiceReportSpecies {
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiLicereportModelsLiceReportSpecies {
        fn default() -> Self {
            Self {
                id: Ok(Default::default()),
                name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiLicereportModelsLiceReportSpecies {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiLicereportModelsLiceReportSpecies>
    for super::BwApiApiLicereportModelsLiceReportSpecies {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiLicereportModelsLiceReportSpecies,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                name: value.name?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiLicereportModelsLiceReportSpecies>
    for BwApiApiLicereportModelsLiceReportSpecies {
        fn from(value: super::BwApiApiLicereportModelsLiceReportSpecies) -> Self {
            Self {
                id: Ok(value.id),
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiLicereportModelsLiceReportSubstance {
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiLicereportModelsLiceReportSubstance {
        fn default() -> Self {
            Self {
                id: Ok(Default::default()),
                name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiLicereportModelsLiceReportSubstance {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiLicereportModelsLiceReportSubstance>
    for super::BwApiApiLicereportModelsLiceReportSubstance {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiLicereportModelsLiceReportSubstance,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                name: value.name?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiLicereportModelsLiceReportSubstance>
    for BwApiApiLicereportModelsLiceReportSubstance {
        fn from(value: super::BwApiApiLicereportModelsLiceReportSubstance) -> Self {
            Self {
                id: Ok(value.id),
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiLicereportModelsLiceReportTreatment {
        end_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        entire_locality: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        start_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        treatment_detail: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiLicereportModelsLiceReportTreatmentDetail>,
            ::std::string::String,
        >,
        treatment_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiLicereportModelsLiceReportTreatment {
        fn default() -> Self {
            Self {
                end_date: Ok(Default::default()),
                entire_locality: Ok(Default::default()),
                id: Ok(Default::default()),
                start_date: Ok(Default::default()),
                treatment_detail: Ok(Default::default()),
                treatment_type: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiLicereportModelsLiceReportTreatment {
        pub fn end_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.end_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for end_date: {}", e)
                });
            self
        }
        pub fn entire_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.entire_locality = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for entire_locality: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn start_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.start_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for start_date: {}", e)
                });
            self
        }
        pub fn treatment_detail<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiLicereportModelsLiceReportTreatmentDetail>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.treatment_detail = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for treatment_detail: {}", e
                    )
                });
            self
        }
        pub fn treatment_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.treatment_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for treatment_type: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiLicereportModelsLiceReportTreatment>
    for super::BwApiApiLicereportModelsLiceReportTreatment {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiLicereportModelsLiceReportTreatment,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                end_date: value.end_date?,
                entire_locality: value.entire_locality?,
                id: value.id?,
                start_date: value.start_date?,
                treatment_detail: value.treatment_detail?,
                treatment_type: value.treatment_type?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiLicereportModelsLiceReportTreatment>
    for BwApiApiLicereportModelsLiceReportTreatment {
        fn from(value: super::BwApiApiLicereportModelsLiceReportTreatment) -> Self {
            Self {
                end_date: Ok(value.end_date),
                entire_locality: Ok(value.entire_locality),
                id: Ok(value.id),
                start_date: Ok(value.start_date),
                treatment_detail: Ok(value.treatment_detail),
                treatment_type: Ok(value.treatment_type),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiLicereportModelsLiceReportTreatmentDetail {
        concentration: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        quantity: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        substance: ::std::result::Result<
            ::std::option::Option<super::BwApiApiLicereportModelsLiceReportSubstance>,
            ::std::string::String,
        >,
        substance_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiLicereportModelsLiceReportTreatmentDetail {
        fn default() -> Self {
            Self {
                concentration: Ok(Default::default()),
                id: Ok(Default::default()),
                quantity: Ok(Default::default()),
                substance: Ok(Default::default()),
                substance_id: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiLicereportModelsLiceReportTreatmentDetail {
        pub fn concentration<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.concentration = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for concentration: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn quantity<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.quantity = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for quantity: {}", e)
                });
            self
        }
        pub fn substance<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::BwApiApiLicereportModelsLiceReportSubstance>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.substance = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for substance: {}", e)
                });
            self
        }
        pub fn substance_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.substance_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for substance_id: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiLicereportModelsLiceReportTreatmentDetail>
    for super::BwApiApiLicereportModelsLiceReportTreatmentDetail {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiLicereportModelsLiceReportTreatmentDetail,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                concentration: value.concentration?,
                id: value.id?,
                quantity: value.quantity?,
                substance: value.substance?,
                substance_id: value.substance_id?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiLicereportModelsLiceReportTreatmentDetail>
    for BwApiApiLicereportModelsLiceReportTreatmentDetail {
        fn from(
            value: super::BwApiApiLicereportModelsLiceReportTreatmentDetail,
        ) -> Self {
            Self {
                concentration: Ok(value.concentration),
                id: Ok(value.id),
                quantity: Ok(value.quantity),
                substance: Ok(value.substance),
                substance_id: Ok(value.substance_id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiLicereportModelsLocalityWeek {
        avg_adult_female_lice: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        avg_mobile_lice: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        avg_stationary_lice: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        bath_treatments: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiLicereportModelsLiceReportTreatment>,
            ::std::string::String,
        >,
        cleaner_fish: ::std::result::Result<
            ::std::option::Option<super::BwApiApiLicereportModelsLiceReportCleanerFish>,
            ::std::string::String,
        >,
        combination_treatments: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiLicereportModelsLiceReportCombinationTreatment,
            >,
            ::std::string::String,
        >,
        has_bath_treatment: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        has_cleaner_fish_deployed: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        has_in_feed_treatment: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        has_mechanical_removal: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        has_reported_lice: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        has_salmonoids: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        in_feed_treatments: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiLicereportModelsLiceReportTreatment>,
            ::std::string::String,
        >,
        is_fallow: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_slaughter_holding_cage: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i64>,
            ::std::string::String,
        >,
        mechanical_removal: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiLicereportModelsLiceReportMechanicalRemoval,
            >,
            ::std::string::String,
        >,
        medicinal_treatments: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiLicereportModelsLiceReportMedicinalTreatment>,
            ::std::string::String,
        >,
        non_medicinal_treatments: ::std::result::Result<
            ::std::vec::Vec<
                super::BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
            >,
            ::std::string::String,
        >,
        sea_temperature: ::std::result::Result<
            ::std::option::Option<f32>,
            ::std::string::String,
        >,
        time_since_last_chitin_synthesis_inhibitor_treatment: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        version: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiLicereportModelsLocalityWeek {
        fn default() -> Self {
            Self {
                avg_adult_female_lice: Ok(Default::default()),
                avg_mobile_lice: Ok(Default::default()),
                avg_stationary_lice: Ok(Default::default()),
                bath_treatments: Ok(Default::default()),
                cleaner_fish: Ok(Default::default()),
                combination_treatments: Ok(Default::default()),
                has_bath_treatment: Ok(Default::default()),
                has_cleaner_fish_deployed: Ok(Default::default()),
                has_in_feed_treatment: Ok(Default::default()),
                has_mechanical_removal: Ok(Default::default()),
                has_reported_lice: Ok(Default::default()),
                has_salmonoids: Ok(Default::default()),
                id: Ok(Default::default()),
                in_feed_treatments: Ok(Default::default()),
                is_fallow: Ok(Default::default()),
                is_slaughter_holding_cage: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                mechanical_removal: Ok(Default::default()),
                medicinal_treatments: Ok(Default::default()),
                non_medicinal_treatments: Ok(Default::default()),
                sea_temperature: Ok(Default::default()),
                time_since_last_chitin_synthesis_inhibitor_treatment: Ok(
                    Default::default(),
                ),
                version: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiLicereportModelsLocalityWeek {
        pub fn avg_adult_female_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_adult_female_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for avg_adult_female_lice: {}",
                        e
                    )
                });
            self
        }
        pub fn avg_mobile_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_mobile_lice = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for avg_mobile_lice: {}", e)
                });
            self
        }
        pub fn avg_stationary_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.avg_stationary_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for avg_stationary_lice: {}", e
                    )
                });
            self
        }
        pub fn bath_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiLicereportModelsLiceReportTreatment>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.bath_treatments = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for bath_treatments: {}", e)
                });
            self
        }
        pub fn cleaner_fish<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiLicereportModelsLiceReportCleanerFish,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.cleaner_fish = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for cleaner_fish: {}", e)
                });
            self
        }
        pub fn combination_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiLicereportModelsLiceReportCombinationTreatment,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.combination_treatments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for combination_treatments: {}",
                        e
                    )
                });
            self
        }
        pub fn has_bath_treatment<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_bath_treatment = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_bath_treatment: {}", e
                    )
                });
            self
        }
        pub fn has_cleaner_fish_deployed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_cleaner_fish_deployed = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_cleaner_fish_deployed: {}",
                        e
                    )
                });
            self
        }
        pub fn has_in_feed_treatment<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_in_feed_treatment = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_in_feed_treatment: {}",
                        e
                    )
                });
            self
        }
        pub fn has_mechanical_removal<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_mechanical_removal = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_mechanical_removal: {}",
                        e
                    )
                });
            self
        }
        pub fn has_reported_lice<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_reported_lice = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_reported_lice: {}", e
                    )
                });
            self
        }
        pub fn has_salmonoids<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_salmonoids = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for has_salmonoids: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn in_feed_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiLicereportModelsLiceReportTreatment>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.in_feed_treatments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for in_feed_treatments: {}", e
                    )
                });
            self
        }
        pub fn is_fallow<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_fallow = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_fallow: {}", e)
                });
            self
        }
        pub fn is_slaughter_holding_cage<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_slaughter_holding_cage = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_slaughter_holding_cage: {}",
                        e
                    )
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn mechanical_removal<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiLicereportModelsLiceReportMechanicalRemoval,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.mechanical_removal = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for mechanical_removal: {}", e
                    )
                });
            self
        }
        pub fn medicinal_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiLicereportModelsLiceReportMedicinalTreatment,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.medicinal_treatments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for medicinal_treatments: {}", e
                    )
                });
            self
        }
        pub fn non_medicinal_treatments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    super::BwApiApiLicereportModelsLiceReportNonMedicinalTreatment,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.non_medicinal_treatments = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for non_medicinal_treatments: {}",
                        e
                    )
                });
            self
        }
        pub fn sea_temperature<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f32>>,
            T::Error: ::std::fmt::Display,
        {
            self.sea_temperature = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for sea_temperature: {}", e)
                });
            self
        }
        pub fn time_since_last_chitin_synthesis_inhibitor_treatment<T>(
            mut self,
            value: T,
        ) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.time_since_last_chitin_synthesis_inhibitor_treatment = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for time_since_last_chitin_synthesis_inhibitor_treatment: {}",
                        e
                    )
                });
            self
        }
        pub fn version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.version = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for version: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiLicereportModelsLocalityWeek>
    for super::BwApiApiLicereportModelsLocalityWeek {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiLicereportModelsLocalityWeek,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                avg_adult_female_lice: value.avg_adult_female_lice?,
                avg_mobile_lice: value.avg_mobile_lice?,
                avg_stationary_lice: value.avg_stationary_lice?,
                bath_treatments: value.bath_treatments?,
                cleaner_fish: value.cleaner_fish?,
                combination_treatments: value.combination_treatments?,
                has_bath_treatment: value.has_bath_treatment?,
                has_cleaner_fish_deployed: value.has_cleaner_fish_deployed?,
                has_in_feed_treatment: value.has_in_feed_treatment?,
                has_mechanical_removal: value.has_mechanical_removal?,
                has_reported_lice: value.has_reported_lice?,
                has_salmonoids: value.has_salmonoids?,
                id: value.id?,
                in_feed_treatments: value.in_feed_treatments?,
                is_fallow: value.is_fallow?,
                is_slaughter_holding_cage: value.is_slaughter_holding_cage?,
                locality_no: value.locality_no?,
                mechanical_removal: value.mechanical_removal?,
                medicinal_treatments: value.medicinal_treatments?,
                non_medicinal_treatments: value.non_medicinal_treatments?,
                sea_temperature: value.sea_temperature?,
                time_since_last_chitin_synthesis_inhibitor_treatment: value
                    .time_since_last_chitin_synthesis_inhibitor_treatment?,
                version: value.version?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiLicereportModelsLocalityWeek>
    for BwApiApiLicereportModelsLocalityWeek {
        fn from(value: super::BwApiApiLicereportModelsLocalityWeek) -> Self {
            Self {
                avg_adult_female_lice: Ok(value.avg_adult_female_lice),
                avg_mobile_lice: Ok(value.avg_mobile_lice),
                avg_stationary_lice: Ok(value.avg_stationary_lice),
                bath_treatments: Ok(value.bath_treatments),
                cleaner_fish: Ok(value.cleaner_fish),
                combination_treatments: Ok(value.combination_treatments),
                has_bath_treatment: Ok(value.has_bath_treatment),
                has_cleaner_fish_deployed: Ok(value.has_cleaner_fish_deployed),
                has_in_feed_treatment: Ok(value.has_in_feed_treatment),
                has_mechanical_removal: Ok(value.has_mechanical_removal),
                has_reported_lice: Ok(value.has_reported_lice),
                has_salmonoids: Ok(value.has_salmonoids),
                id: Ok(value.id),
                in_feed_treatments: Ok(value.in_feed_treatments),
                is_fallow: Ok(value.is_fallow),
                is_slaughter_holding_cage: Ok(value.is_slaughter_holding_cage),
                locality_no: Ok(value.locality_no),
                mechanical_removal: Ok(value.mechanical_removal),
                medicinal_treatments: Ok(value.medicinal_treatments),
                non_medicinal_treatments: Ok(value.non_medicinal_treatments),
                sea_temperature: Ok(value.sea_temperature),
                time_since_last_chitin_synthesis_inhibitor_treatment: Ok(
                    value.time_since_last_chitin_synthesis_inhibitor_treatment,
                ),
                version: Ok(value.version),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto {
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto {
        fn default() -> Self {
            Self {
                geometry: Ok(Default::default()),
                name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto {
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto>
    for super::BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                geometry: value.geometry?,
                name: value.name?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto>
    for BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto {
        fn from(
            value: super::BwApiApiMaritimeBoundaryModelsMaritimeBoundaryDto,
        ) -> Self {
            Self {
                geometry: Ok(value.geometry),
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiPayoutModelsPayoutModel {
        municipality_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        municipality_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        total_payout: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiPayoutModelsPayoutModel {
        fn default() -> Self {
            Self {
                municipality_name: Ok(Default::default()),
                municipality_number: Ok(Default::default()),
                total_payout: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiPayoutModelsPayoutModel {
        pub fn municipality_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_name = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_name: {}", e
                    )
                });
            self
        }
        pub fn municipality_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_number = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_number: {}", e
                    )
                });
            self
        }
        pub fn total_payout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.total_payout = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for total_payout: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiPayoutModelsPayoutModel>
    for super::BwApiApiPayoutModelsPayoutModel {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiPayoutModelsPayoutModel,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                municipality_name: value.municipality_name?,
                municipality_number: value.municipality_number?,
                total_payout: value.total_payout?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiPayoutModelsPayoutModel>
    for BwApiApiPayoutModelsPayoutModel {
        fn from(value: super::BwApiApiPayoutModelsPayoutModel) -> Self {
            Self {
                municipality_name: Ok(value.municipality_name),
                municipality_number: Ok(value.municipality_number),
                total_payout: Ok(value.total_payout),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiProductionAreasModelsProductionArea {
        colors: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiProductionAreasModelsProductionAreaColor>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiProductionAreasModelsProductionArea {
        fn default() -> Self {
            Self {
                colors: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiProductionAreasModelsProductionArea {
        pub fn colors<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiProductionAreasModelsProductionAreaColor>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.colors = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for colors: {}", e)
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiProductionAreasModelsProductionArea>
    for super::BwApiApiProductionAreasModelsProductionArea {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiProductionAreasModelsProductionArea,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                colors: value.colors?,
                geometry: value.geometry?,
                id: value.id?,
                name: value.name?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiProductionAreasModelsProductionArea>
    for BwApiApiProductionAreasModelsProductionArea {
        fn from(value: super::BwApiApiProductionAreasModelsProductionArea) -> Self {
            Self {
                colors: Ok(value.colors),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiProductionAreasModelsProductionAreaAquaCultureData {
        number_of_broodstock_sites: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        number_of_land_sites: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        number_of_salmonoid_sites: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        number_of_sites: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiProductionAreasModelsProductionAreaAquaCultureData {
        fn default() -> Self {
            Self {
                number_of_broodstock_sites: Ok(Default::default()),
                number_of_land_sites: Ok(Default::default()),
                number_of_salmonoid_sites: Ok(Default::default()),
                number_of_sites: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiProductionAreasModelsProductionAreaAquaCultureData {
        pub fn number_of_broodstock_sites<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_broodstock_sites = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for number_of_broodstock_sites: {}",
                        e
                    )
                });
            self
        }
        pub fn number_of_land_sites<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_land_sites = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for number_of_land_sites: {}", e
                    )
                });
            self
        }
        pub fn number_of_salmonoid_sites<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_salmonoid_sites = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for number_of_salmonoid_sites: {}",
                        e
                    )
                });
            self
        }
        pub fn number_of_sites<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.number_of_sites = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for number_of_sites: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiProductionAreasModelsProductionAreaAquaCultureData,
    > for super::BwApiApiProductionAreasModelsProductionAreaAquaCultureData {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiProductionAreasModelsProductionAreaAquaCultureData,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                number_of_broodstock_sites: value.number_of_broodstock_sites?,
                number_of_land_sites: value.number_of_land_sites?,
                number_of_salmonoid_sites: value.number_of_salmonoid_sites?,
                number_of_sites: value.number_of_sites?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiProductionAreasModelsProductionAreaAquaCultureData,
    > for BwApiApiProductionAreasModelsProductionAreaAquaCultureData {
        fn from(
            value: super::BwApiApiProductionAreasModelsProductionAreaAquaCultureData,
        ) -> Self {
            Self {
                number_of_broodstock_sites: Ok(value.number_of_broodstock_sites),
                number_of_land_sites: Ok(value.number_of_land_sites),
                number_of_salmonoid_sites: Ok(value.number_of_salmonoid_sites),
                number_of_sites: Ok(value.number_of_sites),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiProductionAreasModelsProductionAreaColor {
        color: ::std::result::Result<
            ::std::option::Option<super::BwApiApiProductionAreasModelsColor>,
            ::std::string::String,
        >,
        from_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        to_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiProductionAreasModelsProductionAreaColor {
        fn default() -> Self {
            Self {
                color: Ok(Default::default()),
                from_date: Ok(Default::default()),
                to_date: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiProductionAreasModelsProductionAreaColor {
        pub fn color<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::BwApiApiProductionAreasModelsColor>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.color = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for color: {}", e)
                });
            self
        }
        pub fn from_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_date: {}", e)
                });
            self
        }
        pub fn to_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_date: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiProductionAreasModelsProductionAreaColor>
    for super::BwApiApiProductionAreasModelsProductionAreaColor {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiProductionAreasModelsProductionAreaColor,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                color: value.color?,
                from_date: value.from_date?,
                to_date: value.to_date?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiProductionAreasModelsProductionAreaColor>
    for BwApiApiProductionAreasModelsProductionAreaColor {
        fn from(value: super::BwApiApiProductionAreasModelsProductionAreaColor) -> Self {
            Self {
                color: Ok(value.color),
                from_date: Ok(value.from_date),
                to_date: Ok(value.to_date),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiProductionAreasModelsProductionAreaWeek {
        area: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        current_color: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiProductionAreasModelsProductionAreaColor,
            >,
            ::std::string::String,
        >,
        production_area: ::std::result::Result<
            ::std::option::Option<super::BwApiApiProductionAreasModelsProductionArea>,
            ::std::string::String,
        >,
        production_area_aqua_culture_data: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiProductionAreasModelsProductionAreaAquaCultureData,
            >,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiProductionAreasModelsProductionAreaWeek {
        fn default() -> Self {
            Self {
                area: Ok(Default::default()),
                current_color: Ok(Default::default()),
                production_area: Ok(Default::default()),
                production_area_aqua_culture_data: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiProductionAreasModelsProductionAreaWeek {
        pub fn area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.area = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for area: {}", e));
            self
        }
        pub fn current_color<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiProductionAreasModelsProductionAreaColor,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.current_color = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for current_color: {}", e)
                });
            self
        }
        pub fn production_area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::BwApiApiProductionAreasModelsProductionArea>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.production_area = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for production_area: {}", e)
                });
            self
        }
        pub fn production_area_aqua_culture_data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiProductionAreasModelsProductionAreaAquaCultureData,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.production_area_aqua_culture_data = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for production_area_aqua_culture_data: {}",
                        e
                    )
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiProductionAreasModelsProductionAreaWeek>
    for super::BwApiApiProductionAreasModelsProductionAreaWeek {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiProductionAreasModelsProductionAreaWeek,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                area: value.area?,
                current_color: value.current_color?,
                production_area: value.production_area?,
                production_area_aqua_culture_data: value
                    .production_area_aqua_culture_data?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiProductionAreasModelsProductionAreaWeek>
    for BwApiApiProductionAreasModelsProductionAreaWeek {
        fn from(value: super::BwApiApiProductionAreasModelsProductionAreaWeek) -> Self {
            Self {
                area: Ok(value.area),
                current_color: Ok(value.current_color),
                production_area: Ok(value.production_area),
                production_area_aqua_culture_data: Ok(
                    value.production_area_aqua_culture_data,
                ),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiProtectedAreasModelsProtectedArea {
        cdda_id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        faktaark: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        foerstegang_vernet: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        forvaltningsmyndighet: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        forvaltningsmyndighet_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        geom: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        iucn: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        kommune: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        major_ecosystem_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        naturvern_id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        navn: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        object_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        offisielt_navn: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        revisjon: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        shape_st_area: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        shape_st_length: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        truet_vurdering: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        vernedato: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        verneform: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        verneforskrift: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        verneplan: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiProtectedAreasModelsProtectedArea {
        fn default() -> Self {
            Self {
                cdda_id: Ok(Default::default()),
                faktaark: Ok(Default::default()),
                foerstegang_vernet: Ok(Default::default()),
                forvaltningsmyndighet: Ok(Default::default()),
                forvaltningsmyndighet_type: Ok(Default::default()),
                geom: Ok(Default::default()),
                id: Ok(Default::default()),
                iucn: Ok(Default::default()),
                kommune: Ok(Default::default()),
                major_ecosystem_type: Ok(Default::default()),
                naturvern_id: Ok(Default::default()),
                navn: Ok(Default::default()),
                object_id: Ok(Default::default()),
                offisielt_navn: Ok(Default::default()),
                revisjon: Ok(Default::default()),
                shape_st_area: Ok(Default::default()),
                shape_st_length: Ok(Default::default()),
                truet_vurdering: Ok(Default::default()),
                vernedato: Ok(Default::default()),
                verneform: Ok(Default::default()),
                verneforskrift: Ok(Default::default()),
                verneplan: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiProtectedAreasModelsProtectedArea {
        pub fn cdda_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.cdda_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for cdda_id: {}", e)
                });
            self
        }
        pub fn faktaark<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.faktaark = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for faktaark: {}", e)
                });
            self
        }
        pub fn foerstegang_vernet<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.foerstegang_vernet = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for foerstegang_vernet: {}", e
                    )
                });
            self
        }
        pub fn forvaltningsmyndighet<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forvaltningsmyndighet = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for forvaltningsmyndighet: {}",
                        e
                    )
                });
            self
        }
        pub fn forvaltningsmyndighet_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.forvaltningsmyndighet_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for forvaltningsmyndighet_type: {}",
                        e
                    )
                });
            self
        }
        pub fn geom<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geom = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for geom: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn iucn<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.iucn = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for iucn: {}", e));
            self
        }
        pub fn kommune<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.kommune = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for kommune: {}", e)
                });
            self
        }
        pub fn major_ecosystem_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.major_ecosystem_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for major_ecosystem_type: {}", e
                    )
                });
            self
        }
        pub fn naturvern_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.naturvern_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for naturvern_id: {}", e)
                });
            self
        }
        pub fn navn<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.navn = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for navn: {}", e));
            self
        }
        pub fn object_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.object_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for object_id: {}", e)
                });
            self
        }
        pub fn offisielt_navn<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.offisielt_navn = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for offisielt_navn: {}", e)
                });
            self
        }
        pub fn revisjon<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.revisjon = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for revisjon: {}", e)
                });
            self
        }
        pub fn shape_st_area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.shape_st_area = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for shape_st_area: {}", e)
                });
            self
        }
        pub fn shape_st_length<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.shape_st_length = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for shape_st_length: {}", e)
                });
            self
        }
        pub fn truet_vurdering<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.truet_vurdering = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for truet_vurdering: {}", e)
                });
            self
        }
        pub fn vernedato<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.vernedato = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for vernedato: {}", e)
                });
            self
        }
        pub fn verneform<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.verneform = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for verneform: {}", e)
                });
            self
        }
        pub fn verneforskrift<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.verneforskrift = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for verneforskrift: {}", e)
                });
            self
        }
        pub fn verneplan<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.verneplan = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for verneplan: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiProtectedAreasModelsProtectedArea>
    for super::BwApiApiProtectedAreasModelsProtectedArea {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiProtectedAreasModelsProtectedArea,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                cdda_id: value.cdda_id?,
                faktaark: value.faktaark?,
                foerstegang_vernet: value.foerstegang_vernet?,
                forvaltningsmyndighet: value.forvaltningsmyndighet?,
                forvaltningsmyndighet_type: value.forvaltningsmyndighet_type?,
                geom: value.geom?,
                id: value.id?,
                iucn: value.iucn?,
                kommune: value.kommune?,
                major_ecosystem_type: value.major_ecosystem_type?,
                naturvern_id: value.naturvern_id?,
                navn: value.navn?,
                object_id: value.object_id?,
                offisielt_navn: value.offisielt_navn?,
                revisjon: value.revisjon?,
                shape_st_area: value.shape_st_area?,
                shape_st_length: value.shape_st_length?,
                truet_vurdering: value.truet_vurdering?,
                vernedato: value.vernedato?,
                verneform: value.verneform?,
                verneforskrift: value.verneforskrift?,
                verneplan: value.verneplan?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiProtectedAreasModelsProtectedArea>
    for BwApiApiProtectedAreasModelsProtectedArea {
        fn from(value: super::BwApiApiProtectedAreasModelsProtectedArea) -> Self {
            Self {
                cdda_id: Ok(value.cdda_id),
                faktaark: Ok(value.faktaark),
                foerstegang_vernet: Ok(value.foerstegang_vernet),
                forvaltningsmyndighet: Ok(value.forvaltningsmyndighet),
                forvaltningsmyndighet_type: Ok(value.forvaltningsmyndighet_type),
                geom: Ok(value.geom),
                id: Ok(value.id),
                iucn: Ok(value.iucn),
                kommune: Ok(value.kommune),
                major_ecosystem_type: Ok(value.major_ecosystem_type),
                naturvern_id: Ok(value.naturvern_id),
                navn: Ok(value.navn),
                object_id: Ok(value.object_id),
                offisielt_navn: Ok(value.offisielt_navn),
                revisjon: Ok(value.revisjon),
                shape_st_area: Ok(value.shape_st_area),
                shape_st_length: Ok(value.shape_st_length),
                truet_vurdering: Ok(value.truet_vurdering),
                vernedato: Ok(value.vernedato),
                verneform: Ok(value.verneform),
                verneforskrift: Ok(value.verneforskrift),
                verneplan: Ok(value.verneplan),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiRiverCatchModelsRiverCatchModel {
        catch: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        number: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        river: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        species: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiRiverCatchModelsRiverCatchModel {
        fn default() -> Self {
            Self {
                catch: Ok(Default::default()),
                number: Ok(Default::default()),
                river: Ok(Default::default()),
                species: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiRiverCatchModelsRiverCatchModel {
        pub fn catch<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.catch = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for catch: {}", e)
                });
            self
        }
        pub fn number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.number = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for number: {}", e)
                });
            self
        }
        pub fn river<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.river = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for river: {}", e)
                });
            self
        }
        pub fn species<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.species = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for species: {}", e)
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiRiverCatchModelsRiverCatchModel>
    for super::BwApiApiRiverCatchModelsRiverCatchModel {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiRiverCatchModelsRiverCatchModel,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                catch: value.catch?,
                number: value.number?,
                river: value.river?,
                species: value.species?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiRiverCatchModelsRiverCatchModel>
    for BwApiApiRiverCatchModelsRiverCatchModel {
        fn from(value: super::BwApiApiRiverCatchModelsRiverCatchModel) -> Self {
            Self {
                catch: Ok(value.catch),
                number: Ok(value.number),
                river: Ok(value.river),
                species: Ok(value.species),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiSalmonFjordModelsSalmonFjordDto {
        border_point: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        place_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        region: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiSalmonFjordModelsSalmonFjordDto {
        fn default() -> Self {
            Self {
                border_point: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                place_name: Ok(Default::default()),
                region: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiSalmonFjordModelsSalmonFjordDto {
        pub fn border_point<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.border_point = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for border_point: {}", e)
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn place_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.place_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for place_name: {}", e)
                });
            self
        }
        pub fn region<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.region = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for region: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiSalmonFjordModelsSalmonFjordDto>
    for super::BwApiApiSalmonFjordModelsSalmonFjordDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiSalmonFjordModelsSalmonFjordDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                border_point: value.border_point?,
                geometry: value.geometry?,
                id: value.id?,
                place_name: value.place_name?,
                region: value.region?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiSalmonFjordModelsSalmonFjordDto>
    for BwApiApiSalmonFjordModelsSalmonFjordDto {
        fn from(value: super::BwApiApiSalmonFjordModelsSalmonFjordDto) -> Self {
            Self {
                border_point: Ok(value.border_point),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                place_name: Ok(value.place_name),
                region: Ok(value.region),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount {
        count: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount {
        fn default() -> Self {
            Self {
                count: Ok(Default::default()),
                week: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount {
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount>
    for super::BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                count: value.count?,
                week: value.week?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount>
    for BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount {
        fn from(value: super::BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount) -> Self {
            Self {
                count: Ok(value.count),
                week: Ok(value.week),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto {
        included_localities_above_lice_limit_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        localities_above_lice_limit_count: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount>,
            ::std::string::String,
        >,
        total_localities_above_lice_limit_count: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto {
        fn default() -> Self {
            Self {
                included_localities_above_lice_limit_count: Ok(Default::default()),
                localities_above_lice_limit_count: Ok(Default::default()),
                total_localities_above_lice_limit_count: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto {
        pub fn included_localities_above_lice_limit_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.included_localities_above_lice_limit_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for included_localities_above_lice_limit_count: {}",
                        e
                    )
                });
            self
        }
        pub fn localities_above_lice_limit_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiSalmonLiceLocalitiesAboveLiceLimitCount>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.localities_above_lice_limit_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for localities_above_lice_limit_count: {}",
                        e
                    )
                });
            self
        }
        pub fn total_localities_above_lice_limit_count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.total_localities_above_lice_limit_count = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for total_localities_above_lice_limit_count: {}",
                        e
                    )
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto>
    for super::BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                included_localities_above_lice_limit_count: value
                    .included_localities_above_lice_limit_count?,
                localities_above_lice_limit_count: value
                    .localities_above_lice_limit_count?,
                total_localities_above_lice_limit_count: value
                    .total_localities_above_lice_limit_count?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto,
    > for BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto {
        fn from(
            value: super::BwApiApiSalmonLiceLocalitiesAboveLiceLimitGraphDataDto,
        ) -> Self {
            Self {
                included_localities_above_lice_limit_count: Ok(
                    value.included_localities_above_lice_limit_count,
                ),
                localities_above_lice_limit_count: Ok(
                    value.localities_above_lice_limit_count,
                ),
                total_localities_above_lice_limit_count: Ok(
                    value.total_localities_above_lice_limit_count,
                ),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiSalmonRiversModelsSalmonRiver {
        alternative_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        is_national_salmon_river: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        municipality_id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        municipality_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        production_area_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        production_area_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        river_catch: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiRiverCatchModelsRiverCatchModel>,
            ::std::string::String,
        >,
        river_id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        river_mouth_location: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiSalmonRiversModelsSalmonRiver {
        fn default() -> Self {
            Self {
                alternative_name: Ok(Default::default()),
                geometry: Ok(Default::default()),
                is_national_salmon_river: Ok(Default::default()),
                municipality_id: Ok(Default::default()),
                municipality_name: Ok(Default::default()),
                name: Ok(Default::default()),
                production_area_id: Ok(Default::default()),
                production_area_name: Ok(Default::default()),
                river_catch: Ok(Default::default()),
                river_id: Ok(Default::default()),
                river_mouth_location: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiSalmonRiversModelsSalmonRiver {
        pub fn alternative_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.alternative_name = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for alternative_name: {}", e
                    )
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn is_national_salmon_river<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_national_salmon_river = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_national_salmon_river: {}",
                        e
                    )
                });
            self
        }
        pub fn municipality_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for municipality_id: {}", e)
                });
            self
        }
        pub fn municipality_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.municipality_name = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for municipality_name: {}", e
                    )
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn production_area_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.production_area_id = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for production_area_id: {}", e
                    )
                });
            self
        }
        pub fn production_area_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.production_area_name = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for production_area_name: {}", e
                    )
                });
            self
        }
        pub fn river_catch<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiRiverCatchModelsRiverCatchModel>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.river_catch = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for river_catch: {}", e)
                });
            self
        }
        pub fn river_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.river_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for river_id: {}", e)
                });
            self
        }
        pub fn river_mouth_location<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.river_mouth_location = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for river_mouth_location: {}", e
                    )
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiSalmonRiversModelsSalmonRiver>
    for super::BwApiApiSalmonRiversModelsSalmonRiver {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiSalmonRiversModelsSalmonRiver,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                alternative_name: value.alternative_name?,
                geometry: value.geometry?,
                is_national_salmon_river: value.is_national_salmon_river?,
                municipality_id: value.municipality_id?,
                municipality_name: value.municipality_name?,
                name: value.name?,
                production_area_id: value.production_area_id?,
                production_area_name: value.production_area_name?,
                river_catch: value.river_catch?,
                river_id: value.river_id?,
                river_mouth_location: value.river_mouth_location?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiSalmonRiversModelsSalmonRiver>
    for BwApiApiSalmonRiversModelsSalmonRiver {
        fn from(value: super::BwApiApiSalmonRiversModelsSalmonRiver) -> Self {
            Self {
                alternative_name: Ok(value.alternative_name),
                geometry: Ok(value.geometry),
                is_national_salmon_river: Ok(value.is_national_salmon_river),
                municipality_id: Ok(value.municipality_id),
                municipality_name: Ok(value.municipality_name),
                name: Ok(value.name),
                production_area_id: Ok(value.production_area_id),
                production_area_name: Ok(value.production_area_name),
                river_catch: Ok(value.river_catch),
                river_id: Ok(value.river_id),
                river_mouth_location: Ok(value.river_mouth_location),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiShellSandAreaModelsShellSandAreaModel {
        area_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        area_size: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesPolygon>,
            ::std::string::String,
        >,
        info_url: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        object_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        registered_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        value: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiShellSandAreaModelsShellSandAreaModel {
        fn default() -> Self {
            Self {
                area_name: Ok(Default::default()),
                area_size: Ok(Default::default()),
                geometry: Ok(Default::default()),
                info_url: Ok(Default::default()),
                object_id: Ok(Default::default()),
                registered_date: Ok(Default::default()),
                value: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiShellSandAreaModelsShellSandAreaModel {
        pub fn area_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.area_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for area_name: {}", e)
                });
            self
        }
        pub fn area_size<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.area_size = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for area_size: {}", e)
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesPolygon>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn info_url<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.info_url = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for info_url: {}", e)
                });
            self
        }
        pub fn object_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.object_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for object_id: {}", e)
                });
            self
        }
        pub fn registered_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.registered_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for registered_date: {}", e)
                });
            self
        }
        pub fn value<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.value = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for value: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiShellSandAreaModelsShellSandAreaModel>
    for super::BwApiApiShellSandAreaModelsShellSandAreaModel {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiShellSandAreaModelsShellSandAreaModel,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                area_name: value.area_name?,
                area_size: value.area_size?,
                geometry: value.geometry?,
                info_url: value.info_url?,
                object_id: value.object_id?,
                registered_date: value.registered_date?,
                value: value.value?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiShellSandAreaModelsShellSandAreaModel>
    for BwApiApiShellSandAreaModelsShellSandAreaModel {
        fn from(value: super::BwApiApiShellSandAreaModelsShellSandAreaModel) -> Self {
            Self {
                area_name: Ok(value.area_name),
                area_size: Ok(value.area_size),
                geometry: Ok(value.geometry),
                info_url: Ok(value.info_url),
                object_id: Ok(value.object_id),
                registered_date: Ok(value.registered_date),
                value: Ok(value.value),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto {
        date: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        placename: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        updated_date: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto {
        fn default() -> Self {
            Self {
                date: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                placename: Ok(Default::default()),
                updated_date: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto {
        pub fn date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.date = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for date: {}", e));
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn placename<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.placename = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for placename: {}", e)
                });
            self
        }
        pub fn updated_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.updated_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for updated_date: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<
        BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto,
    > for super::BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                date: value.date?,
                geometry: value.geometry?,
                id: value.id?,
                placename: value.placename?,
                updated_date: value.updated_date?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto,
    > for BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto {
        fn from(
            value: super::BwApiApiShrimpFishingGroundsModelsDtoShrimpFishingGroundDto,
        ) -> Self {
            Self {
                date: Ok(value.date),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                placename: Ok(value.placename),
                updated_date: Ok(value.updated_date),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiSlaughterhouseModelsSlaughterhouseDetails {
        ila_protection_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsIlaControlAreaDto>,
            ::std::string::String,
        >,
        ila_surveillance_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsIlaControlAreaDto>,
            ::std::string::String,
        >,
        licenses: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiSlaughterhouseModelsSlaughterhouseLicense>,
            ::std::string::String,
        >,
        pd_protection_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsPdControlAreaDto>,
            ::std::string::String,
        >,
        pd_surveillance_zones: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiControlAreasModelsPdControlAreaDto>,
            ::std::string::String,
        >,
        pd_zone_id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        slaughterhouse_locality: ::std::result::Result<
            ::std::option::Option<
                super::BwApiApiSlaughterhouseModelsSlaughterhouseLocality,
            >,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiSlaughterhouseModelsSlaughterhouseDetails {
        fn default() -> Self {
            Self {
                ila_protection_zones: Ok(Default::default()),
                ila_surveillance_zones: Ok(Default::default()),
                licenses: Ok(Default::default()),
                pd_protection_zones: Ok(Default::default()),
                pd_surveillance_zones: Ok(Default::default()),
                pd_zone_id: Ok(Default::default()),
                slaughterhouse_locality: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiSlaughterhouseModelsSlaughterhouseDetails {
        pub fn ila_protection_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsIlaControlAreaDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ila_protection_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ila_protection_zones: {}", e
                    )
                });
            self
        }
        pub fn ila_surveillance_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsIlaControlAreaDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ila_surveillance_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ila_surveillance_zones: {}",
                        e
                    )
                });
            self
        }
        pub fn licenses<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiSlaughterhouseModelsSlaughterhouseLicense>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.licenses = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for licenses: {}", e)
                });
            self
        }
        pub fn pd_protection_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsPdControlAreaDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.pd_protection_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for pd_protection_zones: {}", e
                    )
                });
            self
        }
        pub fn pd_surveillance_zones<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiControlAreasModelsPdControlAreaDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.pd_surveillance_zones = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for pd_surveillance_zones: {}",
                        e
                    )
                });
            self
        }
        pub fn pd_zone_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.pd_zone_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for pd_zone_id: {}", e)
                });
            self
        }
        pub fn slaughterhouse_locality<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiSlaughterhouseModelsSlaughterhouseLocality,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.slaughterhouse_locality = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for slaughterhouse_locality: {}",
                        e
                    )
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiSlaughterhouseModelsSlaughterhouseDetails>
    for super::BwApiApiSlaughterhouseModelsSlaughterhouseDetails {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiSlaughterhouseModelsSlaughterhouseDetails,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                ila_protection_zones: value.ila_protection_zones?,
                ila_surveillance_zones: value.ila_surveillance_zones?,
                licenses: value.licenses?,
                pd_protection_zones: value.pd_protection_zones?,
                pd_surveillance_zones: value.pd_surveillance_zones?,
                pd_zone_id: value.pd_zone_id?,
                slaughterhouse_locality: value.slaughterhouse_locality?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiSlaughterhouseModelsSlaughterhouseDetails>
    for BwApiApiSlaughterhouseModelsSlaughterhouseDetails {
        fn from(
            value: super::BwApiApiSlaughterhouseModelsSlaughterhouseDetails,
        ) -> Self {
            Self {
                ila_protection_zones: Ok(value.ila_protection_zones),
                ila_surveillance_zones: Ok(value.ila_surveillance_zones),
                licenses: Ok(value.licenses),
                pd_protection_zones: Ok(value.pd_protection_zones),
                pd_surveillance_zones: Ok(value.pd_surveillance_zones),
                pd_zone_id: Ok(value.pd_zone_id),
                slaughterhouse_locality: Ok(value.slaughterhouse_locality),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiSlaughterhouseModelsSlaughterhouseLicense {
        production_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        valid_from: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        valid_to: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiSlaughterhouseModelsSlaughterhouseLicense {
        fn default() -> Self {
            Self {
                production_type: Ok(Default::default()),
                valid_from: Ok(Default::default()),
                valid_to: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiSlaughterhouseModelsSlaughterhouseLicense {
        pub fn production_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.production_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for production_type: {}", e)
                });
            self
        }
        pub fn valid_from<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.valid_from = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for valid_from: {}", e)
                });
            self
        }
        pub fn valid_to<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.valid_to = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for valid_to: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiSlaughterhouseModelsSlaughterhouseLicense>
    for super::BwApiApiSlaughterhouseModelsSlaughterhouseLicense {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiSlaughterhouseModelsSlaughterhouseLicense,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                production_type: value.production_type?,
                valid_from: value.valid_from?,
                valid_to: value.valid_to?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiSlaughterhouseModelsSlaughterhouseLicense>
    for BwApiApiSlaughterhouseModelsSlaughterhouseLicense {
        fn from(
            value: super::BwApiApiSlaughterhouseModelsSlaughterhouseLicense,
        ) -> Self {
            Self {
                production_type: Ok(value.production_type),
                valid_from: Ok(value.valid_from),
                valid_to: Ok(value.valid_to),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiSlaughterhouseModelsSlaughterhouseLocality {
        approval_number: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        company: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        establishment: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        valid_from: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        valid_to: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiSlaughterhouseModelsSlaughterhouseLocality {
        fn default() -> Self {
            Self {
                approval_number: Ok(Default::default()),
                company: Ok(Default::default()),
                establishment: Ok(Default::default()),
                geometry: Ok(Default::default()),
                id: Ok(Default::default()),
                valid_from: Ok(Default::default()),
                valid_to: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiSlaughterhouseModelsSlaughterhouseLocality {
        pub fn approval_number<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.approval_number = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for approval_number: {}", e)
                });
            self
        }
        pub fn company<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.company = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for company: {}", e)
                });
            self
        }
        pub fn establishment<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.establishment = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for establishment: {}", e)
                });
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn valid_from<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.valid_from = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for valid_from: {}", e)
                });
            self
        }
        pub fn valid_to<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.valid_to = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for valid_to: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiSlaughterhouseModelsSlaughterhouseLocality>
    for super::BwApiApiSlaughterhouseModelsSlaughterhouseLocality {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiSlaughterhouseModelsSlaughterhouseLocality,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                approval_number: value.approval_number?,
                company: value.company?,
                establishment: value.establishment?,
                geometry: value.geometry?,
                id: value.id?,
                valid_from: value.valid_from?,
                valid_to: value.valid_to?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiSlaughterhouseModelsSlaughterhouseLocality>
    for BwApiApiSlaughterhouseModelsSlaughterhouseLocality {
        fn from(
            value: super::BwApiApiSlaughterhouseModelsSlaughterhouseLocality,
        ) -> Self {
            Self {
                approval_number: Ok(value.approval_number),
                company: Ok(value.company),
                establishment: Ok(value.establishment),
                geometry: Ok(value.geometry),
                id: Ok(value.id),
                valid_from: Ok(value.valid_from),
                valid_to: Ok(value.valid_to),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiVesselTrackWeeksModelsDisease {
        disease_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        from_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        ruling: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        to_date: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsDisease {
        fn default() -> Self {
            Self {
                disease_name: Ok(Default::default()),
                from_date: Ok(Default::default()),
                ruling: Ok(Default::default()),
                to_date: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiVesselTrackWeeksModelsDisease {
        pub fn disease_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.disease_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disease_name: {}", e)
                });
            self
        }
        pub fn from_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_date: {}", e)
                });
            self
        }
        pub fn ruling<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ruling = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ruling: {}", e)
                });
            self
        }
        pub fn to_date<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_date = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_date: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiVesselTrackWeeksModelsDisease>
    for super::BwApiApiVesselTrackWeeksModelsDisease {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiVesselTrackWeeksModelsDisease,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                disease_name: value.disease_name?,
                from_date: value.from_date?,
                ruling: value.ruling?,
                to_date: value.to_date?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiVesselTrackWeeksModelsDisease>
    for BwApiApiVesselTrackWeeksModelsDisease {
        fn from(value: super::BwApiApiVesselTrackWeeksModelsDisease) -> Self {
            Self {
                disease_name: Ok(value.disease_name),
                from_date: Ok(value.from_date),
                ruling: Ok(value.ruling),
                to_date: Ok(value.to_date),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit {
        disease_zone_id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        disease_zone_type: ::std::result::Result<
            ::std::option::Option<super::BwApiApiVesselTrackWeeksModelsDiseaseZoneType>,
            ::std::string::String,
        >,
        from_point: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        from_time: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        to_point: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        to_time: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit {
        fn default() -> Self {
            Self {
                disease_zone_id: Ok(Default::default()),
                disease_zone_type: Ok(Default::default()),
                from_point: Ok(Default::default()),
                from_time: Ok(Default::default()),
                to_point: Ok(Default::default()),
                to_time: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit {
        pub fn disease_zone_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.disease_zone_id = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for disease_zone_id: {}", e)
                });
            self
        }
        pub fn disease_zone_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::BwApiApiVesselTrackWeeksModelsDiseaseZoneType,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.disease_zone_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for disease_zone_type: {}", e
                    )
                });
            self
        }
        pub fn from_point<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.from_point = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_point: {}", e)
                });
            self
        }
        pub fn from_time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_time = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_time: {}", e)
                });
            self
        }
        pub fn to_point<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.to_point = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_point: {}", e)
                });
            self
        }
        pub fn to_time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_time = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_time: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit>
    for super::BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                disease_zone_id: value.disease_zone_id?,
                disease_zone_type: value.disease_zone_type?,
                from_point: value.from_point?,
                from_time: value.from_time?,
                to_point: value.to_point?,
                to_time: value.to_time?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit>
    for BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit {
        fn from(value: super::BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit) -> Self {
            Self {
                disease_zone_id: Ok(value.disease_zone_id),
                disease_zone_type: Ok(value.disease_zone_type),
                from_point: Ok(value.from_point),
                from_time: Ok(value.from_time),
                to_point: Ok(value.to_point),
                to_time: Ok(value.to_time),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiVesselTrackWeeksModelsTrackAnalysis {
        disease_zone_visits: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit>,
            ::std::string::String,
        >,
        has_disease_zone_visits_analysis: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        is_based_on_surface_area: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        locality_waypoints: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint>,
            ::std::string::String,
        >,
        vessel_track_week_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsTrackAnalysis {
        fn default() -> Self {
            Self {
                disease_zone_visits: Ok(Default::default()),
                has_disease_zone_visits_analysis: Ok(Default::default()),
                id: Ok(Default::default()),
                is_based_on_surface_area: Ok(Default::default()),
                locality_waypoints: Ok(Default::default()),
                vessel_track_week_id: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiVesselTrackWeeksModelsTrackAnalysis {
        pub fn disease_zone_visits<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiVesselTrackWeeksModelsDiseaseZoneVisit>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.disease_zone_visits = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for disease_zone_visits: {}", e
                    )
                });
            self
        }
        pub fn has_disease_zone_visits_analysis<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_disease_zone_visits_analysis = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for has_disease_zone_visits_analysis: {}",
                        e
                    )
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn is_based_on_surface_area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_based_on_surface_area = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_based_on_surface_area: {}",
                        e
                    )
                });
            self
        }
        pub fn locality_waypoints<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.locality_waypoints = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for locality_waypoints: {}", e
                    )
                });
            self
        }
        pub fn vessel_track_week_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.vessel_track_week_id = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for vessel_track_week_id: {}", e
                    )
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiVesselTrackWeeksModelsTrackAnalysis>
    for super::BwApiApiVesselTrackWeeksModelsTrackAnalysis {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiVesselTrackWeeksModelsTrackAnalysis,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                disease_zone_visits: value.disease_zone_visits?,
                has_disease_zone_visits_analysis: value
                    .has_disease_zone_visits_analysis?,
                id: value.id?,
                is_based_on_surface_area: value.is_based_on_surface_area?,
                locality_waypoints: value.locality_waypoints?,
                vessel_track_week_id: value.vessel_track_week_id?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiVesselTrackWeeksModelsTrackAnalysis>
    for BwApiApiVesselTrackWeeksModelsTrackAnalysis {
        fn from(value: super::BwApiApiVesselTrackWeeksModelsTrackAnalysis) -> Self {
            Self {
                disease_zone_visits: Ok(value.disease_zone_visits),
                has_disease_zone_visits_analysis: Ok(
                    value.has_disease_zone_visits_analysis,
                ),
                id: Ok(value.id),
                is_based_on_surface_area: Ok(value.is_based_on_surface_area),
                locality_waypoints: Ok(value.locality_waypoints),
                vessel_track_week_id: Ok(value.vessel_track_week_id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiVesselTrackWeeksModelsVesselInfo {
        is_slaughter_boat: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_wellboat: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        mmsi: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        ship_register_vessel_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_register_vessel_type_name_en: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_register_vessel_type_name_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_type: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        vessel_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselInfo {
        fn default() -> Self {
            Self {
                is_slaughter_boat: Ok(Default::default()),
                is_wellboat: Ok(Default::default()),
                mmsi: Ok(Default::default()),
                ship_register_vessel_type: Ok(Default::default()),
                ship_register_vessel_type_name_en: Ok(Default::default()),
                ship_register_vessel_type_name_no: Ok(Default::default()),
                ship_type: Ok(Default::default()),
                vessel_name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiVesselTrackWeeksModelsVesselInfo {
        pub fn is_slaughter_boat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_slaughter_boat = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_slaughter_boat: {}", e
                    )
                });
            self
        }
        pub fn is_wellboat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_wellboat = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_wellboat: {}", e)
                });
            self
        }
        pub fn mmsi<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.mmsi = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mmsi: {}", e));
            self
        }
        pub fn ship_register_vessel_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_register_vessel_type_name_en<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type_name_en = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type_name_en: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_register_vessel_type_name_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type_name_no = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type_name_no: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ship_type: {}", e)
                });
            self
        }
        pub fn vessel_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.vessel_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for vessel_name: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiVesselTrackWeeksModelsVesselInfo>
    for super::BwApiApiVesselTrackWeeksModelsVesselInfo {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiVesselTrackWeeksModelsVesselInfo,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                is_slaughter_boat: value.is_slaughter_boat?,
                is_wellboat: value.is_wellboat?,
                mmsi: value.mmsi?,
                ship_register_vessel_type: value.ship_register_vessel_type?,
                ship_register_vessel_type_name_en: value
                    .ship_register_vessel_type_name_en?,
                ship_register_vessel_type_name_no: value
                    .ship_register_vessel_type_name_no?,
                ship_type: value.ship_type?,
                vessel_name: value.vessel_name?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiVesselTrackWeeksModelsVesselInfo>
    for BwApiApiVesselTrackWeeksModelsVesselInfo {
        fn from(value: super::BwApiApiVesselTrackWeeksModelsVesselInfo) -> Self {
            Self {
                is_slaughter_boat: Ok(value.is_slaughter_boat),
                is_wellboat: Ok(value.is_wellboat),
                mmsi: Ok(value.mmsi),
                ship_register_vessel_type: Ok(value.ship_register_vessel_type),
                ship_register_vessel_type_name_en: Ok(
                    value.ship_register_vessel_type_name_en,
                ),
                ship_register_vessel_type_name_no: Ok(
                    value.ship_register_vessel_type_name_no,
                ),
                ship_type: Ok(value.ship_type),
                vessel_name: Ok(value.vessel_name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiVesselTrackWeeksModelsVesselPosition {
        a: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        b: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        c: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        callsign: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        cog: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        d: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        destination: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        draught: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        eta: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        geometry: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        heading: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        is_slaughter_boat: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_well_boat: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        mmsi: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        navstat: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        rot: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        ship_register_vessel_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_register_vessel_type_name_en: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_register_vessel_type_name_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_type: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        sog: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        timestamp: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselPosition {
        fn default() -> Self {
            Self {
                a: Ok(Default::default()),
                b: Ok(Default::default()),
                c: Ok(Default::default()),
                callsign: Ok(Default::default()),
                cog: Ok(Default::default()),
                d: Ok(Default::default()),
                destination: Ok(Default::default()),
                draught: Ok(Default::default()),
                eta: Ok(Default::default()),
                geometry: Ok(Default::default()),
                heading: Ok(Default::default()),
                is_slaughter_boat: Ok(Default::default()),
                is_well_boat: Ok(Default::default()),
                mmsi: Ok(Default::default()),
                name: Ok(Default::default()),
                navstat: Ok(Default::default()),
                rot: Ok(Default::default()),
                ship_register_vessel_type: Ok(Default::default()),
                ship_register_vessel_type_name_en: Ok(Default::default()),
                ship_register_vessel_type_name_no: Ok(Default::default()),
                ship_type: Ok(Default::default()),
                sog: Ok(Default::default()),
                timestamp: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiVesselTrackWeeksModelsVesselPosition {
        pub fn a<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.a = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for a: {}", e));
            self
        }
        pub fn b<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.b = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for b: {}", e));
            self
        }
        pub fn c<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.c = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for c: {}", e));
            self
        }
        pub fn callsign<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.callsign = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for callsign: {}", e)
                });
            self
        }
        pub fn cog<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.cog = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cog: {}", e));
            self
        }
        pub fn d<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.d = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for d: {}", e));
            self
        }
        pub fn destination<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.destination = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for destination: {}", e)
                });
            self
        }
        pub fn draught<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.draught = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for draught: {}", e)
                });
            self
        }
        pub fn eta<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.eta = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for eta: {}", e));
            self
        }
        pub fn geometry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry: {}", e)
                });
            self
        }
        pub fn heading<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.heading = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for heading: {}", e)
                });
            self
        }
        pub fn is_slaughter_boat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_slaughter_boat = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_slaughter_boat: {}", e
                    )
                });
            self
        }
        pub fn is_well_boat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_well_boat = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_well_boat: {}", e)
                });
            self
        }
        pub fn mmsi<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.mmsi = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mmsi: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn navstat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.navstat = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for navstat: {}", e)
                });
            self
        }
        pub fn rot<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.rot = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for rot: {}", e));
            self
        }
        pub fn ship_register_vessel_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_register_vessel_type_name_en<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type_name_en = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type_name_en: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_register_vessel_type_name_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type_name_no = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type_name_no: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ship_type: {}", e)
                });
            self
        }
        pub fn sog<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.sog = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for sog: {}", e));
            self
        }
        pub fn timestamp<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.timestamp = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for timestamp: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiVesselTrackWeeksModelsVesselPosition>
    for super::BwApiApiVesselTrackWeeksModelsVesselPosition {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiVesselTrackWeeksModelsVesselPosition,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                a: value.a?,
                b: value.b?,
                c: value.c?,
                callsign: value.callsign?,
                cog: value.cog?,
                d: value.d?,
                destination: value.destination?,
                draught: value.draught?,
                eta: value.eta?,
                geometry: value.geometry?,
                heading: value.heading?,
                is_slaughter_boat: value.is_slaughter_boat?,
                is_well_boat: value.is_well_boat?,
                mmsi: value.mmsi?,
                name: value.name?,
                navstat: value.navstat?,
                rot: value.rot?,
                ship_register_vessel_type: value.ship_register_vessel_type?,
                ship_register_vessel_type_name_en: value
                    .ship_register_vessel_type_name_en?,
                ship_register_vessel_type_name_no: value
                    .ship_register_vessel_type_name_no?,
                ship_type: value.ship_type?,
                sog: value.sog?,
                timestamp: value.timestamp?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiVesselTrackWeeksModelsVesselPosition>
    for BwApiApiVesselTrackWeeksModelsVesselPosition {
        fn from(value: super::BwApiApiVesselTrackWeeksModelsVesselPosition) -> Self {
            Self {
                a: Ok(value.a),
                b: Ok(value.b),
                c: Ok(value.c),
                callsign: Ok(value.callsign),
                cog: Ok(value.cog),
                d: Ok(value.d),
                destination: Ok(value.destination),
                draught: Ok(value.draught),
                eta: Ok(value.eta),
                geometry: Ok(value.geometry),
                heading: Ok(value.heading),
                is_slaughter_boat: Ok(value.is_slaughter_boat),
                is_well_boat: Ok(value.is_well_boat),
                mmsi: Ok(value.mmsi),
                name: Ok(value.name),
                navstat: Ok(value.navstat),
                rot: Ok(value.rot),
                ship_register_vessel_type: Ok(value.ship_register_vessel_type),
                ship_register_vessel_type_name_en: Ok(
                    value.ship_register_vessel_type_name_en,
                ),
                ship_register_vessel_type_name_no: Ok(
                    value.ship_register_vessel_type_name_no,
                ),
                ship_type: Ok(value.ship_type),
                sog: Ok(value.sog),
                timestamp: Ok(value.timestamp),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiVesselTrackWeeksModelsVesselTrack {
        from_time: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        id: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        is_no_signal: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        points: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiAisModelsAisRestPositionDto>,
            ::std::string::String,
        >,
        to_time: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        vessel_track_week_id: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselTrack {
        fn default() -> Self {
            Self {
                from_time: Ok(Default::default()),
                id: Ok(Default::default()),
                is_no_signal: Ok(Default::default()),
                points: Ok(Default::default()),
                to_time: Ok(Default::default()),
                vessel_track_week_id: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiVesselTrackWeeksModelsVesselTrack {
        pub fn from_time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_time = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_time: {}", e)
                });
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn is_no_signal<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_no_signal = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_no_signal: {}", e)
                });
            self
        }
        pub fn points<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiAisModelsAisRestPositionDto>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.points = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for points: {}", e)
                });
            self
        }
        pub fn to_time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_time = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_time: {}", e)
                });
            self
        }
        pub fn vessel_track_week_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.vessel_track_week_id = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for vessel_track_week_id: {}", e
                    )
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiVesselTrackWeeksModelsVesselTrack>
    for super::BwApiApiVesselTrackWeeksModelsVesselTrack {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiVesselTrackWeeksModelsVesselTrack,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                from_time: value.from_time?,
                id: value.id?,
                is_no_signal: value.is_no_signal?,
                points: value.points?,
                to_time: value.to_time?,
                vessel_track_week_id: value.vessel_track_week_id?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiVesselTrackWeeksModelsVesselTrack>
    for BwApiApiVesselTrackWeeksModelsVesselTrack {
        fn from(value: super::BwApiApiVesselTrackWeeksModelsVesselTrack) -> Self {
            Self {
                from_time: Ok(value.from_time),
                id: Ok(value.id),
                is_no_signal: Ok(value.is_no_signal),
                points: Ok(value.points),
                to_time: Ok(value.to_time),
                vessel_track_week_id: Ok(value.vessel_track_week_id),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek {
        anlysis_based_on_surface_area: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        vessel_visits: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiVesselTrackWeeksModelsVesselVisit>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        week_is_analyzed: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default
    for BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek {
        fn default() -> Self {
            Self {
                anlysis_based_on_surface_area: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                vessel_visits: Ok(Default::default()),
                week: Ok(Default::default()),
                week_is_analyzed: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek {
        pub fn anlysis_based_on_surface_area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.anlysis_based_on_surface_area = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for anlysis_based_on_surface_area: {}",
                        e
                    )
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn vessel_visits<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiVesselTrackWeeksModelsVesselVisit>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.vessel_visits = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for vessel_visits: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn week_is_analyzed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.week_is_analyzed = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for week_is_analyzed: {}", e
                    )
                });
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek>
    for super::BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                anlysis_based_on_surface_area: value.anlysis_based_on_surface_area?,
                locality_no: value.locality_no?,
                vessel_visits: value.vessel_visits?,
                week: value.week?,
                week_is_analyzed: value.week_is_analyzed?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<
        super::BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek,
    > for BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek {
        fn from(
            value: super::BwApiApiVesselTrackWeeksModelsVesselTrackLocalityWeek,
        ) -> Self {
            Self {
                anlysis_based_on_surface_area: Ok(value.anlysis_based_on_surface_area),
                locality_no: Ok(value.locality_no),
                vessel_visits: Ok(value.vessel_visits),
                week: Ok(value.week),
                week_is_analyzed: Ok(value.week_is_analyzed),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint {
        diseases: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiVesselTrackWeeksModelsDisease>,
            ::std::string::String,
        >,
        from_time: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        is_based_on_surface_area: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_juvenile: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_on_land: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_slaughter_holding_cage: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        locality_no: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        to_time: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint {
        fn default() -> Self {
            Self {
                diseases: Ok(Default::default()),
                from_time: Ok(Default::default()),
                is_based_on_surface_area: Ok(Default::default()),
                is_juvenile: Ok(Default::default()),
                is_on_land: Ok(Default::default()),
                is_slaughter_holding_cage: Ok(Default::default()),
                locality_no: Ok(Default::default()),
                name: Ok(Default::default()),
                to_time: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint {
        pub fn diseases<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiVesselTrackWeeksModelsDisease>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.diseases = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for diseases: {}", e)
                });
            self
        }
        pub fn from_time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.from_time = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for from_time: {}", e)
                });
            self
        }
        pub fn is_based_on_surface_area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_based_on_surface_area = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_based_on_surface_area: {}",
                        e
                    )
                });
            self
        }
        pub fn is_juvenile<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_juvenile = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_juvenile: {}", e)
                });
            self
        }
        pub fn is_on_land<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_on_land = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_on_land: {}", e)
                });
            self
        }
        pub fn is_slaughter_holding_cage<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_slaughter_holding_cage = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_slaughter_holding_cage: {}",
                        e
                    )
                });
            self
        }
        pub fn locality_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.locality_no = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for locality_no: {}", e)
                });
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn to_time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.to_time = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for to_time: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint>
    for super::BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                diseases: value.diseases?,
                from_time: value.from_time?,
                is_based_on_surface_area: value.is_based_on_surface_area?,
                is_juvenile: value.is_juvenile?,
                is_on_land: value.is_on_land?,
                is_slaughter_holding_cage: value.is_slaughter_holding_cage?,
                locality_no: value.locality_no?,
                name: value.name?,
                to_time: value.to_time?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint>
    for BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint {
        fn from(
            value: super::BwApiApiVesselTrackWeeksModelsVesselTrackWaypoint,
        ) -> Self {
            Self {
                diseases: Ok(value.diseases),
                from_time: Ok(value.from_time),
                is_based_on_surface_area: Ok(value.is_based_on_surface_area),
                is_juvenile: Ok(value.is_juvenile),
                is_on_land: Ok(value.is_on_land),
                is_slaughter_holding_cage: Ok(value.is_slaughter_holding_cage),
                locality_no: Ok(value.locality_no),
                name: Ok(value.name),
                to_time: Ok(value.to_time),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiVesselTrackWeeksModelsVesselTrackWeek {
        id: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        is_slaughter_boat: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_well_boat: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        mmsi: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        ship_register_vessel_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_register_vessel_type_name_en: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_register_vessel_type_name_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_type: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        track_analysis: ::std::result::Result<
            ::std::option::Option<super::BwApiApiVesselTrackWeeksModelsTrackAnalysis>,
            ::std::string::String,
        >,
        vessel_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        vessel_tracks: ::std::result::Result<
            ::std::vec::Vec<super::BwApiApiVesselTrackWeeksModelsVesselTrack>,
            ::std::string::String,
        >,
        week: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        year: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselTrackWeek {
        fn default() -> Self {
            Self {
                id: Ok(Default::default()),
                is_slaughter_boat: Ok(Default::default()),
                is_well_boat: Ok(Default::default()),
                mmsi: Ok(Default::default()),
                ship_register_vessel_type: Ok(Default::default()),
                ship_register_vessel_type_name_en: Ok(Default::default()),
                ship_register_vessel_type_name_no: Ok(Default::default()),
                ship_type: Ok(Default::default()),
                track_analysis: Ok(Default::default()),
                vessel_name: Ok(Default::default()),
                vessel_tracks: Ok(Default::default()),
                week: Ok(Default::default()),
                year: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiVesselTrackWeeksModelsVesselTrackWeek {
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn is_slaughter_boat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_slaughter_boat = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_slaughter_boat: {}", e
                    )
                });
            self
        }
        pub fn is_well_boat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_well_boat = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_well_boat: {}", e)
                });
            self
        }
        pub fn mmsi<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.mmsi = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mmsi: {}", e));
            self
        }
        pub fn ship_register_vessel_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_register_vessel_type_name_en<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type_name_en = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type_name_en: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_register_vessel_type_name_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type_name_no = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type_name_no: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ship_type: {}", e)
                });
            self
        }
        pub fn track_analysis<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::BwApiApiVesselTrackWeeksModelsTrackAnalysis>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.track_analysis = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for track_analysis: {}", e)
                });
            self
        }
        pub fn vessel_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.vessel_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for vessel_name: {}", e)
                });
            self
        }
        pub fn vessel_tracks<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::BwApiApiVesselTrackWeeksModelsVesselTrack>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.vessel_tracks = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for vessel_tracks: {}", e)
                });
            self
        }
        pub fn week<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.week = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for week: {}", e));
            self
        }
        pub fn year<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.year = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for year: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiVesselTrackWeeksModelsVesselTrackWeek>
    for super::BwApiApiVesselTrackWeeksModelsVesselTrackWeek {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiVesselTrackWeeksModelsVesselTrackWeek,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                id: value.id?,
                is_slaughter_boat: value.is_slaughter_boat?,
                is_well_boat: value.is_well_boat?,
                mmsi: value.mmsi?,
                ship_register_vessel_type: value.ship_register_vessel_type?,
                ship_register_vessel_type_name_en: value
                    .ship_register_vessel_type_name_en?,
                ship_register_vessel_type_name_no: value
                    .ship_register_vessel_type_name_no?,
                ship_type: value.ship_type?,
                track_analysis: value.track_analysis?,
                vessel_name: value.vessel_name?,
                vessel_tracks: value.vessel_tracks?,
                week: value.week?,
                year: value.year?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiVesselTrackWeeksModelsVesselTrackWeek>
    for BwApiApiVesselTrackWeeksModelsVesselTrackWeek {
        fn from(value: super::BwApiApiVesselTrackWeeksModelsVesselTrackWeek) -> Self {
            Self {
                id: Ok(value.id),
                is_slaughter_boat: Ok(value.is_slaughter_boat),
                is_well_boat: Ok(value.is_well_boat),
                mmsi: Ok(value.mmsi),
                ship_register_vessel_type: Ok(value.ship_register_vessel_type),
                ship_register_vessel_type_name_en: Ok(
                    value.ship_register_vessel_type_name_en,
                ),
                ship_register_vessel_type_name_no: Ok(
                    value.ship_register_vessel_type_name_no,
                ),
                ship_type: Ok(value.ship_type),
                track_analysis: Ok(value.track_analysis),
                vessel_name: Ok(value.vessel_name),
                vessel_tracks: Ok(value.vessel_tracks),
                week: Ok(value.week),
                year: Ok(value.year),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct BwApiApiVesselTrackWeeksModelsVesselVisit {
        is_slaughter_boat: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_wellboat: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        mmsi: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        ship_register_vessel_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_register_vessel_type_name_en: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_register_vessel_type_name_no: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        ship_type: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        start_time: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        stop_time: ::std::result::Result<
            ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            ::std::string::String,
        >,
        vessel_name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for BwApiApiVesselTrackWeeksModelsVesselVisit {
        fn default() -> Self {
            Self {
                is_slaughter_boat: Ok(Default::default()),
                is_wellboat: Ok(Default::default()),
                mmsi: Ok(Default::default()),
                ship_register_vessel_type: Ok(Default::default()),
                ship_register_vessel_type_name_en: Ok(Default::default()),
                ship_register_vessel_type_name_no: Ok(Default::default()),
                ship_type: Ok(Default::default()),
                start_time: Ok(Default::default()),
                stop_time: Ok(Default::default()),
                vessel_name: Ok(Default::default()),
            }
        }
    }
    impl BwApiApiVesselTrackWeeksModelsVesselVisit {
        pub fn is_slaughter_boat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_slaughter_boat = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for is_slaughter_boat: {}", e
                    )
                });
            self
        }
        pub fn is_wellboat<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_wellboat = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_wellboat: {}", e)
                });
            self
        }
        pub fn mmsi<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.mmsi = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for mmsi: {}", e));
            self
        }
        pub fn ship_register_vessel_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_register_vessel_type_name_en<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type_name_en = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type_name_en: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_register_vessel_type_name_no<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_register_vessel_type_name_no = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ship_register_vessel_type_name_no: {}",
                        e
                    )
                });
            self
        }
        pub fn ship_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.ship_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ship_type: {}", e)
                });
            self
        }
        pub fn start_time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.start_time = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for start_time: {}", e)
                });
            self
        }
        pub fn stop_time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<chrono::DateTime<chrono::offset::Utc>>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.stop_time = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for stop_time: {}", e)
                });
            self
        }
        pub fn vessel_name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.vessel_name = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for vessel_name: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<BwApiApiVesselTrackWeeksModelsVesselVisit>
    for super::BwApiApiVesselTrackWeeksModelsVesselVisit {
        type Error = super::error::ConversionError;
        fn try_from(
            value: BwApiApiVesselTrackWeeksModelsVesselVisit,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                is_slaughter_boat: value.is_slaughter_boat?,
                is_wellboat: value.is_wellboat?,
                mmsi: value.mmsi?,
                ship_register_vessel_type: value.ship_register_vessel_type?,
                ship_register_vessel_type_name_en: value
                    .ship_register_vessel_type_name_en?,
                ship_register_vessel_type_name_no: value
                    .ship_register_vessel_type_name_no?,
                ship_type: value.ship_type?,
                start_time: value.start_time?,
                stop_time: value.stop_time?,
                vessel_name: value.vessel_name?,
            })
        }
    }
    impl ::std::convert::From<super::BwApiApiVesselTrackWeeksModelsVesselVisit>
    for BwApiApiVesselTrackWeeksModelsVesselVisit {
        fn from(value: super::BwApiApiVesselTrackWeeksModelsVesselVisit) -> Self {
            Self {
                is_slaughter_boat: Ok(value.is_slaughter_boat),
                is_wellboat: Ok(value.is_wellboat),
                mmsi: Ok(value.mmsi),
                ship_register_vessel_type: Ok(value.ship_register_vessel_type),
                ship_register_vessel_type_name_en: Ok(
                    value.ship_register_vessel_type_name_en,
                ),
                ship_register_vessel_type_name_no: Ok(
                    value.ship_register_vessel_type_name_no,
                ),
                ship_type: Ok(value.ship_type),
                start_time: Ok(value.start_time),
                stop_time: Ok(value.stop_time),
                vessel_name: Ok(value.vessel_name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct MicrosoftAspNetCoreMvcProblemDetails {
        detail: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        instance: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        status: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for MicrosoftAspNetCoreMvcProblemDetails {
        fn default() -> Self {
            Self {
                detail: Ok(Default::default()),
                instance: Ok(Default::default()),
                status: Ok(Default::default()),
                title: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }
    impl MicrosoftAspNetCoreMvcProblemDetails {
        pub fn detail<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.detail = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for detail: {}", e)
                });
            self
        }
        pub fn instance<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.instance = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for instance: {}", e)
                });
            self
        }
        pub fn status<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.status = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for status: {}", e)
                });
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for title: {}", e)
                });
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for type_: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<MicrosoftAspNetCoreMvcProblemDetails>
    for super::MicrosoftAspNetCoreMvcProblemDetails {
        type Error = super::error::ConversionError;
        fn try_from(
            value: MicrosoftAspNetCoreMvcProblemDetails,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                detail: value.detail?,
                instance: value.instance?,
                status: value.status?,
                title: value.title?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::MicrosoftAspNetCoreMvcProblemDetails>
    for MicrosoftAspNetCoreMvcProblemDetails {
        fn from(value: super::MicrosoftAspNetCoreMvcProblemDetails) -> Self {
            Self {
                detail: Ok(value.detail),
                instance: Ok(value.instance),
                status: Ok(value.status),
                title: Ok(value.title),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct NetTopologySuiteGeometriesCoordinateEqualityComparer {}
    impl ::std::default::Default
    for NetTopologySuiteGeometriesCoordinateEqualityComparer {
        fn default() -> Self {
            Self {}
        }
    }
    impl NetTopologySuiteGeometriesCoordinateEqualityComparer {}
    impl ::std::convert::TryFrom<NetTopologySuiteGeometriesCoordinateEqualityComparer>
    for super::NetTopologySuiteGeometriesCoordinateEqualityComparer {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: NetTopologySuiteGeometriesCoordinateEqualityComparer,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<
        super::NetTopologySuiteGeometriesCoordinateEqualityComparer,
    > for NetTopologySuiteGeometriesCoordinateEqualityComparer {
        fn from(
            _value: super::NetTopologySuiteGeometriesCoordinateEqualityComparer,
        ) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct NetTopologySuiteGeometriesCoordinateSequence {
        count: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        dimension: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        first: ::std::result::Result<::std::vec::Vec<f64>, ::std::string::String>,
        has_m: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        has_z: ::std::result::Result<::std::option::Option<bool>, ::std::string::String>,
        last: ::std::result::Result<::std::vec::Vec<f64>, ::std::string::String>,
        m_ordinate_index: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        measures: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        ordinates: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesOrdinates>,
            ::std::string::String,
        >,
        spatial: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        z_ordinate_index: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for NetTopologySuiteGeometriesCoordinateSequence {
        fn default() -> Self {
            Self {
                count: Ok(Default::default()),
                dimension: Ok(Default::default()),
                first: Ok(Default::default()),
                has_m: Ok(Default::default()),
                has_z: Ok(Default::default()),
                last: Ok(Default::default()),
                m_ordinate_index: Ok(Default::default()),
                measures: Ok(Default::default()),
                ordinates: Ok(Default::default()),
                spatial: Ok(Default::default()),
                z_ordinate_index: Ok(Default::default()),
            }
        }
    }
    impl NetTopologySuiteGeometriesCoordinateSequence {
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count: {}", e)
                });
            self
        }
        pub fn dimension<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.dimension = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for dimension: {}", e)
                });
            self
        }
        pub fn first<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.first = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for first: {}", e)
                });
            self
        }
        pub fn has_m<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_m = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for has_m: {}", e)
                });
            self
        }
        pub fn has_z<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.has_z = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for has_z: {}", e)
                });
            self
        }
        pub fn last<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.last = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for last: {}", e));
            self
        }
        pub fn m_ordinate_index<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.m_ordinate_index = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for m_ordinate_index: {}", e
                    )
                });
            self
        }
        pub fn measures<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.measures = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for measures: {}", e)
                });
            self
        }
        pub fn ordinates<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesOrdinates>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ordinates = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ordinates: {}", e)
                });
            self
        }
        pub fn spatial<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.spatial = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for spatial: {}", e)
                });
            self
        }
        pub fn z_ordinate_index<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.z_ordinate_index = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for z_ordinate_index: {}", e
                    )
                });
            self
        }
    }
    impl ::std::convert::TryFrom<NetTopologySuiteGeometriesCoordinateSequence>
    for super::NetTopologySuiteGeometriesCoordinateSequence {
        type Error = super::error::ConversionError;
        fn try_from(
            value: NetTopologySuiteGeometriesCoordinateSequence,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                count: value.count?,
                dimension: value.dimension?,
                first: value.first?,
                has_m: value.has_m?,
                has_z: value.has_z?,
                last: value.last?,
                m_ordinate_index: value.m_ordinate_index?,
                measures: value.measures?,
                ordinates: value.ordinates?,
                spatial: value.spatial?,
                z_ordinate_index: value.z_ordinate_index?,
            })
        }
    }
    impl ::std::convert::From<super::NetTopologySuiteGeometriesCoordinateSequence>
    for NetTopologySuiteGeometriesCoordinateSequence {
        fn from(value: super::NetTopologySuiteGeometriesCoordinateSequence) -> Self {
            Self {
                count: Ok(value.count),
                dimension: Ok(value.dimension),
                first: Ok(value.first),
                has_m: Ok(value.has_m),
                has_z: Ok(value.has_z),
                last: Ok(value.last),
                m_ordinate_index: Ok(value.m_ordinate_index),
                measures: Ok(value.measures),
                ordinates: Ok(value.ordinates),
                spatial: Ok(value.spatial),
                z_ordinate_index: Ok(value.z_ordinate_index),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct NetTopologySuiteGeometriesCoordinateSequenceFactory {
        ordinates: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesOrdinates>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default
    for NetTopologySuiteGeometriesCoordinateSequenceFactory {
        fn default() -> Self {
            Self {
                ordinates: Ok(Default::default()),
            }
        }
    }
    impl NetTopologySuiteGeometriesCoordinateSequenceFactory {
        pub fn ordinates<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesOrdinates>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ordinates = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for ordinates: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<NetTopologySuiteGeometriesCoordinateSequenceFactory>
    for super::NetTopologySuiteGeometriesCoordinateSequenceFactory {
        type Error = super::error::ConversionError;
        fn try_from(
            value: NetTopologySuiteGeometriesCoordinateSequenceFactory,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                ordinates: value.ordinates?,
            })
        }
    }
    impl ::std::convert::From<super::NetTopologySuiteGeometriesCoordinateSequenceFactory>
    for NetTopologySuiteGeometriesCoordinateSequenceFactory {
        fn from(
            value: super::NetTopologySuiteGeometriesCoordinateSequenceFactory,
        ) -> Self {
            Self {
                ordinates: Ok(value.ordinates),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct NetTopologySuiteGeometriesEnvelope {
        area: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        centre: ::std::result::Result<::std::vec::Vec<f64>, ::std::string::String>,
        diameter: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        height: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        is_null: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        max_extent: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        max_x: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        max_y: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        min_extent: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        min_x: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        min_y: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        width: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
    }
    impl ::std::default::Default for NetTopologySuiteGeometriesEnvelope {
        fn default() -> Self {
            Self {
                area: Ok(Default::default()),
                centre: Ok(Default::default()),
                diameter: Ok(Default::default()),
                height: Ok(Default::default()),
                is_null: Ok(Default::default()),
                max_extent: Ok(Default::default()),
                max_x: Ok(Default::default()),
                max_y: Ok(Default::default()),
                min_extent: Ok(Default::default()),
                min_x: Ok(Default::default()),
                min_y: Ok(Default::default()),
                width: Ok(Default::default()),
            }
        }
    }
    impl NetTopologySuiteGeometriesEnvelope {
        pub fn area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.area = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for area: {}", e));
            self
        }
        pub fn centre<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.centre = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for centre: {}", e)
                });
            self
        }
        pub fn diameter<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.diameter = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for diameter: {}", e)
                });
            self
        }
        pub fn height<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.height = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for height: {}", e)
                });
            self
        }
        pub fn is_null<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_null = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_null: {}", e)
                });
            self
        }
        pub fn max_extent<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.max_extent = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for max_extent: {}", e)
                });
            self
        }
        pub fn max_x<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.max_x = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for max_x: {}", e)
                });
            self
        }
        pub fn max_y<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.max_y = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for max_y: {}", e)
                });
            self
        }
        pub fn min_extent<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.min_extent = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for min_extent: {}", e)
                });
            self
        }
        pub fn min_x<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.min_x = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for min_x: {}", e)
                });
            self
        }
        pub fn min_y<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.min_y = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for min_y: {}", e)
                });
            self
        }
        pub fn width<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.width = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for width: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<NetTopologySuiteGeometriesEnvelope>
    for super::NetTopologySuiteGeometriesEnvelope {
        type Error = super::error::ConversionError;
        fn try_from(
            value: NetTopologySuiteGeometriesEnvelope,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                area: value.area?,
                centre: value.centre?,
                diameter: value.diameter?,
                height: value.height?,
                is_null: value.is_null?,
                max_extent: value.max_extent?,
                max_x: value.max_x?,
                max_y: value.max_y?,
                min_extent: value.min_extent?,
                min_x: value.min_x?,
                min_y: value.min_y?,
                width: value.width?,
            })
        }
    }
    impl ::std::convert::From<super::NetTopologySuiteGeometriesEnvelope>
    for NetTopologySuiteGeometriesEnvelope {
        fn from(value: super::NetTopologySuiteGeometriesEnvelope) -> Self {
            Self {
                area: Ok(value.area),
                centre: Ok(value.centre),
                diameter: Ok(value.diameter),
                height: Ok(value.height),
                is_null: Ok(value.is_null),
                max_extent: Ok(value.max_extent),
                max_x: Ok(value.max_x),
                max_y: Ok(value.max_y),
                min_extent: Ok(value.min_extent),
                min_x: Ok(value.min_x),
                min_y: Ok(value.min_y),
                width: Ok(value.width),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct NetTopologySuiteGeometriesGeometryFactory {
        coordinate_sequence_factory: ::std::result::Result<
            ::std::option::Option<
                super::NetTopologySuiteGeometriesCoordinateSequenceFactory,
            >,
            ::std::string::String,
        >,
        geometry_services: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteNtsGeometryServices>,
            ::std::string::String,
        >,
        precision_model: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModel>,
            ::std::string::String,
        >,
        srid: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
    }
    impl ::std::default::Default for NetTopologySuiteGeometriesGeometryFactory {
        fn default() -> Self {
            Self {
                coordinate_sequence_factory: Ok(Default::default()),
                geometry_services: Ok(Default::default()),
                precision_model: Ok(Default::default()),
                srid: Ok(Default::default()),
            }
        }
    }
    impl NetTopologySuiteGeometriesGeometryFactory {
        pub fn coordinate_sequence_factory<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::NetTopologySuiteGeometriesCoordinateSequenceFactory,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.coordinate_sequence_factory = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for coordinate_sequence_factory: {}",
                        e
                    )
                });
            self
        }
        pub fn geometry_services<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteNtsGeometryServices>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.geometry_services = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for geometry_services: {}", e
                    )
                });
            self
        }
        pub fn precision_model<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModel>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.precision_model = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for precision_model: {}", e)
                });
            self
        }
        pub fn srid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.srid = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for srid: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<NetTopologySuiteGeometriesGeometryFactory>
    for super::NetTopologySuiteGeometriesGeometryFactory {
        type Error = super::error::ConversionError;
        fn try_from(
            value: NetTopologySuiteGeometriesGeometryFactory,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                coordinate_sequence_factory: value.coordinate_sequence_factory?,
                geometry_services: value.geometry_services?,
                precision_model: value.precision_model?,
                srid: value.srid?,
            })
        }
    }
    impl ::std::convert::From<super::NetTopologySuiteGeometriesGeometryFactory>
    for NetTopologySuiteGeometriesGeometryFactory {
        fn from(value: super::NetTopologySuiteGeometriesGeometryFactory) -> Self {
            Self {
                coordinate_sequence_factory: Ok(value.coordinate_sequence_factory),
                geometry_services: Ok(value.geometry_services),
                precision_model: Ok(value.precision_model),
                srid: Ok(value.srid),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct NetTopologySuiteGeometriesGeometryOverlay {}
    impl ::std::default::Default for NetTopologySuiteGeometriesGeometryOverlay {
        fn default() -> Self {
            Self {}
        }
    }
    impl NetTopologySuiteGeometriesGeometryOverlay {}
    impl ::std::convert::TryFrom<NetTopologySuiteGeometriesGeometryOverlay>
    for super::NetTopologySuiteGeometriesGeometryOverlay {
        type Error = super::error::ConversionError;
        fn try_from(
            _value: NetTopologySuiteGeometriesGeometryOverlay,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {})
        }
    }
    impl ::std::convert::From<super::NetTopologySuiteGeometriesGeometryOverlay>
    for NetTopologySuiteGeometriesGeometryOverlay {
        fn from(_value: super::NetTopologySuiteGeometriesGeometryOverlay) -> Self {
            Self {}
        }
    }
    #[derive(Clone, Debug)]
    pub struct NetTopologySuiteGeometriesLineString {
        area: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        boundary: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        boundary_dimension: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            ::std::string::String,
        >,
        centroid: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        coordinate: ::std::result::Result<::std::vec::Vec<f64>, ::std::string::String>,
        coordinate_sequence: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesCoordinateSequence>,
            ::std::string::String,
        >,
        coordinates: ::std::result::Result<
            ::std::vec::Vec<::std::vec::Vec<f64>>,
            ::std::string::String,
        >,
        count: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        dimension: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            ::std::string::String,
        >,
        end_point: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        envelope: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        envelope_internal: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesEnvelope>,
            ::std::string::String,
        >,
        factory: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesGeometryFactory>,
            ::std::string::String,
        >,
        geometry_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        interior_point: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        is_closed: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_empty: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_rectangle: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_ring: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_simple: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_valid: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        length: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        num_geometries: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        num_points: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        ogc_geometry_type: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesOgcGeometryType>,
            ::std::string::String,
        >,
        point_on_surface: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        precision_model: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModel>,
            ::std::string::String,
        >,
        srid: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        start_point: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        user_data: ::std::result::Result<
            ::std::option::Option<::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for NetTopologySuiteGeometriesLineString {
        fn default() -> Self {
            Self {
                area: Ok(Default::default()),
                boundary: Ok(Default::default()),
                boundary_dimension: Ok(Default::default()),
                centroid: Ok(Default::default()),
                coordinate: Ok(Default::default()),
                coordinate_sequence: Ok(Default::default()),
                coordinates: Ok(Default::default()),
                count: Ok(Default::default()),
                dimension: Ok(Default::default()),
                end_point: Ok(Default::default()),
                envelope: Ok(Default::default()),
                envelope_internal: Ok(Default::default()),
                factory: Ok(Default::default()),
                geometry_type: Ok(Default::default()),
                interior_point: Ok(Default::default()),
                is_closed: Ok(Default::default()),
                is_empty: Ok(Default::default()),
                is_rectangle: Ok(Default::default()),
                is_ring: Ok(Default::default()),
                is_simple: Ok(Default::default()),
                is_valid: Ok(Default::default()),
                length: Ok(Default::default()),
                num_geometries: Ok(Default::default()),
                num_points: Ok(Default::default()),
                ogc_geometry_type: Ok(Default::default()),
                point_on_surface: Ok(Default::default()),
                precision_model: Ok(Default::default()),
                srid: Ok(Default::default()),
                start_point: Ok(Default::default()),
                user_data: Ok(Default::default()),
            }
        }
    }
    impl NetTopologySuiteGeometriesLineString {
        pub fn area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.area = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for area: {}", e));
            self
        }
        pub fn boundary<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.boundary = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for boundary: {}", e)
                });
            self
        }
        pub fn boundary_dimension<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.boundary_dimension = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for boundary_dimension: {}", e
                    )
                });
            self
        }
        pub fn centroid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.centroid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for centroid: {}", e)
                });
            self
        }
        pub fn coordinate<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.coordinate = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for coordinate: {}", e)
                });
            self
        }
        pub fn coordinate_sequence<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::NetTopologySuiteGeometriesCoordinateSequence,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.coordinate_sequence = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for coordinate_sequence: {}", e
                    )
                });
            self
        }
        pub fn coordinates<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::vec::Vec<f64>>>,
            T::Error: ::std::fmt::Display,
        {
            self.coordinates = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for coordinates: {}", e)
                });
            self
        }
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count: {}", e)
                });
            self
        }
        pub fn dimension<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.dimension = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for dimension: {}", e)
                });
            self
        }
        pub fn end_point<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.end_point = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for end_point: {}", e)
                });
            self
        }
        pub fn envelope<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.envelope = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for envelope: {}", e)
                });
            self
        }
        pub fn envelope_internal<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesEnvelope>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.envelope_internal = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for envelope_internal: {}", e
                    )
                });
            self
        }
        pub fn factory<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesGeometryFactory>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.factory = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for factory: {}", e)
                });
            self
        }
        pub fn geometry_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry_type: {}", e)
                });
            self
        }
        pub fn interior_point<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.interior_point = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for interior_point: {}", e)
                });
            self
        }
        pub fn is_closed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_closed = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_closed: {}", e)
                });
            self
        }
        pub fn is_empty<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_empty = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_empty: {}", e)
                });
            self
        }
        pub fn is_rectangle<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_rectangle = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_rectangle: {}", e)
                });
            self
        }
        pub fn is_ring<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_ring = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_ring: {}", e)
                });
            self
        }
        pub fn is_simple<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_simple = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_simple: {}", e)
                });
            self
        }
        pub fn is_valid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_valid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_valid: {}", e)
                });
            self
        }
        pub fn length<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.length = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for length: {}", e)
                });
            self
        }
        pub fn num_geometries<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.num_geometries = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for num_geometries: {}", e)
                });
            self
        }
        pub fn num_points<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.num_points = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for num_points: {}", e)
                });
            self
        }
        pub fn ogc_geometry_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesOgcGeometryType>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ogc_geometry_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ogc_geometry_type: {}", e
                    )
                });
            self
        }
        pub fn point_on_surface<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.point_on_surface = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for point_on_surface: {}", e
                    )
                });
            self
        }
        pub fn precision_model<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModel>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.precision_model = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for precision_model: {}", e)
                });
            self
        }
        pub fn srid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.srid = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for srid: {}", e));
            self
        }
        pub fn start_point<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.start_point = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for start_point: {}", e)
                });
            self
        }
        pub fn user_data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::serde_json::Value>>,
            T::Error: ::std::fmt::Display,
        {
            self.user_data = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for user_data: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<NetTopologySuiteGeometriesLineString>
    for super::NetTopologySuiteGeometriesLineString {
        type Error = super::error::ConversionError;
        fn try_from(
            value: NetTopologySuiteGeometriesLineString,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                area: value.area?,
                boundary: value.boundary?,
                boundary_dimension: value.boundary_dimension?,
                centroid: value.centroid?,
                coordinate: value.coordinate?,
                coordinate_sequence: value.coordinate_sequence?,
                coordinates: value.coordinates?,
                count: value.count?,
                dimension: value.dimension?,
                end_point: value.end_point?,
                envelope: value.envelope?,
                envelope_internal: value.envelope_internal?,
                factory: value.factory?,
                geometry_type: value.geometry_type?,
                interior_point: value.interior_point?,
                is_closed: value.is_closed?,
                is_empty: value.is_empty?,
                is_rectangle: value.is_rectangle?,
                is_ring: value.is_ring?,
                is_simple: value.is_simple?,
                is_valid: value.is_valid?,
                length: value.length?,
                num_geometries: value.num_geometries?,
                num_points: value.num_points?,
                ogc_geometry_type: value.ogc_geometry_type?,
                point_on_surface: value.point_on_surface?,
                precision_model: value.precision_model?,
                srid: value.srid?,
                start_point: value.start_point?,
                user_data: value.user_data?,
            })
        }
    }
    impl ::std::convert::From<super::NetTopologySuiteGeometriesLineString>
    for NetTopologySuiteGeometriesLineString {
        fn from(value: super::NetTopologySuiteGeometriesLineString) -> Self {
            Self {
                area: Ok(value.area),
                boundary: Ok(value.boundary),
                boundary_dimension: Ok(value.boundary_dimension),
                centroid: Ok(value.centroid),
                coordinate: Ok(value.coordinate),
                coordinate_sequence: Ok(value.coordinate_sequence),
                coordinates: Ok(value.coordinates),
                count: Ok(value.count),
                dimension: Ok(value.dimension),
                end_point: Ok(value.end_point),
                envelope: Ok(value.envelope),
                envelope_internal: Ok(value.envelope_internal),
                factory: Ok(value.factory),
                geometry_type: Ok(value.geometry_type),
                interior_point: Ok(value.interior_point),
                is_closed: Ok(value.is_closed),
                is_empty: Ok(value.is_empty),
                is_rectangle: Ok(value.is_rectangle),
                is_ring: Ok(value.is_ring),
                is_simple: Ok(value.is_simple),
                is_valid: Ok(value.is_valid),
                length: Ok(value.length),
                num_geometries: Ok(value.num_geometries),
                num_points: Ok(value.num_points),
                ogc_geometry_type: Ok(value.ogc_geometry_type),
                point_on_surface: Ok(value.point_on_surface),
                precision_model: Ok(value.precision_model),
                srid: Ok(value.srid),
                start_point: Ok(value.start_point),
                user_data: Ok(value.user_data),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct NetTopologySuiteGeometriesLinearRing {
        area: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        boundary: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        boundary_dimension: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            ::std::string::String,
        >,
        centroid: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        coordinate: ::std::result::Result<::std::vec::Vec<f64>, ::std::string::String>,
        coordinate_sequence: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesCoordinateSequence>,
            ::std::string::String,
        >,
        coordinates: ::std::result::Result<
            ::std::vec::Vec<::std::vec::Vec<f64>>,
            ::std::string::String,
        >,
        count: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        dimension: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            ::std::string::String,
        >,
        end_point: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        envelope: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        envelope_internal: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesEnvelope>,
            ::std::string::String,
        >,
        factory: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesGeometryFactory>,
            ::std::string::String,
        >,
        geometry_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        interior_point: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        is_ccw: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_closed: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_empty: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_rectangle: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_ring: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_simple: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_valid: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        length: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        num_geometries: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        num_points: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        ogc_geometry_type: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesOgcGeometryType>,
            ::std::string::String,
        >,
        point_on_surface: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        precision_model: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModel>,
            ::std::string::String,
        >,
        srid: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        start_point: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        user_data: ::std::result::Result<
            ::std::option::Option<::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for NetTopologySuiteGeometriesLinearRing {
        fn default() -> Self {
            Self {
                area: Ok(Default::default()),
                boundary: Ok(Default::default()),
                boundary_dimension: Ok(Default::default()),
                centroid: Ok(Default::default()),
                coordinate: Ok(Default::default()),
                coordinate_sequence: Ok(Default::default()),
                coordinates: Ok(Default::default()),
                count: Ok(Default::default()),
                dimension: Ok(Default::default()),
                end_point: Ok(Default::default()),
                envelope: Ok(Default::default()),
                envelope_internal: Ok(Default::default()),
                factory: Ok(Default::default()),
                geometry_type: Ok(Default::default()),
                interior_point: Ok(Default::default()),
                is_ccw: Ok(Default::default()),
                is_closed: Ok(Default::default()),
                is_empty: Ok(Default::default()),
                is_rectangle: Ok(Default::default()),
                is_ring: Ok(Default::default()),
                is_simple: Ok(Default::default()),
                is_valid: Ok(Default::default()),
                length: Ok(Default::default()),
                num_geometries: Ok(Default::default()),
                num_points: Ok(Default::default()),
                ogc_geometry_type: Ok(Default::default()),
                point_on_surface: Ok(Default::default()),
                precision_model: Ok(Default::default()),
                srid: Ok(Default::default()),
                start_point: Ok(Default::default()),
                user_data: Ok(Default::default()),
            }
        }
    }
    impl NetTopologySuiteGeometriesLinearRing {
        pub fn area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.area = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for area: {}", e));
            self
        }
        pub fn boundary<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.boundary = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for boundary: {}", e)
                });
            self
        }
        pub fn boundary_dimension<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.boundary_dimension = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for boundary_dimension: {}", e
                    )
                });
            self
        }
        pub fn centroid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.centroid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for centroid: {}", e)
                });
            self
        }
        pub fn coordinate<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.coordinate = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for coordinate: {}", e)
                });
            self
        }
        pub fn coordinate_sequence<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::NetTopologySuiteGeometriesCoordinateSequence,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.coordinate_sequence = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for coordinate_sequence: {}", e
                    )
                });
            self
        }
        pub fn coordinates<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::vec::Vec<f64>>>,
            T::Error: ::std::fmt::Display,
        {
            self.coordinates = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for coordinates: {}", e)
                });
            self
        }
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for count: {}", e)
                });
            self
        }
        pub fn dimension<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.dimension = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for dimension: {}", e)
                });
            self
        }
        pub fn end_point<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.end_point = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for end_point: {}", e)
                });
            self
        }
        pub fn envelope<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.envelope = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for envelope: {}", e)
                });
            self
        }
        pub fn envelope_internal<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesEnvelope>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.envelope_internal = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for envelope_internal: {}", e
                    )
                });
            self
        }
        pub fn factory<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesGeometryFactory>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.factory = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for factory: {}", e)
                });
            self
        }
        pub fn geometry_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry_type: {}", e)
                });
            self
        }
        pub fn interior_point<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.interior_point = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for interior_point: {}", e)
                });
            self
        }
        pub fn is_ccw<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_ccw = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_ccw: {}", e)
                });
            self
        }
        pub fn is_closed<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_closed = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_closed: {}", e)
                });
            self
        }
        pub fn is_empty<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_empty = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_empty: {}", e)
                });
            self
        }
        pub fn is_rectangle<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_rectangle = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_rectangle: {}", e)
                });
            self
        }
        pub fn is_ring<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_ring = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_ring: {}", e)
                });
            self
        }
        pub fn is_simple<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_simple = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_simple: {}", e)
                });
            self
        }
        pub fn is_valid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_valid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_valid: {}", e)
                });
            self
        }
        pub fn length<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.length = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for length: {}", e)
                });
            self
        }
        pub fn num_geometries<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.num_geometries = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for num_geometries: {}", e)
                });
            self
        }
        pub fn num_points<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.num_points = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for num_points: {}", e)
                });
            self
        }
        pub fn ogc_geometry_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesOgcGeometryType>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ogc_geometry_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ogc_geometry_type: {}", e
                    )
                });
            self
        }
        pub fn point_on_surface<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.point_on_surface = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for point_on_surface: {}", e
                    )
                });
            self
        }
        pub fn precision_model<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModel>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.precision_model = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for precision_model: {}", e)
                });
            self
        }
        pub fn srid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.srid = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for srid: {}", e));
            self
        }
        pub fn start_point<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.start_point = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for start_point: {}", e)
                });
            self
        }
        pub fn user_data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::serde_json::Value>>,
            T::Error: ::std::fmt::Display,
        {
            self.user_data = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for user_data: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<NetTopologySuiteGeometriesLinearRing>
    for super::NetTopologySuiteGeometriesLinearRing {
        type Error = super::error::ConversionError;
        fn try_from(
            value: NetTopologySuiteGeometriesLinearRing,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                area: value.area?,
                boundary: value.boundary?,
                boundary_dimension: value.boundary_dimension?,
                centroid: value.centroid?,
                coordinate: value.coordinate?,
                coordinate_sequence: value.coordinate_sequence?,
                coordinates: value.coordinates?,
                count: value.count?,
                dimension: value.dimension?,
                end_point: value.end_point?,
                envelope: value.envelope?,
                envelope_internal: value.envelope_internal?,
                factory: value.factory?,
                geometry_type: value.geometry_type?,
                interior_point: value.interior_point?,
                is_ccw: value.is_ccw?,
                is_closed: value.is_closed?,
                is_empty: value.is_empty?,
                is_rectangle: value.is_rectangle?,
                is_ring: value.is_ring?,
                is_simple: value.is_simple?,
                is_valid: value.is_valid?,
                length: value.length?,
                num_geometries: value.num_geometries?,
                num_points: value.num_points?,
                ogc_geometry_type: value.ogc_geometry_type?,
                point_on_surface: value.point_on_surface?,
                precision_model: value.precision_model?,
                srid: value.srid?,
                start_point: value.start_point?,
                user_data: value.user_data?,
            })
        }
    }
    impl ::std::convert::From<super::NetTopologySuiteGeometriesLinearRing>
    for NetTopologySuiteGeometriesLinearRing {
        fn from(value: super::NetTopologySuiteGeometriesLinearRing) -> Self {
            Self {
                area: Ok(value.area),
                boundary: Ok(value.boundary),
                boundary_dimension: Ok(value.boundary_dimension),
                centroid: Ok(value.centroid),
                coordinate: Ok(value.coordinate),
                coordinate_sequence: Ok(value.coordinate_sequence),
                coordinates: Ok(value.coordinates),
                count: Ok(value.count),
                dimension: Ok(value.dimension),
                end_point: Ok(value.end_point),
                envelope: Ok(value.envelope),
                envelope_internal: Ok(value.envelope_internal),
                factory: Ok(value.factory),
                geometry_type: Ok(value.geometry_type),
                interior_point: Ok(value.interior_point),
                is_ccw: Ok(value.is_ccw),
                is_closed: Ok(value.is_closed),
                is_empty: Ok(value.is_empty),
                is_rectangle: Ok(value.is_rectangle),
                is_ring: Ok(value.is_ring),
                is_simple: Ok(value.is_simple),
                is_valid: Ok(value.is_valid),
                length: Ok(value.length),
                num_geometries: Ok(value.num_geometries),
                num_points: Ok(value.num_points),
                ogc_geometry_type: Ok(value.ogc_geometry_type),
                point_on_surface: Ok(value.point_on_surface),
                precision_model: Ok(value.precision_model),
                srid: Ok(value.srid),
                start_point: Ok(value.start_point),
                user_data: Ok(value.user_data),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct NetTopologySuiteGeometriesPolygon {
        area: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        boundary: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        boundary_dimension: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            ::std::string::String,
        >,
        centroid: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        coordinate: ::std::result::Result<::std::vec::Vec<f64>, ::std::string::String>,
        coordinates: ::std::result::Result<
            ::std::vec::Vec<::std::vec::Vec<f64>>,
            ::std::string::String,
        >,
        dimension: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            ::std::string::String,
        >,
        envelope: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        envelope_internal: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesEnvelope>,
            ::std::string::String,
        >,
        exterior_ring: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesLineString>,
            ::std::string::String,
        >,
        factory: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesGeometryFactory>,
            ::std::string::String,
        >,
        geometry_type: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        holes: ::std::result::Result<
            ::std::vec::Vec<super::NetTopologySuiteGeometriesLinearRing>,
            ::std::string::String,
        >,
        interior_point: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        interior_rings: ::std::result::Result<
            ::std::vec::Vec<super::NetTopologySuiteGeometriesLineString>,
            ::std::string::String,
        >,
        is_empty: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_rectangle: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_simple: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        is_valid: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        length: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
        num_geometries: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        num_interior_rings: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        num_points: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        ogc_geometry_type: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesOgcGeometryType>,
            ::std::string::String,
        >,
        point_on_surface: ::std::result::Result<
            ::std::option::Option<super::GeoJsonGeometry>,
            ::std::string::String,
        >,
        precision_model: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModel>,
            ::std::string::String,
        >,
        shell: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesLinearRing>,
            ::std::string::String,
        >,
        srid: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        user_data: ::std::result::Result<
            ::std::option::Option<::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for NetTopologySuiteGeometriesPolygon {
        fn default() -> Self {
            Self {
                area: Ok(Default::default()),
                boundary: Ok(Default::default()),
                boundary_dimension: Ok(Default::default()),
                centroid: Ok(Default::default()),
                coordinate: Ok(Default::default()),
                coordinates: Ok(Default::default()),
                dimension: Ok(Default::default()),
                envelope: Ok(Default::default()),
                envelope_internal: Ok(Default::default()),
                exterior_ring: Ok(Default::default()),
                factory: Ok(Default::default()),
                geometry_type: Ok(Default::default()),
                holes: Ok(Default::default()),
                interior_point: Ok(Default::default()),
                interior_rings: Ok(Default::default()),
                is_empty: Ok(Default::default()),
                is_rectangle: Ok(Default::default()),
                is_simple: Ok(Default::default()),
                is_valid: Ok(Default::default()),
                length: Ok(Default::default()),
                num_geometries: Ok(Default::default()),
                num_interior_rings: Ok(Default::default()),
                num_points: Ok(Default::default()),
                ogc_geometry_type: Ok(Default::default()),
                point_on_surface: Ok(Default::default()),
                precision_model: Ok(Default::default()),
                shell: Ok(Default::default()),
                srid: Ok(Default::default()),
                user_data: Ok(Default::default()),
            }
        }
    }
    impl NetTopologySuiteGeometriesPolygon {
        pub fn area<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.area = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for area: {}", e));
            self
        }
        pub fn boundary<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.boundary = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for boundary: {}", e)
                });
            self
        }
        pub fn boundary_dimension<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.boundary_dimension = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for boundary_dimension: {}", e
                    )
                });
            self
        }
        pub fn centroid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.centroid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for centroid: {}", e)
                });
            self
        }
        pub fn coordinate<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.coordinate = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for coordinate: {}", e)
                });
            self
        }
        pub fn coordinates<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::vec::Vec<f64>>>,
            T::Error: ::std::fmt::Display,
        {
            self.coordinates = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for coordinates: {}", e)
                });
            self
        }
        pub fn dimension<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesDimension>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.dimension = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for dimension: {}", e)
                });
            self
        }
        pub fn envelope<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.envelope = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for envelope: {}", e)
                });
            self
        }
        pub fn envelope_internal<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesEnvelope>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.envelope_internal = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for envelope_internal: {}", e
                    )
                });
            self
        }
        pub fn exterior_ring<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesLineString>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.exterior_ring = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for exterior_ring: {}", e)
                });
            self
        }
        pub fn factory<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesGeometryFactory>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.factory = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for factory: {}", e)
                });
            self
        }
        pub fn geometry_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.geometry_type = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for geometry_type: {}", e)
                });
            self
        }
        pub fn holes<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::NetTopologySuiteGeometriesLinearRing>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.holes = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for holes: {}", e)
                });
            self
        }
        pub fn interior_point<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.interior_point = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for interior_point: {}", e)
                });
            self
        }
        pub fn interior_rings<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<super::NetTopologySuiteGeometriesLineString>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.interior_rings = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for interior_rings: {}", e)
                });
            self
        }
        pub fn is_empty<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_empty = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_empty: {}", e)
                });
            self
        }
        pub fn is_rectangle<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_rectangle = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_rectangle: {}", e)
                });
            self
        }
        pub fn is_simple<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_simple = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_simple: {}", e)
                });
            self
        }
        pub fn is_valid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_valid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_valid: {}", e)
                });
            self
        }
        pub fn length<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.length = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for length: {}", e)
                });
            self
        }
        pub fn num_geometries<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.num_geometries = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for num_geometries: {}", e)
                });
            self
        }
        pub fn num_interior_rings<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.num_interior_rings = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for num_interior_rings: {}", e
                    )
                });
            self
        }
        pub fn num_points<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.num_points = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for num_points: {}", e)
                });
            self
        }
        pub fn ogc_geometry_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesOgcGeometryType>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ogc_geometry_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for ogc_geometry_type: {}", e
                    )
                });
            self
        }
        pub fn point_on_surface<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::GeoJsonGeometry>>,
            T::Error: ::std::fmt::Display,
        {
            self.point_on_surface = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for point_on_surface: {}", e
                    )
                });
            self
        }
        pub fn precision_model<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModel>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.precision_model = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for precision_model: {}", e)
                });
            self
        }
        pub fn shell<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesLinearRing>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.shell = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for shell: {}", e)
                });
            self
        }
        pub fn srid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.srid = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for srid: {}", e));
            self
        }
        pub fn user_data<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::serde_json::Value>>,
            T::Error: ::std::fmt::Display,
        {
            self.user_data = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for user_data: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<NetTopologySuiteGeometriesPolygon>
    for super::NetTopologySuiteGeometriesPolygon {
        type Error = super::error::ConversionError;
        fn try_from(
            value: NetTopologySuiteGeometriesPolygon,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                area: value.area?,
                boundary: value.boundary?,
                boundary_dimension: value.boundary_dimension?,
                centroid: value.centroid?,
                coordinate: value.coordinate?,
                coordinates: value.coordinates?,
                dimension: value.dimension?,
                envelope: value.envelope?,
                envelope_internal: value.envelope_internal?,
                exterior_ring: value.exterior_ring?,
                factory: value.factory?,
                geometry_type: value.geometry_type?,
                holes: value.holes?,
                interior_point: value.interior_point?,
                interior_rings: value.interior_rings?,
                is_empty: value.is_empty?,
                is_rectangle: value.is_rectangle?,
                is_simple: value.is_simple?,
                is_valid: value.is_valid?,
                length: value.length?,
                num_geometries: value.num_geometries?,
                num_interior_rings: value.num_interior_rings?,
                num_points: value.num_points?,
                ogc_geometry_type: value.ogc_geometry_type?,
                point_on_surface: value.point_on_surface?,
                precision_model: value.precision_model?,
                shell: value.shell?,
                srid: value.srid?,
                user_data: value.user_data?,
            })
        }
    }
    impl ::std::convert::From<super::NetTopologySuiteGeometriesPolygon>
    for NetTopologySuiteGeometriesPolygon {
        fn from(value: super::NetTopologySuiteGeometriesPolygon) -> Self {
            Self {
                area: Ok(value.area),
                boundary: Ok(value.boundary),
                boundary_dimension: Ok(value.boundary_dimension),
                centroid: Ok(value.centroid),
                coordinate: Ok(value.coordinate),
                coordinates: Ok(value.coordinates),
                dimension: Ok(value.dimension),
                envelope: Ok(value.envelope),
                envelope_internal: Ok(value.envelope_internal),
                exterior_ring: Ok(value.exterior_ring),
                factory: Ok(value.factory),
                geometry_type: Ok(value.geometry_type),
                holes: Ok(value.holes),
                interior_point: Ok(value.interior_point),
                interior_rings: Ok(value.interior_rings),
                is_empty: Ok(value.is_empty),
                is_rectangle: Ok(value.is_rectangle),
                is_simple: Ok(value.is_simple),
                is_valid: Ok(value.is_valid),
                length: Ok(value.length),
                num_geometries: Ok(value.num_geometries),
                num_interior_rings: Ok(value.num_interior_rings),
                num_points: Ok(value.num_points),
                ogc_geometry_type: Ok(value.ogc_geometry_type),
                point_on_surface: Ok(value.point_on_surface),
                precision_model: Ok(value.precision_model),
                shell: Ok(value.shell),
                srid: Ok(value.srid),
                user_data: Ok(value.user_data),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct NetTopologySuiteGeometriesPrecisionModel {
        grid_size: ::std::result::Result<
            ::std::option::Option<f64>,
            ::std::string::String,
        >,
        is_floating: ::std::result::Result<
            ::std::option::Option<bool>,
            ::std::string::String,
        >,
        maximum_significant_digits: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        precision_model_type: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModels>,
            ::std::string::String,
        >,
        scale: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
    }
    impl ::std::default::Default for NetTopologySuiteGeometriesPrecisionModel {
        fn default() -> Self {
            Self {
                grid_size: Ok(Default::default()),
                is_floating: Ok(Default::default()),
                maximum_significant_digits: Ok(Default::default()),
                precision_model_type: Ok(Default::default()),
                scale: Ok(Default::default()),
            }
        }
    }
    impl NetTopologySuiteGeometriesPrecisionModel {
        pub fn grid_size<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.grid_size = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for grid_size: {}", e)
                });
            self
        }
        pub fn is_floating<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<bool>>,
            T::Error: ::std::fmt::Display,
        {
            self.is_floating = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for is_floating: {}", e)
                });
            self
        }
        pub fn maximum_significant_digits<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.maximum_significant_digits = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for maximum_significant_digits: {}",
                        e
                    )
                });
            self
        }
        pub fn precision_model_type<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModels>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.precision_model_type = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for precision_model_type: {}", e
                    )
                });
            self
        }
        pub fn scale<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<f64>>,
            T::Error: ::std::fmt::Display,
        {
            self.scale = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for scale: {}", e)
                });
            self
        }
    }
    impl ::std::convert::TryFrom<NetTopologySuiteGeometriesPrecisionModel>
    for super::NetTopologySuiteGeometriesPrecisionModel {
        type Error = super::error::ConversionError;
        fn try_from(
            value: NetTopologySuiteGeometriesPrecisionModel,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                grid_size: value.grid_size?,
                is_floating: value.is_floating?,
                maximum_significant_digits: value.maximum_significant_digits?,
                precision_model_type: value.precision_model_type?,
                scale: value.scale?,
            })
        }
    }
    impl ::std::convert::From<super::NetTopologySuiteGeometriesPrecisionModel>
    for NetTopologySuiteGeometriesPrecisionModel {
        fn from(value: super::NetTopologySuiteGeometriesPrecisionModel) -> Self {
            Self {
                grid_size: Ok(value.grid_size),
                is_floating: Ok(value.is_floating),
                maximum_significant_digits: Ok(value.maximum_significant_digits),
                precision_model_type: Ok(value.precision_model_type),
                scale: Ok(value.scale),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct NetTopologySuiteNtsGeometryServices {
        coordinate_equality_comparer: ::std::result::Result<
            ::std::option::Option<
                super::NetTopologySuiteGeometriesCoordinateEqualityComparer,
            >,
            ::std::string::String,
        >,
        default_coordinate_sequence_factory: ::std::result::Result<
            ::std::option::Option<
                super::NetTopologySuiteGeometriesCoordinateSequenceFactory,
            >,
            ::std::string::String,
        >,
        default_precision_model: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModel>,
            ::std::string::String,
        >,
        default_srid: ::std::result::Result<
            ::std::option::Option<i32>,
            ::std::string::String,
        >,
        geometry_overlay: ::std::result::Result<
            ::std::option::Option<super::NetTopologySuiteGeometriesGeometryOverlay>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for NetTopologySuiteNtsGeometryServices {
        fn default() -> Self {
            Self {
                coordinate_equality_comparer: Ok(Default::default()),
                default_coordinate_sequence_factory: Ok(Default::default()),
                default_precision_model: Ok(Default::default()),
                default_srid: Ok(Default::default()),
                geometry_overlay: Ok(Default::default()),
            }
        }
    }
    impl NetTopologySuiteNtsGeometryServices {
        pub fn coordinate_equality_comparer<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::NetTopologySuiteGeometriesCoordinateEqualityComparer,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.coordinate_equality_comparer = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for coordinate_equality_comparer: {}",
                        e
                    )
                });
            self
        }
        pub fn default_coordinate_sequence_factory<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<
                    super::NetTopologySuiteGeometriesCoordinateSequenceFactory,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.default_coordinate_sequence_factory = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for default_coordinate_sequence_factory: {}",
                        e
                    )
                });
            self
        }
        pub fn default_precision_model<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesPrecisionModel>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.default_precision_model = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for default_precision_model: {}",
                        e
                    )
                });
            self
        }
        pub fn default_srid<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i32>>,
            T::Error: ::std::fmt::Display,
        {
            self.default_srid = value
                .try_into()
                .map_err(|e| {
                    format!("error converting supplied value for default_srid: {}", e)
                });
            self
        }
        pub fn geometry_overlay<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::NetTopologySuiteGeometriesGeometryOverlay>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.geometry_overlay = value
                .try_into()
                .map_err(|e| {
                    format!(
                        "error converting supplied value for geometry_overlay: {}", e
                    )
                });
            self
        }
    }
    impl ::std::convert::TryFrom<NetTopologySuiteNtsGeometryServices>
    for super::NetTopologySuiteNtsGeometryServices {
        type Error = super::error::ConversionError;
        fn try_from(
            value: NetTopologySuiteNtsGeometryServices,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                coordinate_equality_comparer: value.coordinate_equality_comparer?,
                default_coordinate_sequence_factory: value
                    .default_coordinate_sequence_factory?,
                default_precision_model: value.default_precision_model?,
                default_srid: value.default_srid?,
                geometry_overlay: value.geometry_overlay?,
            })
        }
    }
    impl ::std::convert::From<super::NetTopologySuiteNtsGeometryServices>
    for NetTopologySuiteNtsGeometryServices {
        fn from(value: super::NetTopologySuiteNtsGeometryServices) -> Self {
            Self {
                coordinate_equality_comparer: Ok(value.coordinate_equality_comparer),
                default_coordinate_sequence_factory: Ok(
                    value.default_coordinate_sequence_factory,
                ),
                default_precision_model: Ok(value.default_precision_model),
                default_srid: Ok(value.default_srid),
                geometry_overlay: Ok(value.geometry_overlay),
            }
        }
    }
}
